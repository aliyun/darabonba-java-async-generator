/**
 *
 */
import TeaAsyncHandler;
import TeaRequest;
import AsyncRequestBody;
import ClientConfiguration;
import ClientExecutionParams;
type @product = string
type @version = string
type @endpointRule = string
type @endpointMap = map[string]string
type @REQUEST = TeaRequest
type @handler = TeaAsyncHandler

init(configuration: ClientConfiguration){
  @handler = new TeaAsyncHandler(configuration);
  @product = 'Oss';
  @version = '2019-05-17';
  @endpointRule = '';
  @endpointMap = {
  };
}
model Delete {
  quiet?: boolean(name='Quiet', description='description'),
  objects?: [
    ObjectIdentifier
  ](name='Object', description='description'),
}

model Owner {
  ID?: string(name='ID', description='The ID of the owner'),
  displayName?: string(name='DisplayName', description='The display name of the owner'),
}

enum ObjectACL: string {
  PRIVATE(value='private', description='PRIVATE'),
  PUBLIC_READ(value='public-read', description='PUBLIC_READ'),
  PUBLIC_READ_WRITE(value='public-read-write', description='PUBLIC_READ_WRITE'),
  DEFAULT(value='default', description='DEFAULT'),
}

enum InventoryIncludedObjectVersions: string {
  ALL(value='All', description='ALL'),
  CURRENT(value='Current', description='CURRENT'),
}

model LiveChannelPublishUrls {
  url?: string(name='Url', description='description'),
}

model LiveChannelSnapshot {
  roleName?: string(name='RoleName', description='description'),
  destBucket?: string(name='DestBucket', description='description'),
  notifyTopic?: string(name='NotifyTopic', description='description'),
  interval?: long(name='Interval', description='description'),
}

model ReplicationRule {
  ID?: string(name='ID', description='rule id'),
  prefixSet?: ReplicationPrefixSet(name='PrefixSet'),
  action?: string(name='Action', description='A short description of action'),
  destination?: ReplicationDestination(name='Destination'),
  historicalObjectReplication?: string(name='HistoricalObjectReplication', description='A short description of HistoricalObjectReplication'),
  syncRole?: string(name='SyncRole', description='A short description of SyncRole'),
  sourceSelectionCriteria?: ReplicationSourceSelectionCriteria(name='SourceSelectionCriteria'),
  encryptionConfiguration?: {
    replicaKmsKeyID?: string(name='ReplicaKmsKeyID', description='kms id'),
  }(name='EncryptionConfiguration', description='A short description of EncryptionConfiguration'),
}

model LoggingEnabled {
  targetBucket?: string(name='TargetBucket', description='存储访问日志的存储空间'),
  targetPrefix?: string(name='TargetPrefix', description='保存的日志文件前缀'),
}

model CreateBucketConfiguration {
  storageClass?: StorageClass(name='StorageClass'),
  dataRedundancyType?: DataRedundancyType(name='DataRedundancyType'),
}

model LiveChannelPlayUrls {
  url?: string(name='Url', description='description'),
}

enum InventoryOptionalField: string {
  SIZE(value='Size', description='SIZE'),
  LASTMODIFIEDDATE(value='LastModifiedDate', description='LASTMODIFIEDDATE'),
  ETAG(value='ETag', description='ETAG'),
  STORAGECLASS(value='StorageClass', description='STORAGECLASS'),
  ISMULTIPARTUPLOADED(value='IsMultipartUploaded', description='ISMULTIPARTUPLOADED'),
  ENCRYPTIONSTATUS(value='EncryptionStatus', description='ENCRYPTIONSTATUS'),
}

model RestoreRequest {
  days?: long(name='Days', description='description'),
  jobParameters?: {
    tier?: string(name='Tier', description='description'),
  }(name='JobParameters', description='description'),
}

model LiveChannelConfiguration {
  description?: string(name='Description', description='description'),
  status?: string(name='Status', description='description'),
  target?: LiveChannelTarget(name='Target'),
  snapshot?: LiveChannelSnapshot(name='Snapshot'),
}

model LiveChannelTarget {
  type?: string(name='Type', description='description'),
  fragDuration?: long(name='FragDuration', description='description'),
  fragCount?: long(name='FragCount', description='description'),
}

model ReplicationConfiguration {
  rule?: ReplicationRule(name='Rule'),
}

model DeletedObject {
  key?: string(name='Key', description='description'),
  versionId?: string(name='VersionId', description='description'),
  deleteMarker?: boolean(name='DeleteMarker', description='description'),
  deleteMarkerVersionId?: string(name='DeleteMarkerVersionId', description='description'),
}

model ServerSideEncryptionRule {
  applyServerSideEncryptionByDefault?: ApplyServerSideEncryptionByDefault(name='ApplyServerSideEncryptionByDefault'),
}

model ReplicationDestination {
  bucket?: string(name='Bucket', description='The destination bucket to which the data is replicated'),
  location?: string(name='Location', description='The region in which the destination bucket is located'),
  transferType?: string(name='TransferType', description='The link used to transfer data in CRR'),
}

enum DataRedundancyType: string {
  LRS(value='LRS', description='LRS'),
  ZRS(value='ZRS', description='ZRS'),
}

model LifecycleRule {
  ID?: string(name='ID', description='规则标识'),
  prefix?: string(name='Prefix', description='指定规则所适用的前缀'),
  status?: string(name='Status', description='规则的状态'),
  lifecycleExpiration?: {
    createdBeforeDate?: string(name='CreatedBeforeDate', description='日期'),
    days?: int32(name='Days', description='天数'),
    expiredObjectDeleteMarker?: boolean(name='ExpiredObjectDeleteMarker', description='自动移除过期删除标记'),
  }(name='Expiration', description='过期属性'),
  lifecycleTransition?: [ 
    {
      createdBeforeDate?: string(name='CreatedBeforeDate', description='日期'),
      days?: int32(name='Days', description='天数'),
      storageClass?: StorageClass(name='StorageClass'),
    }
  ](name='Transition', description='存储类型转换'),
  lifecycleAbortMultipartUpload?: {
    days?: int32(name='Days', description='天数'),
    createdBeforeDate?: string(name='CreatedBeforeDate', description='日期'),
  }(name='AbortMultipartUpload', description='未完成分片上传的过期属性'),
  tag?: [ 
    {
      key?: string(name='Key', description='标签 key'),
      value?: string(name='Value', description='标签 value'),
    }
  ](name='Tag', description='标签列表'),
  noncurrentVersionExpiration?: {
    noncurrentDays?: int32(name='NoncurrentDays', description='天数'),
  }(name='NoncurrentVersionExpiration', description='非当前版本生命周期规则的过期属性'),
  noncurrentVersionTransition?: [ 
    {
      noncurrentDays?: int32(name='NoncurrentDays', description='天数'),
      storageClass?: StorageClass(name='StorageClass', description='存储类型'),
    }
  ](name='NoncurrentVersionTransition', description='非当前版本生命周期规则的转储属性'),
}

model ObjectVersion {
  key?: string(name='Key', description='The name of the object'),
  versionId?: string(name='VersionId', description='The version ID of the object'),
  isLatest?: boolean(name='IsLatest', description='Indicates whether the version is the current version'),
  lastModified?: string(name='LastModified', description='The last modified time of the object'),
  ETag?: string(name='ETag', description='The entity tag'),
  size?: long(name='Size', description='The size of the returned object'),
  storageClass?: StorageClass(name='StorageClass'),
  owner?: Owner(name='Owner', description='The information about the bucket owner'),
}

model BucketLoggingStatus {
  loggingEnabled?: LoggingEnabled(name='LoggingEnabled'),
}

model InventoryOSSBucketDestination {
  format?: InventoryFormat(name='Format'),
  accountId?: string(name='AccountId', description='The account ID granted by the bucket owner'),
  roleArn?: string(name='RoleArn', description='The name of the role to which the bucket owner grants permissions'),
  bucket?: string(name='Bucket', description='The bucket that stores the exported inventory list'),
  prefix?: string(name='Prefix', description='The path of the exported inventory list'),
}

model CORSConfiguration {
  CORSRule?: [
    CORSRule
  ](name='CORSRule', description='description'),
  responseVary?: boolean(name='ResponseVary', description='description'),
}

model ReplicationRuleProgress {
  ID?: string(name='ID', description='id'),
  prefixSet?: ReplicationPrefixSet(name='PrefixSet'),
  action?: string(name='Action', description='action'),
}

model Bucket {
  creationDate?: string(name='CreationDate', description='The time when the bucket is created.'),
  extranetEndpoint?: string(name='ExtranetEndpoint', description='The public endpoint used to access the bucket over the Internet.'),
  intranetEndpoint?: string(name='IntranetEndpoint', description='The internal endpoint used to access the bucket from ECS instances in the same region.'),
  location?: string(name='Location', description='The data center in which the bucket is located.'),
  name?: string(name='Name', description='The name of the bucket.'),
  region?: string(name='Region', description='The physical location of the bucket.'),
  storageClass?: StorageClass(name='StorageClass'),
}

model Part {
  ETag?: string(name='ETag', description='description'),
  partNumber?: long(name='PartNumber', description='description'),
  size?: long(name='Size', description='description'),
  lastModified?: string(name='LastModified', description='description'),
}

model LiveChannelAudio {
  bandwidth?: long(name='Bandwidth', description='description'),
  sampleRate?: long(name='SampleRate', description='description'),
  codec?: string(name='Codec', description='description'),
}

model RefererConfiguration {
  allowEmptyReferer?: boolean(name='AllowEmptyReferer', description='是否允许Referer字段为空的请求访问'),
  refererList?: {
    referer?: [ string ](name='Referer', description='指定一条Referer访问白名单'),
  }(name='RefererList', description='保存Referer访问白名单'),
}

enum InventoryFormat: string {
  CSV(value='CSV', description='CSV'),
}

model AccessControlList {
  grant?: string(name='Grant'),
}

model ApplyServerSideEncryptionByDefault {
  SSEAlgorithm?: string(name='SSEAlgorithm', description='description'),
  KMSMasterKeyID?: string(name='KMSMasterKeyID', description='description'),
  KMSDataEncryption?: string(name='KMSDataEncryption', description='description'),
}

model AccessControlPolicy {
  owner?: Owner(name='Owner'),
  accessControlList?: AccessControlList(name='AccessControlList'),
}

model InventoryFilter {
  prefix?: string(name='Prefix', description='The prefix specified in the inventory rule'),
}

model WebsiteConfiguration {
  indexDocument?: {
    suffix?: string(name='Suffix', description='description'),
  }(name='IndexDocument', description='description'),
  errorDocument?: {
    key?: string(name='Key', description='description'),
    httpStatus?: string(name='HttpStatus', description='description'),
  }(name='ErrorDocument', description='description'),
}

model DeleteMarkerEntry {
  key?: string(name='Key', description='The name of the object'),
  versionId?: string(name='VersionId', description='The version ID of the object'),
  isLatest?: boolean(name='IsLatest', description='Indicates whether the version is the current version'),
  lastModified?: string(name='LastModified', description='The last modified time of the object'),
  owner?: Owner(name='Owner'),
}

model InitiateWormConfiguration {
  retentionPeriodInDays?: int32(name='RetentionPeriodInDays', description='The number of days for which objects can be retained'),
}

model Upload {
  key?: string(name='Key', description='description'),
  uploadId?: string(name='UploadId', description='description'),
  initiated?: string(name='Initiated', description='description'),
}

model InventoryEncryption {
  SSEOSS?: string(name='SSE-OSS', description='The container that stores the information about the SSE-OSS encryption method'),
  SSEKMS?: SSEKMS(name='SSE-KMS', description='The container that stores the CMK used in the SSE-KMS encryption method'),
}

model LiveChannelVideo {
  width?: long(name='Width', description='description'),
  height?: long(name='Height', description='description'),
  frameRate?: long(name='FrameRate', description='description'),
  bandwidth?: long(name='Bandwidth', description='description'),
  codec?: string(name='Codec', description='description'),
}

model ExtendWormConfiguration {
  retentionPeriodInDays?: int32(name='RetentionPeriodInDays', description='The number of days for which objects can be retained'),
}

model InventoryDestination {
  OSSBucketDestination?: InventoryOSSBucketDestination(name='OSSBucketDestination', description='The information about the bucket that stores the exported inventory list'),
}

enum BucketACL: string {
  PRIVATE(value='private', description='PRIVATE'),
  PUBLIC_READ(value='public-read', description='PUBLIC_READ'),
  PUBLIC_READ_WRITE(value='public-read-write', description='PUBLIC_READ_WRITE'),
}

model CopyObjectResult {
  ETag?: string(name='ETag', description='description'),
  lastModified?: string(name='LastModified', description='description'),
}

model LiveRecord {
  startTime?: string(name='StartTime', description='description'),
  endTime?: string(name='EndTime', description='description'),
  remoteAddr?: string(name='RemoteAddr', description='description'),
}

enum BucketWormState: string {
  INPROGRESS(value='InProgress', description='INPROGRESS'),
  LOCKED(value='Locked', description='LOCKED'),
}

model ObjectSummary {
  key?: string(name='Key', description='The name of the object.'),
  lastModified?: string(name='LastModified', description='The last modification time of the object.'),
  ETag?: string(name='ETag', description='The entity tag is a hash of the object.'),
  type?: string(name='Type', description='The type of the object.'),
  size?: long(name='Size', description='The size in bytes of the object'),
  storageClass?: StorageClass(name='StorageClass'),
  owner?: Owner(name='Owner'),
}

model SelectRequest {
  expression?: string(name='Expression', description='description'),
}

model RequestPaymentConfiguration {
  payer?: string(name='Payer', description='description'),
}

model ObjectIdentifier {
  key?: string(name='Key', description='key'),
  versionId?: string(name='VersionId', description='version id'),
}

model CommonPrefix {
  prefix?: string(name='Prefix', description='The prefix that the names of returned objects contain'),
}

enum BucketVersioningStatus: string {
  ENABLED(value='Enabled', description='ENABLED'),
  SUSPENDED(value='Suspended', description='SUSPENDED'),
}

enum StorageClass: string {
  STANDARD(value='Standard', description='STANDARD'),
  IA(value='IA', description='IA'),
  ARCHIVE(value='Archive', description='ARCHIVE'),
  COLDARCHIVE(value='ColdArchive', description='COLDARCHIVE'),
}

enum EncodeType: string {
  URL(value='url', description='URL'),
}

model ReplicationPrefixSet {
  prefixs?: [ string ](name='Prefix', description='Prefixs used to specify the object to replicate'),
}

model CORSRule {
  allowedOrigin?: [ string ](name='AllowedOrigin', description='description'),
  allowedMethod?: [ string ](name='AllowedMethod', description='description'),
  allowedHeader?: string(name='AllowedHeader', description='description'),
  exposeHeader?: [ string ](name='ExposeHeader', description='description'),
  maxAgeSeconds?: long(name='MaxAgeSeconds', description='description'),
}

model Error {
  code?: string(name='Code', description='The error code that OSS returns to the user'),
  message?: string(name='Message', description='The detailed error message provided by OSS'),
  requestId?: string(name='RequestId', description='The ID that uniquely identifies a request'),
  hostId?: string(name='HostId', description='The ID of the host in the accessed OSS cluster'),
}

model LifecycleConfiguration {
  rule?: [
    LifecycleRule
  ](name='Rule', description='生命周期规则'),
}

model InventoryConfiguration {
  id?: string(name='Id', description='The specified inventory list name, which must be globally unique in the bucket'),
  isEnabled?: boolean(name='IsEnabled', description='Indicates whether the inventory function is enabled'),
  destination?: InventoryDestination(name='Destination'),
  schedule?: InventorySchedule(name='Schedule'),
  filter?: InventoryFilter(name='Filter'),
  includedObjectVersions?: InventoryIncludedObjectVersions(name='IncludedObjectVersions'),
  optionalFields?: [
    InventoryOptionalField
  ](name='OptionalFields', description='The container that stores the configuration fields included in the inventory list'),
}

enum InventoryFrequency: string {
  DAILY(value='Daily', description='DAILY'),
  WEEKLY(value='Weekly', description='WEEKLY'),
}

model VersioningConfiguration {
  status?: BucketVersioningStatus(name='Status'),
}

model CompleteMultipartUpload {
  part?: [
    Part
  ](name='Part', description='description'),
}

model LocationTransferType {
  location?: string(name='Location', description='The region in which the destination bucket can be located'),
  transferTypes?: {
    type?: string(name='Type', description='The link used to transfer data in Cross-region replication'),
  }(name='TransferTypes', description='The container that stores the transmission type'),
}

model TransferAccelerationConfiguration {
  enabled?: boolean(name='Enabled', description='是否开启传输加速'),
}

model InventorySchedule {
  frequency?: InventoryFrequency(name='Frequency'),
}

model SSEKMS {
  keyId?: string(name='KeyId', description='The CMK used in the SSE-KMS encryption method'),
}

model Tagging {
  tagSet?: [
    Tag
  ](name='TagSet', description='Tag 的容器'),
}

model Tag {
  key?: string(name='Key', description='key'),
  value?: string(name='Value', description='value'),
}

model LiveChannel {
  name?: string(name='Name', description='description'),
  description?: string(name='Description', description='description'),
  status?: string(name='Status', description='description'),
  lastModified?: string(name='LastModified', description='description'),
  publishUrls?: LiveChannelPublishUrls(name='PublishUrls'),
  playUrls?: LiveChannelPlayUrls(name='PlayUrls'),
}

model ReplicationSourceSelectionCriteria {
  sseKmsEncryptedObjects?: {
    status?: string(name='Status', description='A short description of Status'),
  }(name='SseKmsEncryptedObjects', description='A short description of SseKmsEncryptedObjects'),
}

model GetBucketLocationRequest {
  bucket?: string(name='bucket', position='Host'),
}

model GetBucketLocationResponseBody = {
  locationConstraint?: string(name='LocationConstraint', parentIgnore='LocationConstraint'),
}

model GetBucketLocationResponse = {
  headers: map[string]string(name='headers'),
  body: GetBucketLocationResponseBody(name='body'),
}

async function getBucketLocation(request: GetBucketLocationRequest): GetBucketLocationResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'GetBucketLocation', 'GET', '/?location', 'xml', false, 'xml', request);
}

model GetBucketCORSRequest {
  bucket?: string(name='bucket', position='Host'),
}

model GetBucketCORSResponseBody = {
  CORSRule?: [
    CORSRule
  ](name='CORSRule', parentIgnore='CORSConfiguration'),
  responseVary?: boolean(name='ResponseVary', parentIgnore='CORSConfiguration'),
}

model GetBucketCORSResponse = {
  headers: map[string]string(name='headers'),
  body: GetBucketCORSResponseBody(name='body'),
}

async function getBucketCORS(request: GetBucketCORSRequest): GetBucketCORSResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'GetBucketCORS', 'GET', '/?cors', 'xml', false, 'xml', request);
}

model PostVodPlaylistRequest {
  bucket?: string(name='bucket', position='Host'),
  channel?: string(name='channel', position='Path'),
  playlist?: string(name='playlist', position='Path'),
  endTime?: string(name='endTime', position='Query'),
  startTime?: string(name='startTime', position='Query'),
}

model PostVodPlaylistResponse = {
  headers: map[string]string(name='headers'),
}

async function postVodPlaylist(request: PostVodPlaylistRequest): PostVodPlaylistResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'PostVodPlaylist', 'POST', '/{channel}/{playlist}?vod', 'xml', false, 'xml', request);
}

model CompleteBucketWormRequest {
  bucket?: string(name='bucket', position='Host'),
  wormId?: string(name='wormId', description='The ID of the retention policy', position='Query'),
}

model CompleteBucketWormResponse = {
  headers: map[string]string(name='headers'),
}

async function completeBucketWorm(request: CompleteBucketWormRequest): CompleteBucketWormResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'CompleteBucketWorm', 'POST', '/', 'xml', false, 'xml', request);
}

model PutBucketReplicationRequest {
  bucket?: string(name='bucket', position='Host'),
  replicationConfiguration?: ReplicationConfiguration(name='replicationConfiguration', position='Body'),
}

model PutBucketReplicationResponse = {
  headers: map[string]string(name='headers'),
}

async function putBucketReplication(request: PutBucketReplicationRequest): PutBucketReplicationResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'PutBucketReplication', 'POST', '/?replication&comp=add', 'xml', true, 'xml', request);
}

model ExtendBucketWormRequest {
  bucket?: string(name='bucket', position='Host'),
  wormId?: string(name='wormId', position='Query'),
  extendWormConfiguration?: ExtendWormConfiguration(name='extendWormConfiguration', position='Body'),
}

model ExtendBucketWormResponse = {
  headers: map[string]string(name='headers'),
}

async function extendBucketWorm(request: ExtendBucketWormRequest): ExtendBucketWormResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'ExtendBucketWorm', 'POST', '/?wormExtend', 'xml', true, 'xml', request);
}

model PutObjectRequest {
  bucket?: string(name='bucket', position='Host'),
  key?: string(name='key', position='Path'),
  forbidOverwrite?: boolean(name='x-oss-forbid-overwrite', position='Header'),
  sse?: string(name='x-oss-server-side-encryption', position='Header'),
  sseDataEncryption?: string(name='x-oss-server-side-data-encryption', position='Header'),
  sseKeyId?: string(name='x-oss-server-side-encryption-key-id', position='Header'),
  acl?: ObjectACL(name='x-oss-object-acl', position='Header'),
  storageClass?: StorageClass(name='x-oss-storage-class', position='Header'),
  tagging?: string(name='x-oss-tagging', position='Header'),
  userMetadata?: map[string]string(name='x-oss-meta-*', position='Header'),
  body?: readable(name='body', position='Body'),
}

model PutObjectResponse = {
  headers: map[string]string(name='headers'),
}

async function putObject(request: PutObjectRequest): PutObjectResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'PutObject', 'PUT', '/{key}', 'binary', false, 'binary', request);
}

async function putObjectWithRequestBody(request: PutObjectRequest, requestBody: AsyncRequestBody): PutObjectResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'PutObject', 'PUT', '/{key}', 'binary', false, 'binary', request);
}

model DeleteBucketInventoryRequest {
  bucket?: string(name='bucket', position='Host'),
  inventoryId?: string(name='inventoryId', description='The ID of the inventory task to delete', position='Query'),
}

model DeleteBucketInventoryResponse = {
  headers: map[string]string(name='headers'),
}

async function deleteBucketInventory(request: DeleteBucketInventoryRequest): DeleteBucketInventoryResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'DeleteBucketInventory', 'DELETE', '/?inventory', 'xml', false, 'xml', request);
}

model GetBucketWormRequest {
  bucket?: string(name='bucket', position='Host'),
}

model GetBucketWormResponseBody = {
  wormId?: string(name='WormId', parentIgnore='WormConfiguration'),
  state?: BucketWormState(name='State', parentIgnore='WormConfiguration'),
  retentionPeriodInDays?: long(name='RetentionPeriodInDays', parentIgnore='WormConfiguration'),
  creationDate?: string(name='CreationDate', parentIgnore='WormConfiguration'),
}

model GetBucketWormResponse = {
  headers: map[string]string(name='headers'),
  body: GetBucketWormResponseBody(name='body'),
}

async function getBucketWorm(request: GetBucketWormRequest): GetBucketWormResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'GetBucketWorm', 'GET', '/?worm', 'xml', false, 'xml', request);
}

model PutBucketInventoryRequest {
  bucket?: string(name='bucket', position='Host'),
  inventoryId?: string(name='inventoryId', position='Query'),
  inventoryConfiguration?: InventoryConfiguration(name='inventoryConfiguration', position='Body'),
}

model PutBucketInventoryResponse = {
  headers: map[string]string(name='headers'),
}

async function putBucketInventory(request: PutBucketInventoryRequest): PutBucketInventoryResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'PutBucketInventory', 'PUT', '/?inventory', 'xml', true, 'xml', request);
}

model GetBucketInventoryRequest {
  bucket?: string(name='bucket', position='Host'),
  inventoryId?: string(name='inventoryId', description='The ID of the inventory rule to query', position='Query'),
}

model GetBucketInventoryResponseBody = {
  id?: string(name='Id', description='id', parentIgnore='InventoryConfiguration'),
  isEnabled?: boolean(name='IsEnabled', description='status', parentIgnore='InventoryConfiguration'),
  destination?: InventoryDestination(name='Destination', parentIgnore='InventoryConfiguration'),
  schedule?: InventorySchedule(name='Schedule', parentIgnore='InventoryConfiguration'),
  filter?: InventoryFilter(name='Filter', parentIgnore='InventoryConfiguration'),
  includedObjectVersions?: InventoryIncludedObjectVersions(name='IncludedObjectVersions', parentIgnore='InventoryConfiguration'),
  optionalFields?: {
    field?: [
      InventoryOptionalField
    ](name='Field'),
  }(name='OptionalFields', parentIgnore='InventoryConfiguration'),
}

model GetBucketInventoryResponse = {
  headers: map[string]string(name='headers'),
  body: GetBucketInventoryResponseBody(name='body'),
}

async function getBucketInventory(request: GetBucketInventoryRequest): GetBucketInventoryResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'GetBucketInventory', 'GET', '/?inventory', 'xml', false, 'xml', request);
}

model UploadPartCopyRequest {
  bucket?: string(name='bucket', position='Host'),
  key?: string(name='key', position='Path'),
  sourceBucket?: string(name='source-bucket', position='Header'),
  sourceKey?: string(name='source-key', position='Header'),
  partNumber?: string(name='partNumber', position='Query'),
  uploadId?: string(name='uploadId', position='Query'),
  xOssCopySourceRange?: string(name='x-oss-copy-source-range', position='Header'),
  xOssCopySourceIfMatch?: string(name='x-oss-copy-source-if-match', position='Header'),
  xOssCopySourceIfNoneMatch?: string(name='x-oss-copy-source-if-none-match', position='Header'),
  xOssCopySourceIfUnmodifiedSince?: string(name='x-oss-copy-source-if-unmodified-since', position='Header'),
  xOssCopySourceIfModifiedSince?: string(name='x-oss-copy-source-if-modified-since', position='Header'),
}

model UploadPartCopyResponseBody = {
  lastModified?: string(name='LastModified'),
  ETag?: string(name='ETag'),
}

model UploadPartCopyResponse = {
  headers: map[string]string(name='headers'),
  body: UploadPartCopyResponseBody(name='body'),
}

async function uploadPartCopy(request: UploadPartCopyRequest): UploadPartCopyResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'UploadPartCopy', 'PUT', '/{key}', 'xml', false, 'binary', request);
}

model DeleteBucketWebsiteRequest {
  bucket?: string(name='bucket', position='Host'),
}

model DeleteBucketWebsiteResponse = {
  headers: map[string]string(name='headers'),
}

async function deleteBucketWebsite(request: DeleteBucketWebsiteRequest): DeleteBucketWebsiteResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'DeleteBucketWebsite', 'DELETE', '/?website', 'xml', false, 'xml', request);
}

model GetBucketTagsRequest {
  bucket?: string(name='bucket', position='Host'),
}

model GetBucketTagsResponseBody = {
  tagSet?: [
    Tag
  ](name='TagSet', parentIgnore='Tagging'),
}

model GetBucketTagsResponse = {
  headers: map[string]string(name='headers'),
  body: GetBucketTagsResponseBody(name='body'),
}

async function getBucketTags(request: GetBucketTagsRequest): GetBucketTagsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'GetBucketTags', 'GET', '/?tagging', 'xml', false, 'xml', request);
}

model InitiateMultipartUploadRequest {
  bucket?: string(name='bucket', position='Host'),
  key?: string(name='key', position='Path'),
  encodingType?: string(name='encoding-type', position='Query'),
  xOssForbidOverwrite?: string(name='x-oss-forbid-overwrite', position='Header'),
  xOssStorageClass?: string(name='x-oss-storage-class', position='Header'),
  xOssTagging?: string(name='x-oss-tagging', position='Header'),
  xOssServerSideEncryption?: string(name='x-oss-server-side-encryption', position='Header'),
  xOssServerSideDataEncryption?: string(name='x-oss-server-side-data-encryption', position='Header'),
  xOssServerSideEncryptionKeyId?: string(name='x-oss-server-side-encryption-key-id', position='Header'),
}

model InitiateMultipartUploadResponseBody = {
  bucket?: string(name='Bucket', parentIgnore='InitiateMultipartUploadResult'),
  key?: string(name='Key', parentIgnore='InitiateMultipartUploadResult'),
  uploadId?: string(name='UploadId', parentIgnore='InitiateMultipartUploadResult'),
  encodingType?: string(name='EncodingType', parentIgnore='InitiateMultipartUploadResult'),
}

model InitiateMultipartUploadResponse = {
  headers: map[string]string(name='headers'),
  body: InitiateMultipartUploadResponseBody(name='body'),
}

async function initiateMultipartUpload(request: InitiateMultipartUploadRequest): InitiateMultipartUploadResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'InitiateMultipartUpload', 'POST', '/{key}?uploads', 'xml', false, 'xml', request);
}

model DeleteObjectTaggingRequest {
  bucket?: string(name='bucket', position='Host'),
  key?: string(name='key', position='Path'),
}

model DeleteObjectTaggingResponse = {
  headers: map[string]string(name='headers'),
}

async function deleteObjectTagging(request: DeleteObjectTaggingRequest): DeleteObjectTaggingResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'DeleteObjectTagging', 'DELETE', '/{key}?tagging', 'xml', false, 'xml', request);
}

model PutBucketWebsiteRequest {
  bucket?: string(name='bucket', position='Host'),
  websiteConfiguration?: WebsiteConfiguration(name='websiteConfiguration', position='Body'),
}

model PutBucketWebsiteResponse = {
  headers: map[string]string(name='headers'),
}

async function putBucketWebsite(request: PutBucketWebsiteRequest): PutBucketWebsiteResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'PutBucketWebsite', 'PUT', '/?website', 'xml', true, 'xml', request);
}

model HeadObjectRequest {
  bucket?: string(name='bucket', position='Host'),
  key?: string(name='key', position='Path'),
  ifModifiedSince?: string(name='If-Modified-Since', position='Header'),
  ifUnmodifiedSince?: string(name='If-Unmodified-Since', position='Header'),
  ifMatch?: string(name='If-Match', position='Header'),
  ifNoneMatch?: string(name='If-None-Match', position='Header'),
}

model HeadObjectResponse = {
  headers: map[string]string(name='headers'),
}

async function headObject(request: HeadObjectRequest): HeadObjectResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'HeadObject', 'HEAD', '/{key}', 'xml', false, 'xml', request);
}

model GetBucketReplicationRequest {
  bucket?: string(name='bucket', position='Host'),
}

model GetBucketReplicationResponseBody = {
  rule?: [
    ReplicationRule
  ](name='Rule', parentIgnore='ReplicationConfiguration'),
}

model GetBucketReplicationResponse = {
  headers: map[string]string(name='headers'),
  body: GetBucketReplicationResponseBody(name='body'),
}

async function getBucketReplication(request: GetBucketReplicationRequest): GetBucketReplicationResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'GetBucketReplication', 'GET', '/?replication', 'xml', false, 'xml', request);
}

model GetBucketAclRequest {
  bucket?: string(name='bucket', position='Host'),
}

model GetBucketAclResponseBody = {
  owner?: Owner(name='Owner', parentIgnore='AccessControlPolicy'),
  accessControlList?: {
    grant?: BucketACL(name='Grant'),
  }(name='AccessControlList', parentIgnore='AccessControlPolicy'),
}

model GetBucketAclResponse = {
  headers: map[string]string(name='headers'),
  body: GetBucketAclResponseBody(name='body'),
}

async function getBucketAcl(request: GetBucketAclRequest): GetBucketAclResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'GetBucketAcl', 'GET', '/?acl', 'xml', false, 'xml', request);
}

model GetSymlinkRequest {
  bucket?: string(name='bucket', position='Host'),
  key?: string(name='key', position='Query'),
}

model GetSymlinkResponse = {
  headers: map[string]string(name='headers'),
}

async function getSymlink(request: GetSymlinkRequest): GetSymlinkResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'GetSymlink', 'GET', '/{key}?symlink', 'xml', false, 'xml', request);
}

model DeleteBucketRequest {
  bucket?: string(name='bucket', position='Host'),
}

model DeleteBucketResponse = {
  headers: map[string]string(name='headers'),
}

async function deleteBucket(request: DeleteBucketRequest): DeleteBucketResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'DeleteBucket', 'DELETE', '/', 'xml', false, 'xml', request);
}

model DeleteMultipleObjectsRequest {
  bucket?: string(name='bucket', position='Host'),
  delete?: Delete(name='delete', position='Body'),
  encodingType?: string(name='encoding-type', position='Query'),
}

model DeleteMultipleObjectsResponseBody = {
  deleted?: [
    DeletedObject
  ](name='Deleted', parentIgnore='DeleteResult'),
}

model DeleteMultipleObjectsResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteMultipleObjectsResponseBody(name='body'),
}

async function deleteMultipleObjects(request: DeleteMultipleObjectsRequest): DeleteMultipleObjectsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'DeleteMultipleObjects', 'POST', '/?delete', 'xml', true, 'xml', request);
}

model OptionObjectRequest {
  bucket?: string(name='bucket', position='Host'),
  key?: string(name='key', position='Path'),
  origin?: string(name='Origin', position='Header'),
  accessControlRequestMethod?: string(name='AccessControlRequestMethod', position='Header'),
  accessControlRequestHeaders?: string(name='AccessControlRequestHeaders', position='Header'),
}

model OptionObjectResponse = {
  headers: map[string]string(name='headers'),
}

async function optionObject(request: OptionObjectRequest): OptionObjectResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'OptionObject', 'OPTIONS', '/{key}', 'xml', false, 'xml', request);
}

model ListObjectVersionsRequest {
  bucket?: string(name='bucket', position='Host'),
  delimiter?: string(name='delimiter', description='The character used to group objects by name', position='Query'),
  keyMarker?: string(name='key-marker', description='The name of the object from which the list operation begins', position='Query'),
  versionIdMarker?: string(name='version-id-marker', description='The version id of the object from which the list operation begins', position='Query'),
  maxKeys?: long(name='max-keys', description='The maximum number of objects to return', position='Query'),
  prefix?: string(name='prefix', description='The prefix that the returned object names must contain', position='Query'),
  encodingType?: EncodeType(name='encoding-type', description='The encoding type of the object name in the response', position='Query'),
}

model ListObjectVersionsResponseBody = {
  name?: string(name='Name', description='The bucket name', parentIgnore='ListVersionsResult'),
  prefix?: string(name='Prefix', description='The prefix that the names of returned objects must contain', parentIgnore='ListVersionsResult'),
  keyMarker?: string(name='KeyMarker', description='Indicates the object from which the operation starts', parentIgnore='ListVersionsResult'),
  versionIdMarker?: string(name='VersionIdMarker', description='This parameter is returned with KeyMarker together to indicate the version from which the operation starts', parentIgnore='ListVersionsResult'),
  maxKeys?: long(name='MaxKeys', description='The maximum number of returned objects in the response', parentIgnore='ListVersionsResult'),
  isTruncated?: boolean(name='IsTruncated', description='Indicates whether the returned results are truncated', parentIgnore='ListVersionsResult'),
  encodingType?: string(name='EncodingType', parentIgnore='ListVersionsResult'),
  versions?: [
    ObjectVersion
  ](name='Version', description='The container that stores the versions of objects except for delete markers', parentIgnore='ListVersionsResult'),
  deleteMarkers?: [
    DeleteMarkerEntry
  ](name='DeleteMarker', description='The container that stores delete markers', parentIgnore='ListVersionsResult'),
  commonPrefixes?: [
    CommonPrefix
  ](name='CommonPrefixes', description='Objects whose names contain the same string that ranges from the prefix to the next occurrence of the delimiter are grouped as a single result element', parentIgnore='ListVersionsResult'),
}

model ListObjectVersionsResponse = {
  headers: map[string]string(name='headers'),
  body: ListObjectVersionsResponseBody(name='body'),
}

async function listObjectVersions(request: ListObjectVersionsRequest): ListObjectVersionsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'ListObjectVersions', 'GET', '/?versions', 'xml', false, 'xml', request);
}

model GetBucketPolicyRequest {
  bucket?: string(name='bucket', position='Host'),
}

model GetBucketPolicyResponse = {
  headers: map[string]string(name='headers'),
  body: string(name='body'),
}

async function getBucketPolicy(request: GetBucketPolicyRequest): GetBucketPolicyResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'GetBucketPolicy', 'GET', '/?policy', 'string', false, 'json', request);
}

model GetObjectRequest {
  bucket?: string(name='bucket', position='Host'),
  key?: string(name='key', position='Path'),
  responseContentType?: string(name='response-content-type', position='Query'),
  responseContentLanguage	?: string(name='response-content-language', position='Query'),
  responseExpires	?: string(name='response-expires', position='Query'),
  responseCacheControl	?: string(name='response-cache-control', position='Query'),
  responseContentDisposition	?: string(name='response-content-disposition', position='Query'),
  responseContentEncoding	?: string(name='response-content-encoding', position='Query'),
  range?: string(name='Range', position='Header'),
  ifModifiedSince?: string(name='If-Modified-Since', position='Header'),
  ifUnmodifiedSince	?: string(name='If-Unmodified-Since', position='Header'),
  ifMatch	?: string(name='If-Match', position='Header'),
  ifNoneMatch	?: string(name='If-None-Match', position='Header'),
  acceptEncoding	?: string(name='Accept-Encoding', position='Header'),
}

model GetObjectResponse = {
  headers: map[string]string(name='headers'),
}

async function getObject(request: GetObjectRequest): GetObjectResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'GetObject', 'GET', '/{key}', 'binary', false, 'binary', request);
}

model InitiateBucketWormRequest {
  bucket?: string(name='bucket', position='Host'),
  initiateWormConfiguration?: InitiateWormConfiguration(name='initiateWormConfiguration', position='Body'),
}

model InitiateBucketWormResponse = {
  headers: map[string]string(name='headers'),
}

async function initiateBucketWorm(request: InitiateBucketWormRequest): InitiateBucketWormResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'InitiateBucketWorm', 'POST', '/?worm', 'xml', true, 'xml', request);
}

model GetBucketRequest {
  bucket?: string(name='bucket', position='Host'),
  delimiter?: string(name='delimiter', position='Query'),
  marker?: string(name='marker', position='Query'),
  maxKeys?: long(name='max-keys', position='Query'),
  prefix?: string(name='prefix', position='Query'),
  encodingType?: EncodeType(name='encoding-type', position='Query'),
}

model GetBucketResponseBody = {
  name?: string(name='Name', description='The bucket name', parentIgnore='ListBucketResult'),
  prefix?: string(name='Prefix', description='The prefix that the names of returned objects contain', parentIgnore='ListBucketResult'),
  marker?: string(name='Marker', description='The name of the object from which the list operation begins', parentIgnore='ListBucketResult'),
  maxKeys?: int32(name='MaxKeys', description='The maximum number of returned objects in the response', parentIgnore='ListBucketResult'),
  delimiter?: string(name='Delimiter', description='The character used to group objects by name', parentIgnore='ListBucketResult'),
  isTruncated?: boolean(name='IsTruncated', description='Indicates whether the returned results are truncated', parentIgnore='ListBucketResult'),
  contents?: [
    ObjectSummary
  ](name='Contents', description='The container that stores the returned object metadata', parentIgnore='ListBucketResult'),
  commonPrefixes?: [
    CommonPrefix
  ](name='CommonPrefixes', description='Objects whose names contain the same string that ranges from the prefix to the next occurrence of the delimiter are grouped as a single result element', parentIgnore='ListBucketResult'),
}

model GetBucketResponse = {
  headers: map[string]string(name='headers'),
  body: GetBucketResponseBody(name='body'),
}

async function getBucket(request: GetBucketRequest): GetBucketResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'GetBucket', 'GET', '/', 'xml', false, 'xml', request);
}

model PutObjectTaggingRequest {
  bucket?: string(name='bucket', position='Host'),
  key?: string(name='key', position='Path'),
  tagging?: Tagging(name='tagging', position='Body'),
}

model PutObjectTaggingResponse = {
  headers: map[string]string(name='headers'),
}

async function putObjectTagging(request: PutObjectTaggingRequest): PutObjectTaggingResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'PutObjectTagging', 'PUT', '/{key}?tagging', 'xml', true, 'xml', request);
}

model CopyObjectRequest {
  bucket?: string(name='bucket', position='Host'),
  key?: string(name='key', position='Path'),
  sourceBucket?: string(name='source-bucket', position='Header'),
  sourceKey?: string(name='source-key', position='Header'),
  forbidOverwrite?: string(name='x-oss-forbid-overwrite', position='Header'),
  copySourceIfMatch?: string(name='x-oss-copy-source-if-match', position='Header'),
  copySourceIfNoneMatch?: string(name='x-oss-copy-source-if-none-match', position='Header'),
  copySourceIfUnmodifiedSince?: string(name='x-oss-copy-source-if-unmodified-since', position='Header'),
  copySourceIfModifiedSince?: string(name='x-oss-copy-source-if-modified-since', position='Header'),
  metadataDirective?: string(name='x-oss-metadata-directive', position='Header'),
  sse?: string(name='x-oss-server-side-encryption', position='Header'),
  sseKeyId?: string(name='x-oss-server-side-encryption-key-id', position='Header'),
  acl?: string(name='x-oss-object-acl', position='Header'),
  storageClass?: string(name='x-oss-storage-class', position='Header'),
  tagging?: string(name='x-oss-tagging', position='Header'),
}

model CopyObjectResponseBody = {
  ETag?: string(name='ETag', parentIgnore='CopyObjectResult'),
  lastModified?: string(name='LastModified', parentIgnore='CopyObjectResult'),
}

model CopyObjectResponse = {
  headers: map[string]string(name='headers'),
  body: CopyObjectResponseBody(name='body'),
}

async function copyObject(request: CopyObjectRequest): CopyObjectResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'CopyObject', 'PUT', '/{key}', 'xml', false, 'binary', request);
}

model PutBucketLifecycleRequest {
  bucket?: string(name='bucket', position='Host'),
  lifecycleConfiguration?: LifecycleConfiguration(name='LifecycleConfiguration', position='Body'),
}

model PutBucketLifecycleResponse = {
  headers: map[string]string(name='headers'),
}

async function putBucketLifecycle(request: PutBucketLifecycleRequest): PutBucketLifecycleResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'PutBucketLifecycle', 'PUT', '/?lifecycle ', 'xml', true, 'xml', request);
}

model DeleteBucketReplicationRequest {
  bucket?: string(name='bucket', position='Host'),
}

model DeleteBucketReplicationResponseBody = {
  ID?: string(name='ID', parentIgnore='ReplicationRules'),
}

model DeleteBucketReplicationResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteBucketReplicationResponseBody(name='body'),
}

async function deleteBucketReplication(request: DeleteBucketReplicationRequest): DeleteBucketReplicationResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'DeleteBucketReplication', 'POST', '/?replication&comp=delete', 'xml', false, 'xml', request);
}

model GetBucketVersioningRequest {
  bucket?: string(name='bucket', position='Host'),
}

model GetBucketVersioningResponseBody = {
  status?: BucketVersioningStatus(name='Status', parentIgnore='VersioningConfiguration'),
}

model GetBucketVersioningResponse = {
  headers: map[string]string(name='headers'),
  body: GetBucketVersioningResponseBody(name='body'),
}

async function getBucketVersioning(request: GetBucketVersioningRequest): GetBucketVersioningResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'GetBucketVersioning', 'GET', '/?versioning', 'xml', false, 'xml', request);
}

model GetBucketTransferAccelerationRequest {
  bucket?: string(name='bucket', position='Host'),
}

model GetBucketTransferAccelerationResponseBody = {
  enabled?: boolean(name='Enabled', parentIgnore='TransferAccelerationConfiguration'),
}

model GetBucketTransferAccelerationResponse = {
  headers: map[string]string(name='headers'),
  body: GetBucketTransferAccelerationResponseBody(name='body'),
}

async function getBucketTransferAcceleration(request: GetBucketTransferAccelerationRequest): GetBucketTransferAccelerationResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'GetBucketTransferAcceleration', 'GET', '/?transferAcceleration ', 'xml', false, 'xml', request);
}

model DeleteBucketEncryptionRequest {
  bucket?: string(name='bucket', position='Host'),
}

model DeleteBucketEncryptionResponse = {
  headers: map[string]string(name='headers'),
}

async function deleteBucketEncryption(request: DeleteBucketEncryptionRequest): DeleteBucketEncryptionResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'DeleteBucketEncryption', 'DELETE', '/?encryption', 'xml', false, 'xml', request);
}

model PutBucketEncryptionRequest {
  bucket?: string(name='bucket', position='Host'),
  serverSideEncryptionRule?: ServerSideEncryptionRule(name='serverSideEncryptionRule', position='Body'),
}

model PutBucketEncryptionResponse = {
  headers: map[string]string(name='headers'),
}

async function putBucketEncryption(request: PutBucketEncryptionRequest): PutBucketEncryptionResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'PutBucketEncryption', 'PUT', '/?encryption', 'xml', true, 'xml', request);
}

model GetBucketReplicationLocationRequest {
  bucket?: string(name='bucket', position='Host'),
}

model GetBucketReplicationLocationResponseBody = {
  locations?: [ string ](name='Location', parentIgnore='ReplicationLocation'),
  locationTransferTypeConstraint?: {
    locationTransferTypes?: [
      LocationTransferType
    ](name='LocationTransferType'),
  }(name='LocationTransferTypeConstraint', parentIgnore='ReplicationLocation'),
}

model GetBucketReplicationLocationResponse = {
  headers: map[string]string(name='headers'),
  body: GetBucketReplicationLocationResponseBody(name='body'),
}

async function getBucketReplicationLocation(request: GetBucketReplicationLocationRequest): GetBucketReplicationLocationResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'GetBucketReplicationLocation', 'GET', '/?replicationLocation', 'xml', false, 'xml', request);
}

model PutLiveChannelStatusRequest {
  bucket?: string(name='bucket', position='Host'),
  channel?: string(name='channel', position='Path'),
  status?: string(name='status', position='Query'),
}

model PutLiveChannelStatusResponse = {
  headers: map[string]string(name='headers'),
}

async function putLiveChannelStatus(request: PutLiveChannelStatusRequest): PutLiveChannelStatusResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'PutLiveChannelStatus', 'PUT', '/{channel}?live', 'xml', false, 'xml', request);
}

model GetBucketLoggingRequest {
  bucket?: string(name='bucket', position='Host'),
}

model GetBucketLoggingResponseBody = {
  loggingEnabled?: LoggingEnabled(name='LoggingEnabled', parentIgnore='BucketLoggingStatus'),
}

model GetBucketLoggingResponse = {
  headers: map[string]string(name='headers'),
  body: GetBucketLoggingResponseBody(name='body'),
}

async function getBucketLogging(request: GetBucketLoggingRequest): GetBucketLoggingResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'GetBucketLogging', 'GET', '/?logging', 'xml', false, 'xml', request);
}

model PutBucketRequestPaymentRequest {
  bucket?: string(name='bucket', position='Host'),
  requestPaymentConfiguration?: RequestPaymentConfiguration(name='requestPaymentConfiguration', position='Body'),
}

model PutBucketRequestPaymentResponse = {
  headers: map[string]string(name='headers'),
}

async function putBucketRequestPayment(request: PutBucketRequestPaymentRequest): PutBucketRequestPaymentResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'PutBucketRequestPayment', 'PUT', '/?requestPayment', 'xml', true, 'xml', request);
}

model DeleteBucketLoggingRequest {
  bucket?: string(name='bucket', position='Host'),
}

model DeleteBucketLoggingResponse = {
  headers: map[string]string(name='headers'),
}

async function deleteBucketLogging(request: DeleteBucketLoggingRequest): DeleteBucketLoggingResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'DeleteBucketLogging', 'DELETE', '/?logging', 'xml', false, 'xml', request);
}

model GetLiveChannelStatRequest {
  bucket?: string(name='bucket', position='Host'),
  channel?: string(name='channel', position='Path'),
}

model GetLiveChannelStatResponseBody = {
  status?: string(name='Status', parentIgnore='LiveChannelStat'),
  connectedTime?: string(name='ConnectedTime', parentIgnore='LiveChannelStat'),
  remoteAddr?: string(name='RemoteAddr', parentIgnore='LiveChannelStat'),
  video?: LiveChannelVideo(name='Video', parentIgnore='LiveChannelStat'),
  audio?: LiveChannelAudio(name='Audio', parentIgnore='LiveChannelStat'),
}

model GetLiveChannelStatResponse = {
  headers: map[string]string(name='headers'),
  body: GetLiveChannelStatResponseBody(name='body'),
}

async function getLiveChannelStat(request: GetLiveChannelStatRequest): GetLiveChannelStatResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'GetLiveChannelStat', 'GET', '/{channel}?live&comp=stat', 'xml', false, 'xml', request);
}

model PutBucketTransferAccelerationRequest {
  bucket?: string(name='bucket', position='Host'),
  transferAccelerationConfiguration?: TransferAccelerationConfiguration(name='TransferAccelerationConfiguration', position='Body'),
}

model PutBucketTransferAccelerationResponse = {
  headers: map[string]string(name='headers'),
}

async function putBucketTransferAcceleration(request: PutBucketTransferAccelerationRequest): PutBucketTransferAccelerationResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'PutBucketTransferAcceleration', 'PUT', '/?transferAcceleration ', 'xml', true, 'xml', request);
}

model PutBucketCORSRequest {
  bucket?: string(name='bucket', position='Host'),
  cORSConfiguration?: CORSConfiguration(name='CORSConfiguration', position='Body'),
}

model PutBucketCORSResponse = {
  headers: map[string]string(name='headers'),
}

async function putBucketCORS(request: PutBucketCORSRequest): PutBucketCORSResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'PutBucketCORS', 'PUT', '/?cors', 'xml', false, 'xml', request);
}

model PutBucketVersioningRequest {
  bucket?: string(name='bucket', position='Host'),
  versioningConfiguration?: VersioningConfiguration(name='versioningConfiguration', position='Body'),
}

model PutBucketVersioningResponse = {
  headers: map[string]string(name='headers'),
}

async function putBucketVersioning(request: PutBucketVersioningRequest): PutBucketVersioningResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'PutBucketVersioning', 'PUT', '/?versioning', 'xml', true, 'xml', request);
}

model DeleteObjectRequest {
  bucket?: string(name='bucket', position='Host'),
  key?: string(name='key', position='Path'),
  versionId?: string(name='versionId', position='Query'),
}

model DeleteObjectResponse = {
  headers: map[string]string(name='headers'),
}

async function deleteObject(request: DeleteObjectRequest): DeleteObjectResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'DeleteObject', 'DELETE', '/{key}', 'binary', false, 'binary', request);
}

model GetBucketRefererRequest {
  bucket?: string(name='bucket', position='Host'),
}

model GetBucketRefererResponseBody = {
  allowEmptyReferer?: boolean(name='AllowEmptyReferer', parentIgnore='RefererConfiguration'),
  refererList?: {
    referer?: [ string ](name='Referer'),
  }(name='RefererList', parentIgnore='RefererConfiguration'),
}

model GetBucketRefererResponse = {
  headers: map[string]string(name='headers'),
  body: GetBucketRefererResponseBody(name='body'),
}

async function getBucketReferer(request: GetBucketRefererRequest): GetBucketRefererResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'GetBucketReferer', 'GET', '/?referer', 'xml', false, 'xml', request);
}

model GetBucketReplicationProgressRequest {
  bucket?: string(name='bucket', position='Host'),
  ruleId?: string(name='rule-id', position='Query'),
}

model GetBucketReplicationProgressResponseBody = {
  rule?: ReplicationRuleProgress(name='Rule', parentIgnore='ReplicationProgress'),
}

model GetBucketReplicationProgressResponse = {
  headers: map[string]string(name='headers'),
  body: GetBucketReplicationProgressResponseBody(name='body'),
}

async function getBucketReplicationProgress(request: GetBucketReplicationProgressRequest): GetBucketReplicationProgressResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'GetBucketReplicationProgress', 'GET', '/?replicationProgress', 'xml', false, 'xml', request);
}

model ListBucketInventoryRequest {
  bucket?: string(name='bucket', position='Host'),
  continuationToken?: string(name='continuation-token', position='Query'),
}

model ListBucketInventoryResponseBody = {
  inventoryConfigurations?: [
    InventoryConfiguration
  ](name='InventoryConfiguration', parentIgnore='ListInventoryConfigurationsResult'),
  isTruncated?: boolean(name='IsTruncated', parentIgnore='ListInventoryConfigurationsResult'),
  nextContinuationToken?: string(name='NextContinuationToken', parentIgnore='ListInventoryConfigurationsResult'),
}

model ListBucketInventoryResponse = {
  headers: map[string]string(name='headers'),
  body: ListBucketInventoryResponseBody(name='body'),
}

async function listBucketInventory(request: ListBucketInventoryRequest): ListBucketInventoryResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'ListBucketInventory', 'GET', '/?inventory', 'xml', false, 'xml', request);
}

model PutSymlinkRequest {
  bucket?: string(name='bucket', position='Host'),
  key?: string(name='key', position='Path'),
  symlinkTargetKey?: string(name='x-oss-symlink-target', position='Header'),
  acl?: string(name='x-oss-object-acl', position='Header'),
  storageClass?: string(name='x-oss-storage-class', position='Header'),
}

model PutSymlinkResponse = {
  headers: map[string]string(name='headers'),
}

async function putSymlink(request: PutSymlinkRequest): PutSymlinkResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'PutSymlink', 'PUT', '/{key}?symlink', 'xml', false, 'xml', request);
}

model GetObjectMetaRequest {
  bucket?: string(name='bucket', position='Host'),
  key?: string(name='key', position='Path'),
}

model GetObjectMetaResponse = {
  headers: map[string]string(name='headers'),
}

async function getObjectMeta(request: GetObjectMetaRequest): GetObjectMetaResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'GetObjectMeta', 'HEAD', '/{key}?objectMeta', 'xml', false, 'binary', request);
}

model GetLiveChannelInfoRequest {
  bucket?: string(name='bucket', position='Host'),
  channel?: string(name='channel', position='Path'),
}

model GetLiveChannelInfoResponseBody = {
  description?: string(name='Description', parentIgnore='LiveChannelConfiguration'),
  status?: string(name='Status', parentIgnore='LiveChannelConfiguration'),
  target?: LiveChannelTarget(name='Target', parentIgnore='LiveChannelConfiguration'),
}

model GetLiveChannelInfoResponse = {
  headers: map[string]string(name='headers'),
  body: GetLiveChannelInfoResponseBody(name='body'),
}

async function getLiveChannelInfo(request: GetLiveChannelInfoRequest): GetLiveChannelInfoResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'GetLiveChannelInfo', 'GET', '/{channel}?live', 'xml', false, 'xml', request);
}

model GetLiveChannelHistoryRequest {
  bucket?: string(name='bucket', position='Host'),
  channel?: string(name='channel', position='Path'),
}

model GetLiveChannelHistoryResponseBody = {
  liveRecords?: [
    LiveRecord
  ](name='LiveRecord', parentIgnore='LiveChannelHistory'),
}

model GetLiveChannelHistoryResponse = {
  headers: map[string]string(name='headers'),
  body: GetLiveChannelHistoryResponseBody(name='body'),
}

async function getLiveChannelHistory(request: GetLiveChannelHistoryRequest): GetLiveChannelHistoryResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'GetLiveChannelHistory', 'GET', '/{channel}?live&comp=history', 'xml', false, 'xml', request);
}

model GetBucketLifecycleRequest {
  bucket?: string(name='bucket', position='Host'),
}

model GetBucketLifecycleResponseBody = {
  rule?: LifecycleRule(name='Rule', parentIgnore='LifecycleConfiguration'),
}

model GetBucketLifecycleResponse = {
  headers: map[string]string(name='headers'),
  body: GetBucketLifecycleResponseBody(name='body'),
}

async function getBucketLifecycle(request: GetBucketLifecycleRequest): GetBucketLifecycleResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'GetBucketLifecycle', 'GET', '/?lifecycle ', 'xml', false, 'xml', request);
}

model PutBucketRefererRequest {
  bucket?: string(name='bucket', position='Host'),
  refererConfiguration?: RefererConfiguration(name='refererConfiguration', position='Body'),
}

model PutBucketRefererResponse = {
  headers: map[string]string(name='headers'),
}

async function putBucketReferer(request: PutBucketRefererRequest): PutBucketRefererResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'PutBucketReferer', 'PUT', '/?referer', 'xml', true, 'xml', request);
}

model AbortMultipartUploadRequest {
  bucket?: string(name='bucket', position='Host'),
  key?: string(name='key', position='Path'),
  uploadId?: string(name='uploadId', position='Query'),
}

model AbortMultipartUploadResponse = {
  headers: map[string]string(name='headers'),
}

async function abortMultipartUpload(request: AbortMultipartUploadRequest): AbortMultipartUploadResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'AbortMultipartUpload', 'DELETE', '/{key}', 'xml', false, 'xml', request);
}

model PutBucketAclRequest {
  bucket?: string(name='bucket', position='Host'),
  acl?: BucketACL(name='x-oss-acl', position='Header'),
}

model PutBucketAclResponse = {
  headers: map[string]string(name='headers'),
}

async function putBucketAcl(request: PutBucketAclRequest): PutBucketAclResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'PutBucketAcl', 'PUT', '/?acl', 'xml', false, 'xml', request);
}

model PutLiveChannelRequest {
  bucket?: string(name='bucket', position='Host'),
  channel?: string(name='channel', position='Path'),
  liveChannelConfiguration?: LiveChannelConfiguration(name='liveChannelConfiguration', position='Body'),
}

model PutLiveChannelResponseBody = {
  publishUrls?: LiveChannelPublishUrls(name='PublishUrls', parentIgnore='CreateLiveChannelResult'),
  playUrls?: LiveChannelPlayUrls(name='PlayUrls', parentIgnore='CreateLiveChannelResult'),
}

model PutLiveChannelResponse = {
  headers: map[string]string(name='headers'),
  body: PutLiveChannelResponseBody(name='body'),
}

async function putLiveChannel(request: PutLiveChannelRequest): PutLiveChannelResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'PutLiveChannel', 'PUT', '/{channel}?live', 'xml', true, 'xml', request);
}

model PutBucketPolicyRequest {
  bucket?: string(name='bucket', position='Host'),
  policy?: string(name='body', position='Body'),
}

model PutBucketPolicyResponse = {
  headers: map[string]string(name='headers'),
}

async function putBucketPolicy(request: PutBucketPolicyRequest): PutBucketPolicyResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'PutBucketPolicy', 'PUT', '/?policy', 'json', false, 'string', request);
}

model GetBucketRequestPaymentRequest {
  bucket?: string(name='bucket', position='Host'),
}

model GetBucketRequestPaymentResponseBody = {
  payer?: string(name='Payer', parentIgnore='RequestPaymentConfiguration'),
}

model GetBucketRequestPaymentResponse = {
  headers: map[string]string(name='headers'),
  body: GetBucketRequestPaymentResponseBody(name='body'),
}

async function getBucketRequestPayment(request: GetBucketRequestPaymentRequest): GetBucketRequestPaymentResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'GetBucketRequestPayment', 'GET', '/?requestPayment', 'xml', false, 'xml', request);
}

model ListMultipartUploadsRequest {
  bucket?: string(name='bucket', position='Host'),
  delimiter?: string(name='delimiter', position='Query'),
  maxUploads?: string(name='max-uploads', position='Query'),
  keyMarker?: string(name='key-marker', position='Query'),
  prefix?: string(name='prefix', position='Query'),
  uploadIdMarker?: string(name='upload-id-marker', position='Query'),
  encodingType?: string(name='encoding-type', position='Query'),
}

model ListMultipartUploadsResponseBody = {
  bucket?: string(name='Bucket'),
  encodingType?: string(name='EncodingType'),
  keyMarker?: string(name='KeyMarker'),
  uploadIdMarker?: string(name='UploadIdMarker'),
  nextKeyMarker?: string(name='NextKeyMarker'),
  nextUploadMarker?: string(name='NextUploadMarker'),
  maxUploads?: long(name='MaxUploads'),
  isTruncated?: boolean(name='IsTruncated'),
  upload?: [
    Upload
  ](name='Upload'),
}

model ListMultipartUploadsResponse = {
  headers: map[string]string(name='headers'),
  body: ListMultipartUploadsResponseBody(name='body'),
}

async function listMultipartUploads(request: ListMultipartUploadsRequest): ListMultipartUploadsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'ListMultipartUploads', 'GET', '/?uploads', 'xml', false, 'xml', request);
}

model ListBucketsRequest {
  prefix?: string(name='prefix', position='Query'),
  marker?: string(name='marker', position='Query'),
  maxKeys?: long(name='max-keys', position='Query'),
}

model ListBucketsResponseBody = {
  owner?: Owner(name='Owner', parentIgnore='ListAllMyBucketsResult'),
  buckets?: [
    Bucket
  ](name='Bucket', parentIgnore='ListAllMyBucketsResult,Buckets'),
}

model ListBucketsResponse = {
  headers: map[string]string(name='headers'),
  body: ListBucketsResponseBody(name='body'),
}

async function listBuckets(request: ListBucketsRequest): ListBucketsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'ListBuckets', 'GET', '/ ', 'xml', false, 'xml', request);
}

model GetObjectAclRequest {
  bucket?: string(name='bucket', position='Host'),
  key?: string(name='key', position='Path'),
  versionId?: string(name='versionId', description='The version of a object', position='Query'),
}

model GetObjectAclResponseBody = {
  owner?: Owner(name='Owner', parentIgnore='AccessControlPolicy'),
  ACL?: ObjectACL(name='Grant', parentIgnore='AccessControlPolicy,AccessControlList'),
}

model GetObjectAclResponse = {
  headers: map[string]string(name='headers'),
  body: GetObjectAclResponseBody(name='body'),
}

async function getObjectAcl(request: GetObjectAclRequest): GetObjectAclResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'GetObjectAcl', 'GET', '/{key}?acl', 'xml', false, 'xml', request);
}

model GetVodPlaylistRequest {
  bucket?: string(name='bucket', position='Host'),
  channel?: string(name='channel', position='Path'),
  endTime?: string(name='endTime', position='Query'),
  startTime?: string(name='startTime', position='Query'),
}

model GetVodPlaylistResponse = {
  headers: map[string]string(name='headers'),
  body: readable(name='body'),
}

async function getVodPlaylist(request: GetVodPlaylistRequest): GetVodPlaylistResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'GetVodPlaylist', 'GET', '/{channel}?vod', 'binary', false, 'xml', request);
}

model PutBucketTagsRequest {
  bucket?: string(name='bucket', position='Host'),
  tagging?: Tagging(name='Tagging', position='Body'),
}

model PutBucketTagsResponse = {
  headers: map[string]string(name='headers'),
}

async function putBucketTags(request: PutBucketTagsRequest): PutBucketTagsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'PutBucketTags', 'PUT', '/?tagging', 'xml', true, 'xml', request);
}

model AbortBucketWormRequest {
  bucket?: string(name='bucket', position='Host'),
}

model AbortBucketWormResponse = {
  headers: map[string]string(name='headers'),
}

async function abortBucketWorm(request: AbortBucketWormRequest): AbortBucketWormResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'AbortBucketWorm', 'DELETE', '/?worm', 'xml', false, 'xml', request);
}

model GetBucketWebsiteRequest {
  bucket?: string(name='bucket', position='Host'),
}

model GetBucketWebsiteResponseBody = {
  indexDocument?: {
    suffix?: string(name='Suffix'),
  }(name='IndexDocument', parentIgnore='WebsiteConfiguration'),
  errorDocument?: {
    key?: string(name='Key'),
    httpStatus?: string(name='HttpStatus'),
  }(name='ErrorDocument', parentIgnore='WebsiteConfiguration'),
}

model GetBucketWebsiteResponse = {
  headers: map[string]string(name='headers'),
  body: GetBucketWebsiteResponseBody(name='body'),
}

async function getBucketWebsite(request: GetBucketWebsiteRequest): GetBucketWebsiteResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'GetBucketWebsite', 'POST', '/?website', 'xml', false, 'xml', request);
}

model PostObjectRequest {
  bucket?: string(name='bucket', position='Host'),
}

model PostObjectResponse = {
  headers: map[string]string(name='headers'),
}

async function postObject(request: PostObjectRequest): PostObjectResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'PostObject', 'POST', '/', 'xml', false, 'none', request);
}

model SelectObjectRequest {
  bucket?: string(name='bucket', position='Host'),
  key?: string(name='key', position='Path'),
  selectRequest?: SelectRequest(name='selectRequest', position='Body'),
}

model SelectObjectResponse = {
  headers: map[string]string(name='headers'),
}

async function selectObject(request: SelectObjectRequest): SelectObjectResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'SelectObject', 'POST', '/{key}', 'binary', true, 'xml', request);
}

model ListObjectsRequest {
  bucket?: string(name='bucket', position='Host'),
  delimiter?: string(name='delimiter', position='Query'),
  marker?: string(name='marker', position='Query'),
  maxKeys?: long(name='max-keys', position='Query'),
  prefix?: string(name='prefix', position='Query'),
  encodingType?: EncodeType(name='encoding-type', position='Query'),
}

model ListObjectsResponseBody = {
  name?: string(name='Name', description='The bucket name', parentIgnore='ListBucketResult'),
  prefix?: string(name='Prefix', description='The prefix that the names of returned objects contain', parentIgnore='ListBucketResult'),
  marker?: string(name='Marker', description='The name of the object from which the list operation begins', parentIgnore='ListBucketResult'),
  maxKeys?: int32(name='MaxKeys', description='The maximum number of returned objects in the response', parentIgnore='ListBucketResult'),
  delimiter?: string(name='Delimiter', description='The character used to group objects by name', parentIgnore='ListBucketResult'),
  isTruncated?: boolean(name='IsTruncated', description='Indicates whether the returned results are truncated', parentIgnore='ListBucketResult'),
  encodingType?: string(name='EncodingType', parentIgnore='ListBucketResult'),
  contents?: [
    ObjectSummary
  ](name='Contents', description='The container that stores the returned object metadata', parentIgnore='ListBucketResult'),
  commonPrefixes?: [
    CommonPrefix
  ](name='CommonPrefixes', description='Objects whose names contain the same string that ranges from the prefix to the next occurrence of the delimiter are grouped as a single result element', parentIgnore='ListBucketResult'),
}

model ListObjectsResponse = {
  headers: map[string]string(name='headers'),
  body: ListObjectsResponseBody(name='body'),
}

async function listObjects(request: ListObjectsRequest): ListObjectsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'ListObjects', 'GET', '/', 'xml', false, 'xml', request);
}

model ListPartsRequest {
  bucket?: string(name='bucket', position='Host'),
  key?: string(name='key', position='Path'),
  uploadId?: string(name='UploadId', position='Query'),
  maxParts?: long(name='max-parts', position='Query'),
  partNumberMarker?: long(name='part-number-marker', position='Query'),
  encodingType?: string(name='encoding-type', position='Query'),
}

model ListPartsResponseBody = {
  bucket?: string(name='Bucket'),
  key?: string(name='Key'),
  uploadId?: string(name='UploadId'),
  nextPartNumberMarker?: long(name='NextPartNumberMarker'),
  maxParts?: long(name='MaxParts'),
  isTruncated?: boolean(name='IsTruncated'),
  part?: [
    Part
  ](name='Part'),
}

model ListPartsResponse = {
  headers: map[string]string(name='headers'),
  body: ListPartsResponseBody(name='body'),
}

async function listParts(request: ListPartsRequest): ListPartsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'ListParts', 'GET', '/{key}', 'xml', false, 'xml', request);
}

model PutObjectAclRequest {
  bucket?: string(name='bucket', position='Host'),
  key?: string(name='key', position='Path'),
  acl?: ObjectACL(name='x-oss-object-acl', position='Header'),
  versionId?: string(name='versionId', position='Query'),
}

model PutObjectAclResponse = {
  headers: map[string]string(name='headers'),
}

async function putObjectAcl(request: PutObjectAclRequest): PutObjectAclResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'PutObjectAcl', 'PUT', '/{key}?acl', 'xml', false, 'none', request);
}

model UploadPartRequest {
  bucket?: string(name='bucket', position='Host'),
  key?: string(name='key', position='Path'),
  partNumber?: string(name='partNumber', position='Query'),
  uploadId?: string(name='uploadId', position='Query'),
}

model UploadPartResponse = {
  headers: map[string]string(name='headers'),
}

async function uploadPart(request: UploadPartRequest): UploadPartResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'UploadPart', 'PUT', '/{key}', 'xml', false, 'binary', request);
}

model PutBucketRequest {
  bucket?: string(name='bucket', position='Host'),
  acl?: BucketACL(name='x-oss-acl', position='Header'),
  createBucketConfiguration?: CreateBucketConfiguration(name='createBucketConfiguration', position='Body'),
}

model PutBucketResponse = {
  headers: map[string]string(name='headers'),
}

async function putBucket(request: PutBucketRequest): PutBucketResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'PutBucket', 'PUT', '/', 'xml', true, 'xml', request);
}

model DeleteBucketLifecycleRequest {
  bucket?: string(name='bucket', position='Host'),
}

model DeleteBucketLifecycleResponse = {
  headers: map[string]string(name='headers'),
}

async function deleteBucketLifecycle(request: DeleteBucketLifecycleRequest): DeleteBucketLifecycleResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'DeleteBucketLifecycle', 'DELETE', '/?lifecycle', 'xml', false, 'xml', request);
}

model GetObjectTaggingRequest {
  bucket?: string(name='bucket', position='Host'),
  key?: string(name='key', position='Path'),
}

model GetObjectTaggingResponseBody = {
  tagSet?: {
    tag?: [
      Tag
    ](name='Tag'),
  }(name='TagSet', parentIgnore='Tagging'),
}

model GetObjectTaggingResponse = {
  headers: map[string]string(name='headers'),
  body: GetObjectTaggingResponseBody(name='body'),
}

async function getObjectTagging(request: GetObjectTaggingRequest): GetObjectTaggingResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'GetObjectTagging', 'GET', '/{key}?tagging', 'xml', false, 'xml', request);
}

model CompleteMultipartUploadRequest {
  bucket?: string(name='bucket', position='Host'),
  key?: string(name='key', position='Path'),
  uploadId?: string(name='uploadId', position='Query'),
  completeMultipartUpload?: CompleteMultipartUpload(name='completeMultipartUpload', position='Body'),
  encodingType?: string(name='encoding-type', position='Query'),
  xOssForbidOverwrite?: string(name='x-oss-forbid-overwrite', position='Header'),
  xOssCompleteAll?: string(name='x-oss-complete-all', position='Header'),
}

model CompleteMultipartUploadResponseBody = {
  encodingType?: string(name='EncodingType', parentIgnore='CompleteMultipartUploadResult'),
  location?: string(name='Location', parentIgnore='CompleteMultipartUploadResult'),
  bucket?: string(name='Bucket', parentIgnore='CompleteMultipartUploadResult'),
  key?: string(name='Key', parentIgnore='CompleteMultipartUploadResult'),
  ETag?: string(name='ETag', parentIgnore='CompleteMultipartUploadResult'),
}

model CompleteMultipartUploadResponse = {
  headers: map[string]string(name='headers'),
  body: CompleteMultipartUploadResponseBody(name='body'),
}

async function completeMultipartUpload(request: CompleteMultipartUploadRequest): CompleteMultipartUploadResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'CompleteMultipartUpload', 'POST', '/{key}', 'xml', true, 'xml', request);
}

model DeleteBucketCORSRequest {
  bucket?: string(name='bucket', position='Host'),
}

model DeleteBucketCORSResponse = {
  headers: map[string]string(name='headers'),
}

async function deleteBucketCORS(request: DeleteBucketCORSRequest): DeleteBucketCORSResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'DeleteBucketCORS', 'DELETE', '/?cors', 'xml', false, 'xml', request);
}

model DeleteLiveChannelRequest {
  bucket?: string(name='bucket', position='Host'),
  channel?: string(name='channel', position='Path'),
}

model DeleteLiveChannelResponse = {
  headers: map[string]string(name='headers'),
}

async function deleteLiveChannel(request: DeleteLiveChannelRequest): DeleteLiveChannelResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'DeleteLiveChannel', 'DELETE', '/{channel}?live', 'xml', false, 'xml', request);
}

model GetBucketEncryptionRequest {
  bucket?: string(name='bucket', position='Host'),
}

model GetBucketEncryptionResponseBody = {
  applyServerSideEncryptionByDefault?: ApplyServerSideEncryptionByDefault(name='ApplyServerSideEncryptionByDefault', parentIgnore='ServerSideEncryptionRule'),
}

model GetBucketEncryptionResponse = {
  headers: map[string]string(name='headers'),
  body: GetBucketEncryptionResponseBody(name='body'),
}

async function getBucketEncryption(request: GetBucketEncryptionRequest): GetBucketEncryptionResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'GetBucketEncryption', 'GET', '/?encryption', 'xml', false, 'xml', request);
}

model RestoreObjectRequest {
  bucket?: string(name='bucket', position='Host'),
  key?: string(name='key', position='Path'),
  restoreRequest?: RestoreRequest(name='restoreRequest', position='Body'),
}

model RestoreObjectResponse = {
  headers: map[string]string(name='headers'),
}

async function restoreObject(request: RestoreObjectRequest): RestoreObjectResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'RestoreObject', 'POST', '/{key}?restore', 'xml', true, 'xml', request);
}

model DeleteBucketPolicyRequest {
  bucket?: string(name='bucket', position='Host'),
}

model DeleteBucketPolicyResponse = {
  headers: map[string]string(name='headers'),
}

async function deleteBucketPolicy(request: DeleteBucketPolicyRequest): DeleteBucketPolicyResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'DeleteBucketPolicy', 'DELETE', '/?policy', 'xml', false, 'xml', request);
}

model AppendObjectRequest {
  bucket?: string(name='bucket', position='Host'),
  key?: string(name='key', position='Path'),
  position?: long(name='position', position='Query'),
  acl?: string(name='x-oss-object-acl', position='Header'),
  storageClass?: string(name='x-oss-storage-class', position='Header'),
  body?: readable(name='body', position='Body'),
}

model AppendObjectResponse = {
  headers: map[string]string(name='headers'),
}

async function appendObject(request: AppendObjectRequest): AppendObjectResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'AppendObject', 'POST', '/{key}?append', 'xml', true, 'binary', request);
}

async function appendObjectWithRequestBody(request: AppendObjectRequest, requestBody: AsyncRequestBody): AppendObjectResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'AppendObject', 'POST', '/{key}?append', 'xml', true, 'binary', request);
}

model ListLiveChannelRequest {
  bucket?: string(name='bucket', position='Host'),
  marker?: string(name='marker', position='Query'),
  maxKeys?: long(name='max-keys', position='Query'),
  prefix?: string(name='prefix', position='Query'),
}

model ListLiveChannelResponseBody = {
  prefix?: string(name='Prefix', parentIgnore='ListLiveChannelResult'),
  marker?: string(name='Marker', parentIgnore='ListLiveChannelResult'),
  maxKeys?: long(name='MaxKeys', parentIgnore='ListLiveChannelResult'),
  isTruncated?: boolean(name='IsTruncated', parentIgnore='ListLiveChannelResult'),
  nextMarker?: string(name='NextMarker', parentIgnore='ListLiveChannelResult'),
  liveChannels?: [
    LiveChannel
  ](name='LiveChannel', parentIgnore='ListLiveChannelResult'),
}

model ListLiveChannelResponse = {
  headers: map[string]string(name='headers'),
  body: ListLiveChannelResponseBody(name='body'),
}

async function listLiveChannel(request: ListLiveChannelRequest): ListLiveChannelResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'ListLiveChannel', 'GET', '/?live', 'xml', false, 'xml', request);
}

model PutBucketLoggingRequest {
  bucket?: string(name='bucket', position='Host'),
  bucketLoggingStatus?: BucketLoggingStatus(name='bucketLoggingStatus', position='Body'),
}

model PutBucketLoggingResponse = {
  headers: map[string]string(name='headers'),
}

async function putBucketLogging(request: PutBucketLoggingRequest): PutBucketLoggingResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'PutBucketLogging', 'PUT', '/?logging', 'xml', true, 'xml', request);
}

model DeleteBucketTagsRequest {
  bucket?: string(name='bucket', position='Host'),
}

model DeleteBucketTagsResponse = {
  headers: map[string]string(name='headers'),
}

async function deleteBucketTags(request: DeleteBucketTagsRequest): DeleteBucketTagsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'DeleteBucketTags', 'DELETE', '/?tagging', 'xml', false, 'xml', request);
}

model GetBucketInfoRequest {
  bucket?: string(name='bucket', position='Host'),
}

model GetBucketInfoResponseBody = {
  bucketInfo?: {
    creationDate?: string(name='CreationDate'),
    extranetEndpoint?: string(name='ExtranetEndpoint'),
    intranetEndpoint?: string(name='IntranetEndpoint'),
    location?: string(name='Location'),
    storageClass?: StorageClass(name='StorageClass'),
    transferAcceleration?: string(name='TransferAcceleration'),
    crossRegionReplication?: string(name='CrossRegionReplication'),
    name?: string(name='Name'),
    owner?: Owner(name='Owner'),
    accessControlList?: {
      grant?: string(name='Grant'),
    }(name='AccessControlList'),
    comment?: string(name='Comment'),
  }(name='Bucket'),
}

model GetBucketInfoResponse = {
  headers: map[string]string(name='headers'),
  body: GetBucketInfoResponseBody(name='body'),
}

async function getBucketInfo(request: GetBucketInfoRequest): GetBucketInfoResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'GetBucketInfo', 'GET', '/?bucketInfo', 'xml', false, 'xml', request);
}

model GetServiceRequest {
  prefix?: string(name='prefix', position='Query'),
  marker?: string(name='marker', position='Query'),
  maxKeys?: long(name='max-keys', position='Query'),
}

model GetServiceResponseBody = {
  owner?: Owner(name='Owner', parentIgnore='ListAllMyBucketsResult'),
  buckets?: [
    Bucket
  ](name='Bucket', parentIgnore='ListAllMyBucketsResult,Buckets'),
}

model GetServiceResponse = {
  headers: map[string]string(name='headers'),
  body: GetServiceResponseBody(name='body'),
}

async function getService(request: GetServiceRequest): GetServiceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'GetService', 'GET', '/ ', 'xml', false, 'xml', request);
}

model ListObjectsV2Request {
  bucket?: string(name='bucket', position='Host'),
  delimiter?: string(name='delimiter', description='The character used to group objects by name', position='Query'),
  maxKeys?: long(name='max-keys', description='The maximum number of objects to return', position='Query'),
  prefix?: string(name='prefix', description='The prefix that the returned object names must contain', position='Query'),
  encodingType?: EncodeType(name='encoding-type', description='The encoding type of the object name in the response', position='Query'),
  fetchOwner?: boolean(name='fetch-owner', position='Query'),
  startAfter?: string(name='start-after', position='Query'),
  continuationToken?: string(name='continuation-token', position='Query'),
}

model ListObjectsV2ResponseBody = {
  name?: string(name='Name', description='The bucket name', parentIgnore='ListBucketResult'),
  prefix?: string(name='Prefix', description='The prefix that the names of returned objects must contain', parentIgnore='ListBucketResult'),
  startAfter?: string(name='StartAfter', parentIgnore='ListBucketResult'),
  maxKeys?: int32(name='MaxKeys', description='The maximum number of returned objects in the response', parentIgnore='ListBucketResult'),
  isTruncated?: boolean(name='IsTruncated', description='Indicates whether the returned results are truncated', parentIgnore='ListBucketResult'),
  keyCount?: int32(name='KeyCount', parentIgnore='ListBucketResult'),
  encodingType?: string(name='EncodingType', parentIgnore='ListBucketResult'),
  continuationToken?: string(name='ContinuationToken', parentIgnore='ListBucketResult'),
  nextContinuationToken?: string(name='NextContinuationToken', parentIgnore='ListBucketResult'),
  versions?: [
    ObjectSummary
  ](name='Contents', description='The container that stores the versions of objects except for delete markers', parentIgnore='ListBucketResult'),
  commonPrefixes?: [
    CommonPrefix
  ](name='CommonPrefixes', description='Objects whose names contain the same string that ranges from the prefix to the next occurrence of the delimiter are grouped as a single result element', parentIgnore='ListBucketResult'),
}

model ListObjectsV2Response = {
  headers: map[string]string(name='headers'),
  body: ListObjectsV2ResponseBody(name='body'),
}

async function listObjectsV2(request: ListObjectsV2Request): ListObjectsV2Response {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'ListObjectsV2', 'GET', '/?list-type=2', 'xml', false, 'xml', request);
}

