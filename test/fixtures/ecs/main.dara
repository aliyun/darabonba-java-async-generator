/**
 *
 */
import TeaAsyncHandler;
import TeaRequest;
import AsyncRequestBody;
import ClientConfiguration;
import ClientExecutionParams;
type @product = string
type @version = string
type @endpointRule = string
type @endpointMap = map[string]string
type @REQUEST = TeaRequest
type @handler = TeaAsyncHandler

init(configuration: ClientConfiguration){
  @handler = new TeaAsyncHandler(configuration);
  @product = 'Ecs';
  @version = '2014-05-26';
  @endpointRule = 'regional';
  @endpointMap = {
    cn-qingdao = 'ecs-cn-hangzhou.aliyuncs.com',
    cn-beijing = 'ecs-cn-hangzhou.aliyuncs.com',
    cn-hangzhou = 'ecs-cn-hangzhou.aliyuncs.com',
    cn-shanghai = 'ecs-cn-hangzhou.aliyuncs.com',
    cn-shenzhen = 'ecs-cn-hangzhou.aliyuncs.com',
    cn-hongkong = 'ecs-cn-hangzhou.aliyuncs.com',
    ap-southeast-1 = 'ecs-cn-hangzhou.aliyuncs.com',
    us-west-1 = 'ecs-cn-hangzhou.aliyuncs.com',
    us-east-1 = 'ecs-cn-hangzhou.aliyuncs.com',
    cn-shanghai-finance-1 = 'ecs-cn-hangzhou.aliyuncs.com',
    cn-shenzhen-finance-1 = 'ecs-cn-hangzhou.aliyuncs.com',
    cn-north-2-gov-1 = 'ecs.aliyuncs.com',
    ap-northeast-2-pop = 'ecs.ap-northeast-1.aliyuncs.com',
    cn-beijing-finance-1 = 'ecs.aliyuncs.com',
    cn-beijing-finance-pop = 'ecs.aliyuncs.com',
    cn-beijing-gov-1 = 'ecs.aliyuncs.com',
    cn-beijing-nu16-b01 = 'ecs-cn-hangzhou.aliyuncs.com',
    cn-edge-1 = 'ecs.cn-qingdao-nebula.aliyuncs.com',
    cn-fujian = 'ecs-cn-hangzhou.aliyuncs.com',
    cn-haidian-cm12-c01 = 'ecs-cn-hangzhou.aliyuncs.com',
    cn-hangzhou-bj-b01 = 'ecs-cn-hangzhou.aliyuncs.com',
    cn-hangzhou-finance = 'ecs.aliyuncs.com',
    cn-hangzhou-internal-prod-1 = 'ecs-cn-hangzhou.aliyuncs.com',
    cn-hangzhou-internal-test-1 = 'ecs-cn-hangzhou.aliyuncs.com',
    cn-hangzhou-internal-test-2 = 'ecs-cn-hangzhou.aliyuncs.com',
    cn-hangzhou-internal-test-3 = 'ecs-cn-hangzhou.aliyuncs.com',
    cn-hangzhou-test-306 = 'ecs-cn-hangzhou.aliyuncs.com',
    cn-hongkong-finance-pop = 'ecs.aliyuncs.com',
    cn-shanghai-et15-b01 = 'ecs-cn-hangzhou.aliyuncs.com',
    cn-shanghai-et2-b01 = 'ecs-cn-hangzhou.aliyuncs.com',
    cn-shanghai-inner = 'ecs.aliyuncs.com',
    cn-shanghai-internal-test-1 = 'ecs-cn-hangzhou.aliyuncs.com',
    cn-shenzhen-inner = 'ecs.aliyuncs.com',
    cn-shenzhen-st4-d01 = 'ecs-cn-hangzhou.aliyuncs.com',
    cn-shenzhen-su18-b01 = 'ecs-cn-hangzhou.aliyuncs.com',
    cn-wuhan = 'ecs.aliyuncs.com',
    cn-yushanfang = 'ecs.aliyuncs.com',
    cn-zhangbei-na61-b01 = 'ecs-cn-hangzhou.aliyuncs.com',
    cn-zhangjiakou-na62-a01 = 'ecs.cn-zhangjiakou.aliyuncs.com',
    cn-zhengzhou-nebula-1 = 'ecs.cn-qingdao-nebula.aliyuncs.com',
    eu-west-1-oxs = 'ecs.cn-shenzhen-cloudstone.aliyuncs.com',
    rus-west-1-pop = 'ecs.ap-northeast-1.aliyuncs.com',
  };
}
model ModifySnapshotAttributeRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  snapshotId?: string(name='SnapshotId', description='The ID of the snapshot.', position='Query'),
  description?: string(name='Description', description='The description of the snapshot. The description must be 2 to 256 characters in length and cannot start with http:// or https.', position='Query'),
  disableInstantAccess?: boolean(name='DisableInstantAccess', description='Disable the snapshot extreme availability feature. Valid values:

-true: disable snapshot extreme availability.
-false: the snapshot is not disabled.

Default value: false', position='Query'),
  snapshotName?: string(name='SnapshotName', description='The name of the snapshot. The description must be 2 to 128 characters in length. It must start with a letter and cannot start with http:// or https. It can contain numbers, colons (:), underscores (_), and hyphens (-).

To prevent conflicts with the name of an automatic snapshot, it cannot start with auto.', position='Query'),
}

model ModifySnapshotAttributeResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.'),
}

model ModifySnapshotAttributeResponse = {
  headers: map[string]string(name='headers'),
  body: ModifySnapshotAttributeResponseBody(name='body'),
}

async function modifySnapshotAttribute(request: ModifySnapshotAttributeRequest): ModifySnapshotAttributeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifySnapshotAttribute', 'POST', 'undefined', 'json', false, 'none', request);
}

model UntagResourcesRequest {
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='The account name of the resource master account.', position='Query'),
  regionId?: string(name='RegionId', description='The ID of the region to which the resource belongs. You can call [DescribeRegions](~~ 25609 ~~) to view the latest region list.', position='Query'),
  tagKey?: [ string ](name='TagKey', description='The tag key of the resource. Valid values of N: 1 to 20.', position='Query'),
  ownerId?: long(name='OwnerId', description='The ID of the RAM user.', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', description='The ID of the resource master account, that is, the UID.', position='Query'),
  resourceType?: string(name='ResourceType', description='The definition of the resource type. Valid values:

-instance:ECS instance
-disk: disk
-snapshot: snapshot
-image: image
-securitygroup: Security Group
-volume: storage volume
-eni: eni
-ddh: Dedicated host
-ddhcluster: Dedicated host cluster
-keypair:SSH key pair
-launchtemplate: launch Template
-reservedinstance: Reserved Instance
-snapshotpolicy: automatic snapshot policy
-elasticityassurance: elastic assurance
-capacityreservation: capacity reservation', position='Query'),
  resourceId?: [ string ](name='ResourceId', description='The ID of the resource. Valid values of N: 1 to 50.', position='Query'),
  all?: boolean(name='All', description='Specifies whether to unbind all tags from a resource. This parameter is valid only when TagKey.N is not set in the request. Valid values:
-true
-false

Default value: false', position='Query'),
}

model UntagResourcesResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.'),
}

model UntagResourcesResponse = {
  headers: map[string]string(name='headers'),
  body: UntagResourcesResponseBody(name='body'),
}

async function untagResources(request: UntagResourcesRequest): UntagResourcesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UntagResources', 'POST', 'undefined', 'json', false, 'none', request);
}

model DescribeStorageSetsRequest {
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  zoneId?: string(name='ZoneId', description='The zone to which the bucket belongs. You can call [DescribeZones](~~ 25610 ~~) to query the latest zone list.', position='Query'),
  pageNumber?: int32(name='PageNumber', description='The page number of the bucket list. Start value: 1

Default value: 1.', position='Query'),
  regionId?: string(name='RegionId', description='The region to which the bucket belongs. You can call [DescribeRegions](~~ 25609 ~~) to view the latest region list.', position='Query'),
  storageSetName?: string(name='StorageSetName', description='The name of the storage set. The description must be 2 to 128 characters in length. It must start with a letter and cannot start with http:// or https. It can contain numbers, colons (:), underscores (_), and hyphens (-).', position='Query'),
  clientToken?: string(name='ClientToken', description='Ensure the idempotence of the request. Generate a parameter value from your client. Make sure that the value is unique among different requests. **ClientToken** supports only ASCII characters and cannot exceed 64 characters. For more information, see [how to ensure idempotence](~~ 25693 ~~).', position='Query'),
  pageSize?: int32(name='PageSize', description='The number of entries to return on each page. Maximum value: 100.

Default value: 10', position='Query'),
  storageSetIds?: string(name='StorageSetIds', description='The list of Storage Set IDs. The value can be a JSON Array consisting of multiple storage set IDs. A maximum of 100 IDs can be entered. Separate IDs with commas (,).', position='Query'),
}

model DescribeStorageSetsResponseBody = {
  pageSize?: int32(name='PageSize', description='The number of entries returned per page.'),
  requestId?: string(name='RequestId', description='The ID of the request.'),
  pageNumber?: int32(name='PageNumber', description='The page number of the bucket list.'),
  totalCount?: int32(name='TotalCount', description='The total number of buckets.'),
  storageSets?: {
    storageSet?: [ 
    {
      creationTime?: string(name='CreationTime', description='The time when the storage set was created.'),
      description?: string(name='Description', description='The description of the storage set.'),
      zoneId?: string(name='ZoneId', description='The ID of the zone to which the bucket belongs.'),
      storageSetId?: string(name='StorageSetId', description='The ID of the storage set.'),
      storageSetPartitionNumber?: int32(name='StorageSetPartitionNumber', description='The maximum number of partitions supported by a storage set.'),
      storageSetName?: string(name='StorageSetName', description='The name of the storage set.'),
      regionId?: string(name='RegionId', description='The ID of the region to which the bucket belongs.'),
    }
  ](name='StorageSet')
  }(name='StorageSets', description='By StorageSet array of format, returns Storage Set details.'),
}

model DescribeStorageSetsResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeStorageSetsResponseBody(name='body'),
}

async function describeStorageSets(request: DescribeStorageSetsRequest): DescribeStorageSetsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeStorageSets', 'POST', 'undefined', 'json', false, 'none', request);
}

model ModifyBandwidthPackageSpecRequest {
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  bandwidthPackageId?: string(name='BandwidthPackageId', position='Query'),
  bandwidth?: string(name='Bandwidth', position='Query'),
}

model ModifyBandwidthPackageSpecResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyBandwidthPackageSpecResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyBandwidthPackageSpecResponseBody(name='body'),
}

async function modifyBandwidthPackageSpec(request: ModifyBandwidthPackageSpecRequest): ModifyBandwidthPackageSpecResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyBandwidthPackageSpec', 'POST', 'undefined', 'json', false, 'none', request);
}

model ModifyInstanceVncPasswdRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', description='The ID of the resource master account, that is, the UID.', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='The account name of the resource master account.', position='Query'),
  ownerId?: long(name='OwnerId', description='The ID of the RAM user.', position='Query'),
  instanceId?: string(name='InstanceId', description='The ECS instance.', position='Query'),
  regionId?: string(name='RegionId', description='The region of the ECS instance. You can call [DescribeRegions](~~ 25609 ~~) to view the latest region list.', position='Query'),
  vncPassword?: string(name='VncPassword', description='The password of the new ECS instance management terminal.', position='Query'),
}

model ModifyInstanceVncPasswdResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.'),
}

model ModifyInstanceVncPasswdResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyInstanceVncPasswdResponseBody(name='body'),
}

/**
 * ## API description

-The password must be six characters in length and can only contain uppercase letters, lowercase letters, and Arabic numerals.

-After the password is changed:

-I/O optimized instances take effect immediately without restarting them.

-For non-I/O optimized instances, you must [restart the instance](~~ 25440 ~~) in the console or call the API [RebootInstance](~~ 25502 ~~) to take effect.
 */
async function modifyInstanceVncPasswd(request: ModifyInstanceVncPasswdRequest): ModifyInstanceVncPasswdResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyInstanceVncPasswd', 'POST', 'undefined', 'json', false, 'none', request);
}

model AttachDiskRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  device?: string(name='Device', description='The name of the cloud disk device.

> This parameter will be deprecated soon. We recommend that you use other parameters to improve compatibility.', position='Query'),
  deleteWithInstance?: boolean(name='DeleteWithInstance', description='Whether the cloud disk is released along with the instance when the instance is released.

-true: release.
-false: not released. Cloud disks are converted to pay-as-you-go data disks and retained.

Default value: false

When you set this parameter, note that:

-After "DeleteWithInstance" is set to "false", once the ECS instance is under security control, "OperationLocks" is marked with ""LockReason" : "security"", when you release an ECS instance, this attribute of the disk is ignored and released at the same time.

-This parameter is not supported for disks with multiple mount features enabled.', position='Query'),
  password?: string(name='Password', description='When you mount a system disk, set the username and password of the instance. This parameter takes effect only for the administrator and root user names. Other user names do not take effect. The description must be 8 to 30 characters in length and must contain letters, digits, and special characters. Special symbols can be:

"""
()"~! @%& *-_+ =} [],.?/
"""
The Windows instance cannot start with a slash (/).

> If the "Password" parameter is specified, we recommend that you send requests over HTTPS to avoid password leakage.', position='Query'),
  bootable?: boolean(name='Bootable', description='Specifies whether to mount a system disk.

Default value: false

> If you set the value to "Bootable = true", the target ECS instance must be in the no system disk state.', position='Query'),
  diskId?: string(name='DiskId', description='The ID of the disk to be mounted. The disk ("DiskId") and the instance ("InstanceId") must be in the same zone.

> supports mounting data disks and system disks. For more information, see the preceding section.', position='Query'),
  keyPairName?: string(name='KeyPairName', description='The name of the SSH key pair bound to the Linux ECS instance when the system disk is mounted.

-Windows Server: SSH key pairs are not supported. Even if this parameter is specified, only the "Password" configuration is executed.

-Linux: password logon is disabled.', position='Query'),
  instanceId?: string(name='InstanceId', description='The ID of the target ECS instance.', position='Query'),
}

model AttachDiskResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.'),
}

model AttachDiskResponse = {
  headers: map[string]string(name='headers'),
  body: AttachDiskResponseBody(name='body'),
}

/**
 * ## API description

When you call this operation, note that:

-The status of the disk must be **to be mounted**("Available").

-When you mount a data disk:

-The target ECS instance must be in the **running**("Running") or **stopped**("Stopped") status.
-If you purchase a cloud disk separately, the billing method must be pay-as-you-go.
-When a system disk is mounted from an ECS instance as a data disk, the billing method is not limited.

-When the system disk is mounted:

-The target ECS instance must be the source instance when the system disk is uninstalled.
-The target ECS instance must be in the **stopped**("Stopped") status.
-You must set the instance logon credential.

-When querying ECS instance information, if the returned data contains "{"OperationLocks": {"LockReason" : "security"}}", all operations are prohibited.

<props="china">
-Disks with multiple mount features can only be mounted to instances that support the NVMe protocol. For more information, see [support NVMe for ESSDS](~~ 256487 ~~) and [use multiple Mount functions](~~ 262105 ~~).

</props>

 */
async function attachDisk(request: AttachDiskRequest): AttachDiskResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'AttachDisk', 'POST', 'undefined', 'json', false, 'none', request);
}

model StartElasticityAssuranceRequest {
  privatePoolOptions?: {
    id?: string(name='Id', position=''),
  }(name='PrivatePoolOptions'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
}

model StartElasticityAssuranceResponseBody = {
  requestId?: string(name='RequestId'),
}

model StartElasticityAssuranceResponse = {
  headers: map[string]string(name='headers'),
  body: StartElasticityAssuranceResponseBody(name='body'),
}

async function startElasticityAssurance(request: StartElasticityAssuranceRequest): StartElasticityAssuranceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'StartElasticityAssurance', 'POST', 'undefined', 'json', false, 'none', request);
}

model CreateHaVipRequest {
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  clientToken?: string(name='ClientToken', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  vSwitchId?: string(name='VSwitchId', position='Query'),
  ipAddress?: string(name='IpAddress', position='Query'),
  description?: string(name='Description', position='Query'),
}

model CreateHaVipResponseBody = {
  haVipId?: string(name='HaVipId'),
  requestId?: string(name='RequestId'),
}

model CreateHaVipResponse = {
  headers: map[string]string(name='headers'),
  body: CreateHaVipResponseBody(name='body'),
}

async function createHaVip(request: CreateHaVipRequest): CreateHaVipResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateHaVip', 'POST', 'undefined', 'json', false, 'none', request);
}

model ReInitDiskRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  diskId?: string(name='DiskId', description='The ID of the cloud disk.', position='Query'),
  ownerId?: long(name='OwnerId', description='The ID of the RAM user.', position='Query'),
  autoStartInstance?: boolean(name='AutoStartInstance', description='Indicates whether the instance is automatically started after the disk is reinitialized.

Default value: false', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', description='The ID of the resource master account, that is, the UID.', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='The account name of the resource master account.', position='Query'),
  password?: string(name='Password', description='Specifies whether to reset the username and password of the ECS instance when the system disk is reinitialized. The description must be 8 to 30 characters in length and must contain letters, digits, and special characters. Special symbols can be:

"""
()"~! @%& *-_+ =} [],.?/
"""

The Windows instance cannot start with a slash (/).

> If the "Password" parameter is specified, we recommend that you send requests over HTTPS to avoid password leakage.', position='Query'),
  securityEnhancementStrategy?: string(name='SecurityEnhancementStrategy', description='If the specified cloud disk is a system disk, whether to use security center for free after the cloud disk is reinitialized. Valid values:

-Active: used. This value only supports public images.

-Deactive: not used. This value supports all images.

Default value: Deactive', position='Query'),
  keyPairName?: string(name='KeyPairName', description='The name of the key pair.

> This parameter applies only to Linux instances. When you reinitialize the system disk, you can bind an SSH key pair to the ECS instance as the logon credential. After an SSH key pair is used, the logon credential for the username and password is disabled.', position='Query'),
}

model ReInitDiskResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.'),
}

model ReInitDiskResponse = {
  headers: map[string]string(name='headers'),
  body: ReInitDiskResponseBody(name='body'),
}

/**
 * ## API description

When you call this operation, note that:

-The status of the cloud disk must be **in use**(In_use). The status of the ECS instance attached to the cloud disk must be **Stopped**(Stopped).

-You cannot reinitialize the disks attached to the instance before it is started for the first time.

-A cloud disk that already has a local snapshot cannot be reinitialized.

-<props = "china"> cloud disks with multiple mount features enabled cannot be reinitialized. </props>

-The system disk is initialized to the initial state of the image. If the source image of the created cloud disk is deleted, it cannot be initialized.

-For directly created data disks, initialize them to the empty disk state.

-Initialize a data disk created from a snapshot to the snapshot state.

> for a data disk created from a snapshot, if the source snapshot has been deleted, it cannot be initialized and an error is returned.

 */
async function reInitDisk(request: ReInitDiskRequest): ReInitDiskResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ReInitDisk', 'POST', 'undefined', 'json', false, 'none', request);
}

model ModifyAutoSnapshotPolicyRequest {
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  systemDiskPolicyEnabled?: boolean(name='SystemDiskPolicyEnabled', position='Query'),
  systemDiskPolicyTimePeriod?: int32(name='SystemDiskPolicyTimePeriod', position='Query'),
  systemDiskPolicyRetentionDays?: int32(name='SystemDiskPolicyRetentionDays', position='Query'),
  systemDiskPolicyRetentionLastWeek?: boolean(name='SystemDiskPolicyRetentionLastWeek', position='Query'),
  dataDiskPolicyEnabled?: boolean(name='DataDiskPolicyEnabled', position='Query'),
  dataDiskPolicyTimePeriod?: int32(name='DataDiskPolicyTimePeriod', position='Query'),
  dataDiskPolicyRetentionDays?: int32(name='DataDiskPolicyRetentionDays', position='Query'),
  dataDiskPolicyRetentionLastWeek?: boolean(name='DataDiskPolicyRetentionLastWeek', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
}

model ModifyAutoSnapshotPolicyResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyAutoSnapshotPolicyResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyAutoSnapshotPolicyResponseBody(name='body'),
}

async function modifyAutoSnapshotPolicy(request: ModifyAutoSnapshotPolicyRequest): ModifyAutoSnapshotPolicyResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyAutoSnapshotPolicy', 'POST', 'undefined', 'json', false, 'none', request);
}

model AssociateEipAddressRequest {
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  allocationId?: string(name='AllocationId', position='Query'),
  instanceId?: string(name='InstanceId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  instanceType?: string(name='InstanceType', position='Query'),
}

model AssociateEipAddressResponseBody = {
  requestId?: string(name='RequestId'),
}

model AssociateEipAddressResponse = {
  headers: map[string]string(name='headers'),
  body: AssociateEipAddressResponseBody(name='body'),
}

async function associateEipAddress(request: AssociateEipAddressRequest): AssociateEipAddressResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'AssociateEipAddress', 'POST', 'undefined', 'json', false, 'none', request);
}

model DescribeSendFileResultsRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  regionId?: string(name='RegionId', description='The region ID of the ECS instance. You can call [DescribeRegions](~~ 25609 ~~) to view the latest region list.', position='Query'),
  name?: string(name='Name', description='The name of the file. After you specify this parameter, all delivery records of the name file are queried.', position='Query'),
  pageNumber?: long(name='PageNumber', description='The current page number.

Start value: 1

Default value: 1.', position='Query'),
  pageSize?: long(name='PageSize', description='The number of entries to return on each page.

Maximum Value: 50

Default value: 10', position='Query'),
  instanceId?: string(name='InstanceId', description='The ID of the instance. After you specify this parameter, all file distribution records of the instance are queried.', position='Query'),
  invokeId?: string(name='InvokeId', description='The ID of the execution.', position='Query'),
}

model DescribeSendFileResultsResponseBody = {
  pageSize?: long(name='PageSize', description='The number of rows per page.'),
  requestId?: string(name='RequestId', description='The ID of the request.'),
  pageNumber?: long(name='PageNumber', description='The current page number of the query result.'),
  totalCount?: long(name='TotalCount', description='The total number of scripts.'),
  invocations?: {
    invocation?: [ 
    {
      creationTime?: string(name='CreationTime', description='The time when the file delivery task was created.'),
      invocationStatus?: string(name='InvocationStatus', description='The total status of the file. The total status depends on the common execution status of all instances issued this time. Possible values:

-Pending: The system is verifying or distributing files. If the delivery status of at least one instance is Pending, the total status is Pending.
-Running: The file creation task is Running on the instance. If the status of at least one instance is Running, the total status is Running.
-Success: If the file status on each instance is Success, the total execution status is Success.
-Failed: if all files on each instance are in the Failed status, the total execution status is Failed. If one or more of the objects on the instance are in the following status, the returned value is Failed:
-Verification failed (Invalid)
-File sending failed (Aborted)
-Failed file creation
-File delivery Timeout (Timeout)
-File delivery exception (Error)
-PartialFailed: Some instances are successfully delivered and some instances fail to be executed. If the instance status is Success and Failed, the total execution status is PartialFailed.'),
      contentType?: string(name='ContentType', description='The content type of the file. Possible values:
-PlainText: Plain text
-Base64:Base64 encoding'),
      targetDir?: string(name='TargetDir', description='The destination path.'),
      fileOwner?: string(name='FileOwner', description='The user of the file.'),
      description?: string(name='Description', description='The description.'),
      vmCount?: int32(name='VmCount', description='The number of instances to be delivered.'),
      fileMode?: string(name='FileMode', description='The permissions of the file.'),
      fileGroup?: string(name='FileGroup', description='The user group of the file.'),
      invokeId?: string(name='InvokeId', description='The ID of the execution.'),
      name?: string(name='Name', description='The name of the file.'),
      content?: string(name='Content', description='The content of the file.'),
      overwrite?: string(name='Overwrite', description='Specifies whether to allow overwriting.'),
      invokeInstances?: {
        invokeInstance?: [ 
        {
          creationTime?: string(name='CreationTime', description='The creation time of the file delivery task.'),
          startTime?: string(name='StartTime', description='The time when the task starts to run in the instance.'),
          invocationStatus?: string(name='InvocationStatus', description='The status of the task.'),
          finishTime?: string(name='FinishTime', description='The end time of the task.'),
          updateTime?: string(name='UpdateTime', description='The time when the task status was updated.'),
          errorInfo?: string(name='ErrorInfo', description='The error message returned because the file failed to be delivered or failed to be executed. Possible values:

-Null: The file is delivered normally.
-the specified instance does not exists: the specified instance does not exist or has been released.
-the instance has released when create task: the instance is released during file delivery.
-the instance is not running when create task: the instance is not running.
-the specified account does not exists: the specified account does not exist.
-the aliyun service is not running on the instance: the cloud assistant client is not running.
-the aliyun service in the instance does not response: the cloud assistant client does not respond.
-the aliyun service in the instance is upgrading now: the cloud assistant client is being upgraded.
-the aliyun service in the instance need upgrade: the cloud assistant client needs to be upgraded.
-the command delivery has been timeout.
-Unexpected error during creating: file creation failed.
-File already exists: files with the same name exist in the same path.
-File content error: the File content is invalid.
-File name is invalid: the File name is invalid.
-File path is invalid: the File path is invalid.
-Owner not exists: the user does not exist.
-Group not exists: the user Group does not exist.
-Mode is invalid: The file permission is invalid.'),
          errorCode?: string(name='ErrorCode', description='The error message returned because the file failed to be delivered. Possible values:

-Null: The file is delivered normally.
-InstanceNotExists: the specified instance does not exist or has been released.
-InstanceReleased: the instance is released during file delivery.
-InstanceNotRunning: the instance is not running when you create a file task.
-AccountNotExists: the specified account does not exist.
-ClientNotRunning: The cloud assistant client is not running.
-ClientNotResponse: The cloud assistant client does not respond.
-ClientIsUpgrading: The cloud assistant client is being upgraded.
-ClientNeedUpgrade: The cloud assistant client needs to be upgraded.
-DeliveryTimeout: The file sending times out.
-FileCreateFail: file creation failed.
-FileAlreadyExists: files with the same name exist in the same path.
-FileContentInvalid: the file content is invalid.
-FileNameInvalid: the file name is invalid.
-FilePathInvalid: the file path is invalid.
-FileAuthorityInvalid: The file permission is invalid.'),
          instanceId?: string(name='InstanceId', description='The ID of the instance.'),
        }
      ](name='InvokeInstance')
      }(name='InvokeInstances', description='The type of the target instance set.'),
    }
  ](name='Invocation')
  }(name='Invocations', description='File Distribution records.'),
}

model DescribeSendFileResultsResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeSendFileResultsResponseBody(name='body'),
}

/**
 * ## API description
-After you deliver a file, it does not mean that the file is successfully delivered. You need to view the actual delivery result through the return value of the interface, and the actual output result shall prevail.
-You can query the distribution records in the last two weeks. The maximum number of distribution records is 100,000.
 */
async function describeSendFileResults(request: DescribeSendFileResultsRequest): DescribeSendFileResultsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeSendFileResults', 'POST', 'undefined', 'json', false, 'none', request);
}

model DeleteInstancesRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='The account name of the resource master account.', position='Query'),
  terminateSubscription?: boolean(name='TerminateSubscription', description='Specifies whether to release expired subscription instances.

Default value: false', position='Query'),
  dryRun?: boolean(name='DryRun', description='Specifies whether to PreCheck only this request.

-true: sends a check request without querying the resource status. Check whether the AccessKey is valid, whether the RAM user is authorized, and whether required parameters are specified. If the check fails, the corresponding error is returned. If the check succeeds, the error code DRYRUN.SUCCESS is returned.
-false (default): a normal request is sent. After the request passes the check, the 2XX HTTP status code is returned and the resource status is directly queried.', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', description='The ID of the resource master account, that is, the UID.', position='Query'),
  ownerId?: long(name='OwnerId', description='The ID of the RAM user.', position='Query'),
  clientToken?: string(name='ClientToken', description='Ensure the idempotence of the request. Generate a parameter value from your client. Make sure that the value is unique among different requests. **ClientToken** supports only ASCII characters and cannot exceed 64 characters. For more information, see [how to ensure idempotence](~~ 25693 ~~).', position='Query'),
  regionId?: string(name='RegionId', description='The ID of the region to which the instance belongs. You can call [DescribeRegions](~~ 25609 ~~) to view the latest region list.', position='Query'),
  force?: boolean(name='Force', description='Specifies whether to force the release of **running**("Running") ECS instances.

-true: forcibly releases **running**("Running") instances. Forced release is equivalent to power failure, and temporary data in the instance memory and storage will be erased and cannot be recovered.
-false (default): the instance is released. The instance must be in the **stopped**("Stopped") state.', position='Query'),
  instanceId?: [ string ](name='InstanceId', description='The ID of the instance. Valid values of N: 1 to 100.', position='Query'),
}

model DeleteInstancesResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.'),
}

model DeleteInstancesResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteInstancesResponseBody(name='body'),
}

/**
 * ## API description

-After the instance is released, all physical resources used by the instance are recycled, and all relevant data is lost and cannot be recovered.

-Disks attached to the instance:

-If "DeleteWithInstance = false" is set, the disks are converted to pay-as-you-go disks and retained.

-If "DeleteWithInstance = true" is set, the disk is released at the same time.

-If "DeleteAutoSnapshot = false", the automatic snapshot is retained.

-If "DeleteAutoSnapshot = true", the automatic snapshot is released.

-Keep the manual snapshot of the disk.

-The instance is under [security control](~~ 25695 ~~) and "OperationLocks" is marked with "LockReason ": "Security", even if the "DeleteWithInstance" attribute of the cloud disk is "false ", the system ignores this attribute and releases the disk.
 */
async function deleteInstances(request: DeleteInstancesRequest): DeleteInstancesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteInstances', 'POST', 'undefined', 'json', false, 'none', request);
}

model CreateDedicatedHostClusterRequest {
  tag?: [ 
    {
      key?: string(name='Key', description='专有宿主机集群的标签键。N的取值范围：1~20。一旦传入该值，则不允许为空字符串。最多支持64个字符，不能以`aliyun`和`acs:`开头，不能包含`http://`或`https://`。'),
      value?: string(name='Value', description='专有宿主机集群的标签值。N的取值范围：1~20。一旦传入该值，则不允许为空字符串。最多支持64个字符，不能以`aliyun`和`acs:`开头，不能包含`http://`或`https://`。'),
    }
  ](name='Tag', position='Query'),
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  regionId?: string(name='RegionId', description='The region ID of the DDH cluster. You can call [DescribeRegions](~~ 25609 ~~) to view the latest region list.', position='Query'),
  dryRun?: boolean(name='DryRun', description='Specifies whether to PreCheck only this request. Valid values:

-true: sends a check request without querying the resource status. Check whether the AccessKey is valid, whether the RAM user is authorized, and whether required parameters are specified. If the check fails, the corresponding error is returned. If the check succeeds, the error code "DryRunOperation" is returned ".
-false: a normal request is sent. After the request passes the check, the 2XX HTTP status code is returned and the resource status is directly queried.

Default value: false', position='Query'),
  description?: string(name='Description', description='The description of the DDH cluster. The description must be 2 to 256 characters in length. It cannot start with "http:// "or "https.

Default value: Null.', position='Query'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group to which the DDH cluster belongs.', position='Query'),
  dedicatedHostClusterName?: string(name='DedicatedHostClusterName', description='The name of the DDH cluster. The name must be 2 to 128 characters in length and can contain letters, digits, periods (.), underscores (_), and hyphens (-). It must start with a letter. It cannot contain "http:// "or "https://".

Default value: Null.', position='Query'),
  zoneId?: string(name='ZoneId', description='The ID of the zone where the dedicated host cluster is located. You can call [DescribeZones](~~ 25610 ~~) to view the zones in the Alibaba Cloud region.', position='Query'),
}

model CreateDedicatedHostClusterResponseBody = {
  dedicatedHostClusterId?: string(name='DedicatedHostClusterId', description='The ID of the DDH cluster.'),
  requestId?: string(name='RequestId', description='The ID of the request.'),
}

model CreateDedicatedHostClusterResponse = {
  headers: map[string]string(name='headers'),
  body: CreateDedicatedHostClusterResponseBody(name='body'),
}

async function createDedicatedHostCluster(request: CreateDedicatedHostClusterRequest): CreateDedicatedHostClusterResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateDedicatedHostCluster', 'POST', 'undefined', 'json', false, 'none', request);
}

model TerminateVirtualBorderRouterRequest {
  regionId?: string(name='RegionId', position='Query'),
  vbrId?: string(name='VbrId', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  clientToken?: string(name='ClientToken', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  userCidr?: string(name='UserCidr', position='Query'),
}

model TerminateVirtualBorderRouterResponseBody = {
  requestId?: string(name='RequestId'),
}

model TerminateVirtualBorderRouterResponse = {
  headers: map[string]string(name='headers'),
  body: TerminateVirtualBorderRouterResponseBody(name='body'),
}

async function terminateVirtualBorderRouter(request: TerminateVirtualBorderRouterRequest): TerminateVirtualBorderRouterResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'TerminateVirtualBorderRouter', 'POST', 'undefined', 'json', false, 'none', request);
}

model DescribeInstanceHistoryEventsRequest {
  notBefore?: {
    start?: string(name='Start', description='Queries the start time of the scheduled execution time of system events. The time follows the [ISO8601](~~ 25696 ~~) standard and uses UTC +0. The format is yyyy-MM-ddTHH:mm:ssZ.', position=''),
    end?: string(name='End', description='Queries the end time of the scheduled execution time of system events. The time follows the [ISO8601](~~ 25696 ~~) standard and uses UTC +0. The format is yyyy-MM-ddTHH:mm:ssZ.', position=''),
  }(name='NotBefore'),
  eventPublishTime?: {
    start?: string(name='Start', description='Query the start time of the system event release time. The time follows the [ISO8601](~~ 25696 ~~) standard and uses UTC +0. The format is yyyy-MM-ddTHH:mm:ssZ.', position=''),
    end?: string(name='End', description='Query the end time of the system event release time. The time follows the [ISO8601](~~ 25696 ~~) standard and uses UTC +0. The format is yyyy-MM-ddTHH:mm:ssZ.', position=''),
  }(name='EventPublishTime'),
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  impactLevel?: string(name='ImpactLevel', position='Query'),
  eventId?: [ string ](name='EventId', position='Query'),
  instanceEventCycleStatus?: [ string ](name='InstanceEventCycleStatus', position='Query'),
  instanceEventType?: [ string ](name='InstanceEventType', position='Query'),
  resourceId?: [ string ](name='ResourceId', position='Query'),
  tag?: [ 
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='Tag', position='Query'),
  resourceGroupId?: string(name='ResourceGroupId', position='Query'),
  regionId?: string(name='RegionId', description='The region ID of the instance. You can call [DescribeRegions](~~ 25609 ~~) to view the latest region list.', position='Query'),
  pageSize?: int32(name='PageSize', description='The number of entries to return on each page. Valid values: 1 to 100.

Default value: 10', position='Query'),
  eventCycleStatus?: string(name='EventCycleStatus', description='The lifecycle status of a system event. EventCycleStatus is valid only when the InstanceEventCycleStatus.N parameter is not specified. Valid values:

-Scheduled: pending events
-Avoided: The event has been Avoided.
-Executing: The event is being executed.
-Executed: The event has been Executed.
-Canceled: The event has been Canceled.
-Failed: the event Failed to be executed.
-Inquiring: The event is being inquired.
', position='Query'),
  resourceType?: string(name='ResourceType', description='The type of the resource. Valid values:

-instance:ECS instance
-ddh: Dedicated host
-managedhost: physical machines in the intelligent fully managed resource pool

Default value: instance', position='Query'),
  pageNumber?: int32(name='PageNumber', description='The page number of the query result. Value range: positive integer

Default value: 1.', position='Query'),
  eventType?: string(name='EventType', description='The type of the system event. EventType parameter is valid only when the InstanceEventType.N parameter is not specified. Valid values:

-SystemMaintenance.Reboot: The instance is restarted due to system maintenance.
-SystemMaintenance.Redeploy: the instance is redeployed due to system maintenance.
-SystemFailure.Reboot: The instance is restarted due to a system error.
-SystemFailure.Redeploy: the instance is redeployed due to a system error.
-SystemFailure.Delete: the instance is released due to an instance creation failure.
-InstanceFailure.Reboot: The instance is restarted due to an instance error.
-InstanceExpiration.Stop: the instance is stopped because the subscription period expires.
-InstanceExpiration.Delete: the instance is released because the subscription period expires.
-AccountUnbalanced.Stop: the pay-as-you-go instance is stopped due to an overdue payment.
-AccountUnbalanced.Delete: the pay-as-you-go instance is released due to an overdue payment.
', position='Query'),
  instanceId?: string(name='InstanceId', description='The ID of the resource. Valid values:

-When "ResourceType = instance", the resource ID indicates the ID of the ECS instance.
-When "ResourceType = ddh", the resource ID indicates the ID of the dedicated host.
-When "ResourceType = managedhost", the resource ID indicates the ID of the physical machine in the intelligent fully managed resource pool.

If you do not specify this parameter, system events of all resources in the specified region ("RegionId") and resource type ("ResourceType") are queried.

> We recommend that you use the "ResourceId. **parameter to set one or more resource IDs. If you specify both the "ResourceId. **parameter and the "InstanceId" parameter, the "ResourceId.** parameter takes effect first by default.', position='Query'),
}

model DescribeInstanceHistoryEventsResponseBody = {
  pageSize?: int32(name='PageSize', description='The number of entries to return on each page.'),
  requestId?: string(name='RequestId', description='The ID of the request.'),
  pageNumber?: int32(name='PageNumber', description='The page number of the instance list.'),
  totalCount?: int32(name='TotalCount', description='The total number of instances.'),
  instanceSystemEventSet?: {
    instanceSystemEventType?: [ 
    {
      eventId?: string(name='EventId', description='The ID of the system event.'),
      eventPublishTime?: string(name='EventPublishTime', description='The release time of the system event. The time follows the [ISO8601](~~ 25696 ~~) standard and uses UTC +0. The format is yyyy-MM-ddTHH:mm:ssZ.'),
      eventFinishTime?: string(name='EventFinishTime', description='The end time of the system event. The time follows the [ISO8601](~~ 25696 ~~) standard and uses UTC +0. The format is yyyy-MM-ddTHH:mm:ssZ.'),
      resourceType?: string(name='ResourceType', description='The type of the resource. Possible values:

-instance:ECS instance
-ddh: Dedicated host
-managedhost: physical machines in the intelligent fully managed resource pool'),
      impactLevel?: string(name='ImpactLevel', description='The impact level.'),
      notBefore?: string(name='NotBefore', description='The scheduled execution time of the system event. The time follows the [ISO8601](~~ 25696 ~~) standard and uses UTC +0. The format is yyyy-MM-ddTHH:mm:ssZ.'),
      instanceId?: string(name='InstanceId', description='The ID of the resource.'),
      reason?: string(name='Reason', description='The cause of the system event.'),
      eventType?: {
        name?: string(name='Name', description='The name of the system event type.'),
        code?: int32(name='Code', description='The system event type code.'),
      }(name='EventType', description='The type of the system event.'),
      eventCycleStatus?: {
        name?: string(name='Name', description='The name of the system event status.'),
        code?: int32(name='Code', description='The system event status code.'),
      }(name='EventCycleStatus', description='The lifecycle status of a system event.'),
      extendedAttribute?: {
        device?: string(name='Device', description='The name of the local disk device.'),
        diskId?: string(name='DiskId', description='The ID of the local disk.'),
        inactiveDisks?: {
          inactiveDisk?: [ 
          {
            creationTime?: string(name='CreationTime', description='The time when the cloud disk or local disk was created. The time follows the [ISO8601](~~ 25696 ~~) standard and uses UTC +0. The format is yyyy-MM-ddTHH:mm:ssZ.'),
            deviceSize?: string(name='DeviceSize', description='The size of the cloud disk or local disk. Unit: GiB.'),
            deviceCategory?: string(name='DeviceCategory', description='The type of the cloud disk or local disk. Possible values:
-cloud: basic cloud disk
-cloud_efficiency: Ultra disk
-cloud_ssd:SSD
-cloud_essd:ESSD
-local_ssd_pro:I/O-intensive local disks
-local_hdd_pro: Throughput-intensive local disks
-ephemeral:(discontinued) local disk
-ephemeral_ssd:(phased out) local SSD'),
            deviceType?: string(name='DeviceType', description='The type of the cloud disk or local disk. Possible values:
-system: system disk
-data: data disk'),
            releaseTime?: string(name='ReleaseTime', description='The release time of the cloud disk or local disk. The time follows the [ISO8601](~~ 25696 ~~) standard and uses UTC +0. The format is yyyy-MM-ddTHH:mm:ssZ.'),
          }
        ](name='InactiveDisk')
        }(name='InactiveDisks', description='An array of inactive or local disks that have been released but need to be cleaned.'),
        hostType?: string(name='HostType'),
        hostId?: string(name='HostId'),
      }(name='ExtendedAttribute', description='Event extension properties.'),
    }
  ](name='InstanceSystemEventType')
  }(name='InstanceSystemEventSet', description='An array of historical system events.'),
}

model DescribeInstanceHistoryEventsResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeInstanceHistoryEventsResponseBody(name='body'),
}

/**
 * ## API description

-You can query a maximum of 30 closed system events in the last 30 days. There is no query time limit for unfinished system events.

-By specifying InstanceEventCycleStatus parameters, you can also query system events in the Scheduled (pending events), Executing (Executing events), and Inquiring (questioning events) states.
 */
async function describeInstanceHistoryEvents(request: DescribeInstanceHistoryEventsRequest): DescribeInstanceHistoryEventsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeInstanceHistoryEvents', 'POST', 'undefined', 'json', false, 'none', request);
}

model DescribeInstanceTopologyRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  instanceIds?: string(name='InstanceIds', description='The ID of one or more ECS instances. A maximum of 100 ECS instances are supported.', position='Query'),
  regionId?: string(name='RegionId', description='The region ID of the ECS instance. You can call [DescribeRegions](~~ 25609 ~~) to view the latest region list.', position='Query'),
}

model DescribeInstanceTopologyResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.'),
  topologys?: {
    topology?: [ 
    {
      hostId?: string(name='HostId', description='The ID of the physical machine to which the ECS instance belongs. After encryption, it cannot directly match the identity of Alibaba Cloud resources. However, if the values of different ECS instances are the same, the ECS instances are on the same physical server.'),
      instanceId?: string(name='InstanceId', description='The ID of the instance.'),
    }
  ](name='Topology')
  }(name='Topologys', description='The topology details.'),
}

model DescribeInstanceTopologyResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeInstanceTopologyResponseBody(name='body'),
}

/**
 * > The DescribeInstanceTopology is in the beta phase. Please wait patiently. Thank you for your support!
 */
async function describeInstanceTopology(request: DescribeInstanceTopologyRequest): DescribeInstanceTopologyResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeInstanceTopology', 'POST', 'undefined', 'json', false, 'none', request);
}

model CheckAutoSnapshotPolicyRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  systemDiskPolicyEnabled?: boolean(name='SystemDiskPolicyEnabled', position='Query'),
  systemDiskPolicyTimePeriod?: int32(name='SystemDiskPolicyTimePeriod', position='Query'),
  systemDiskPolicyRetentionDays?: int32(name='SystemDiskPolicyRetentionDays', position='Query'),
  systemDiskPolicyRetentionLastWeek?: boolean(name='SystemDiskPolicyRetentionLastWeek', position='Query'),
  dataDiskPolicyEnabled?: boolean(name='DataDiskPolicyEnabled', position='Query'),
  dataDiskPolicyTimePeriod?: int32(name='DataDiskPolicyTimePeriod', position='Query'),
  dataDiskPolicyRetentionDays?: int32(name='DataDiskPolicyRetentionDays', position='Query'),
  dataDiskPolicyRetentionLastWeek?: boolean(name='DataDiskPolicyRetentionLastWeek', position='Query'),
}

model CheckAutoSnapshotPolicyResponseBody = {
  requestId?: string(name='RequestId'),
  isPermittedModify?: string(name='IsPermittedModify'),
  autoSnapshotOccupation?: int32(name='AutoSnapshotOccupation'),
}

model CheckAutoSnapshotPolicyResponse = {
  headers: map[string]string(name='headers'),
  body: CheckAutoSnapshotPolicyResponseBody(name='body'),
}

async function checkAutoSnapshotPolicy(request: CheckAutoSnapshotPolicyRequest): CheckAutoSnapshotPolicyResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CheckAutoSnapshotPolicy', 'POST', 'undefined', 'json', false, 'none', request);
}

model RevokeSecurityGroupRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', description='The ID of the resource master account, that is, the UID.', position='Query'),
  securityGroupId?: string(name='SecurityGroupId', description='The ID of the destination security group.', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='The account name of the resource master account.', position='Query'),
  ownerId?: long(name='OwnerId', description='The ID of the RAM user.', position='Query'),
  regionId?: string(name='RegionId', description='The region ID of the destination security group. You can call [DescribeRegions](~~ 25609 ~~) to view the latest region list.', position='Query'),
  sourceGroupOwnerAccount?: string(name='SourceGroupOwnerAccount', description='The Alibaba Cloud account to which the source Security Group belongs when you delete a security group rule across accounts.

-If "SourceGroupOwnerAccount" and "SourceGroupOwnerId" are not set, the access permission of other security groups is revoked.
-If the "SourceCidrIp" parameter is set, the "SourceGroupOwnerAccount" parameter is invalid.', position='Query'),
  description?: string(name='Description', description='The description of the security group rule.', position='Query'),
  sourceGroupId?: string(name='SourceGroupId', description='The ID of the source security group to which you want to revoke access permissions. Set at least one "SourceGroupId" or "SourceCidrIp" parameter.

-If "SourceGroupId" is specified but "SourceCidrIp" is not specified, the value of "NicType" can only be intranet.
-If both "SourceGroupId" and "SourceCidrIp" are specified, the default value is "SourceCidrIp.', position='Query'),
  nicType?: string(name='NicType', description='The NIC type of the classic network security group rule. Valid values:

-internet: internet Nic
-intranet: intranet Nic

Default value: internet

In the following cases, the parameter NicType can only be set to intranet:
-You do not need to set the Nic type for VPC-type security group rules. The default value is intranet, which can only be intranet.
-When you set the mutual access between security groups, that is, only the "SourceGroupId" parameter is specified, it can only be intranet.

', position='Query'),
  portRange?: string(name='PortRange', description='The port range related to the transport layer protocol opened by the destination security group. Valid values:

-TCP/UDP: valid values: 1 to 65535. Use a slash (/) to separate the start port from the end port. Example: 1/200
-ICMP:-1/-1
-GRE protocol:-1/-1
-all:-1/-1', position='Query'),
  sourcePortRange?: string(name='SourcePortRange', description='The range of ports related to the transport layer protocol opened by the source security group. Valid values:

-TCP/UDP: valid values: 1 to 65535. Use a slash (/) to separate the start port from the end port. Example: 1/200
-ICMP:-1/-1
-GRE protocol:-1/-1
-all:-1/-1', position='Query'),
  ipv6DestCidrIp?: string(name='Ipv6DestCidrIp', description='The Destination IPv6 CIDR block. CIDR and IPv6 IP addresses are supported.

> only VPC-type IP addresses are supported.

Default value: None', position='Query'),
  clientToken?: string(name='ClientToken', description='Ensure the idempotence of the request. Generate a parameter value from your client. Make sure that the value is unique among different requests. **ClientToken** supports only ASCII characters and cannot exceed 64 characters. For more information, see [how to ensure idempotence](~~ 25693 ~~).', position='Query'),
  priority?: string(name='Priority', description='The priority of the security group rule. Valid values: 1 to 100.

Default value: 1.', position='Query'),
  ipProtocol?: string(name='IpProtocol', description='The transport layer protocol. Parameter values are case sensitive. Valid values:

-icmp
-gre
-tcp
-udp
-all: all protocols are supported.', position='Query'),
  destCidrIp?: string(name='DestCidrIp', description='The range of destination IP addresses. CIDR and IPv4 IP addresses are supported. Default value: 0.0.0.0/0', position='Query'),
  policy?: string(name='Policy', description='The access permission. Valid values:

-accept: accept access
-drop: denies access and does not send back the deny message.

Default value: accept', position='Query'),
  ipv6SourceCidrIp?: string(name='Ipv6SourceCidrIp', description='The source IPv6 CIDR block to which you want to revoke access permissions. CIDR and IPv6 IP addresses are supported.

> only VPC-type IP addresses are supported.

Default value: None
', position='Query'),
  sourceCidrIp?: string(name='SourceCidrIp', description='The source IPv4 CIDR block to which you want to revoke access permissions. CIDR and IPv4 IP addresses are supported.

Default value: 0.0.0.0/0', position='Query'),
  sourcePrefixListId?: string(name='SourcePrefixListId', description='The ID of the source prefix to be revoked. You can call [DescribePrefixLists](~~ 205046 ~~) to query the list IDs of available prefixes.

Note:

-If the network type of a security group is classic network, the prefix list cannot be set. For more information about security groups and Prefix List restrictions, see [Security Group restrictions](~~ 25412#SecurityGroupQuota1 ~~).
-If you specify one of the "SourceCidrIp", "Ipv6SourceCidrIp", or "SourceGroupId" parameters, this parameter is ignored.', position='Query'),
  sourceGroupOwnerId?: long(name='SourceGroupOwnerId', description='The ID of the Alibaba Cloud account to which the source Security Group belongs when you delete a security group rule across accounts.

-If "SourceGroupOwnerId" and "SourceGroupOwnerAccount" are not set, the access permission of other security groups is revoked.
-If you have set the "SourceCidrIp" parameter, the "SourceGroupOwnerId" parameter is invalid.', position='Query'),
}

model RevokeSecurityGroupResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.'),
}

model RevokeSecurityGroupResponse = {
  headers: map[string]string(name='headers'),
  body: RevokeSecurityGroupResponseBody(name='body'),
}

/**
 * ## API description

In the API document of the security group, the initiator of the traffic is the Source and the receiver of the data transmission is the Dest.

-Any of the following parameters can match an inbound rule of a security group. Only one parameter can be specified to determine a security group rule.

-Revoke the access permission of the specified CIDR block. For example, IpProtocol, PortRange, (optional) SourcePortRange, NicType, Policy, (optional) DestCidrIp, and SourceCidrIp.

"""
https://ecs.aliyuncs.com/? Action=RevokeSecurityGroup
&SecurityGroupId=sg-bp67acfmxazb4p ****
&SourceCidrIp=10.0.0.0/8
&IpProtocol=tcp
&PortRange=80/80
&NicType=intranet
&Policy=accept
& <common request parameters>
"""

-Revoke permission settings for other security groups. For example, IpProtocol, PortRange, (optional) SourcePortRange, NicType, Policy, (optional) DestCidrIp, and SourceGroupId.

"""
https://ecs.aliyuncs.com/? Action=RevokeSecurityGroup
&SecurityGroupId=sg-bp67acfmxazb4p ****
&SourceGroupId=sg-bp67acfmxa123b ****
&IpProtocol=tcp
&PortRange=80/80
&NicType=intranet
&Policy=accept
& <common request parameters>
"""
-Revokes security group rules associated with the prefix list. For example, IpProtocol, PortRange, (optional) SourcePortRange, NicType, Policy, (optional) DestCidrIp, and SourcePrefixListId.

"""
https://ecs.aliyuncs.com/? Action=RevokeSecurityGroup
&SecurityGroupId=sg-bp67acfmxazb4p ****
&SourcePrefixListId=pl-x1j1k5ykzqlixdcy ****
&IpProtocol=tcp
&PortRange=80/80
&NicType=intranet
&Policy=accept
& <common request parameters>
"""

-If the specified security group rule does not exist, the RevokeSecurityGroup is called successfully, but no rules are deleted.
 */
async function revokeSecurityGroup(request: RevokeSecurityGroupRequest): RevokeSecurityGroupResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'RevokeSecurityGroup', 'POST', 'undefined', 'json', false, 'none', request);
}

model DescribeTaskAttributeRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  regionId?: string(name='RegionId', description='The ID of the region. You can call [DescribeRegions](~~ 25609 ~~) to view the latest region list.', position='Query'),
  taskId?: string(name='TaskId', description='The ID of the task. You can call [DescribeTasks](~~ 25622 ~~) to view the task ID.', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', description='The ID of the resource master account, that is, the UID.', position='Query'),
  ownerId?: long(name='OwnerId', description='The ID of the RAM user.', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='The account name of the resource master account.', position='Query'),
}

model DescribeTaskAttributeResponseBody = {
  creationTime?: string(name='CreationTime', description='The time when the task was created.'),
  supportCancel?: string(name='SupportCancel', description='Indicates whether the task can be canceled ([CancelTask](~~ 25624 ~~)). Valid values:

-true: can be canceled
-false: cannot be canceled.
'),
  totalCount?: int32(name='TotalCount', description='The total number of tasks.'),
  successCount?: int32(name='SuccessCount', description='The number of successful tasks.'),
  regionId?: string(name='RegionId', description='The ID of the region.'),
  taskAction?: string(name='TaskAction', description='The operation that you want to perform.'),
  failedCount?: int32(name='FailedCount', description='The number of failed tasks.'),
  requestId?: string(name='RequestId', description='The ID of the request.'),
  taskStatus?: string(name='TaskStatus', description='The status of the task.'),
  taskProcess?: string(name='TaskProcess', description='The process of the task.'),
  finishedTime?: string(name='FinishedTime', description='The time when the task was completed.'),
  taskId?: string(name='TaskId', description='The ID of the task.'),
  operationProgressSet?: {
    operationProgress?: [ 
    {
      errorMsg?: string(name='ErrorMsg', description='The error message.'),
      errorCode?: string(name='ErrorCode', description='The error code.'),
      operationStatus?: string(name='OperationStatus', description='The operation status.'),
      relatedItemSet?: {
        relatedItem?: [ 
        {
          name?: string(name='Name', description='The name of the relevant item.'),
          value?: string(name='Value', description='The value of the relevant item.'),
        }
      ](name='RelatedItem')
      }(name='RelatedItemSet', description='The type of the resource information.'),
    }
  ](name='OperationProgress')
  }(name='OperationProgressSet', description='The information contained in the returned task, including the status and related information of each subtask.'),
}

model DescribeTaskAttributeResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeTaskAttributeResponseBody(name='body'),
}

async function describeTaskAttribute(request: DescribeTaskAttributeRequest): DescribeTaskAttributeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeTaskAttribute', 'POST', 'undefined', 'json', false, 'none', request);
}

model ModifyReservedInstanceAttributeRequest {
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  reservedInstanceId?: string(name='ReservedInstanceId', position='Query'),
  reservedInstanceName?: string(name='ReservedInstanceName', position='Query'),
  description?: string(name='Description', position='Query'),
}

model ModifyReservedInstanceAttributeResponseBody = {
  httpStatusCode?: int32(name='HttpStatusCode'),
  code?: string(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model ModifyReservedInstanceAttributeResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyReservedInstanceAttributeResponseBody(name='body'),
}

async function modifyReservedInstanceAttribute(request: ModifyReservedInstanceAttributeRequest): ModifyReservedInstanceAttributeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyReservedInstanceAttribute', 'POST', 'undefined', 'json', false, 'none', request);
}

model ReActivateInstancesRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  instanceId?: string(name='InstanceId', description='The ID of the instance to be restarted.', position='Query'),
  regionId?: string(name='RegionId', description='The ID of the region to which the instance belongs. You can call [DescribeRegions](~~ 25609 ~~) to view the latest region list.', position='Query'),
}

model ReActivateInstancesResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.
'),
}

model ReActivateInstancesResponse = {
  headers: map[string]string(name='headers'),
  body: ReActivateInstancesResponseBody(name='body'),
}

/**
 * ## API description

When you call this operation, note that:

-<props = "china"> The instance must be in the **expired**("Stopped") or **overdue recycling**("Stopped") status. </props>

-<props = "intl"> The instance must be in the **expired**("Stopped") state. </props>

-<props = "china"> You must pay the bill and restart the instance within 15 days after the instance is stopped due to overdue payments. If the instance is not restarted after the overdue bill is settled, the instance is automatically released 15 days after the overdue bill is settled, and the data cannot be recovered. If you restart a pay-as-you-go VPC instance, the instance may fail to be restarted. Please try again at intervals or [submit a ticket](https://selfservice.console.aliyun.com/ticket/createIndex.htm). </props>

-<props = "intl"> to prevent the instance from being released and data cannot be recovered, you must clear the bill and restart the instance within 15 days after the instance is stopped due to overdue payments. If you cannot restart a VPC instance, try again at intervals or [open a ticket](https://workorder-intl.console.aliyun.com/#/ticket/createIndex) to contact Alibaba Cloud. </props>

-<props = "china"> after the overdue payment is settled, the total value of your Alibaba Cloud account balance (cash balance) and voucher cannot be less than RMB 100.00. Otherwise, the instance cannot be restarted. For more information about business restrictions, see [reboot instance](~~ 34374 ~~). </props>

-After the API is called, the instance enters the **starting**("Starting") state.

-Quilt safety locking ECS instance "operationlocks" parameter contains ""LockReason": "security"" not supported when call the interface. For more information, see [API actions for security lock](~~ 25695 ~~).

 */
async function reActivateInstances(request: ReActivateInstancesRequest): ReActivateInstancesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ReActivateInstances', 'POST', 'undefined', 'json', false, 'none', request);
}

model DescribeForwardTableEntriesRequest {
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  forwardTableId?: string(name='ForwardTableId', position='Query'),
  forwardEntryId?: string(name='ForwardEntryId', position='Query'),
  pageNumber?: int32(name='PageNumber', position='Query'),
  pageSize?: int32(name='PageSize', position='Query'),
}

model DescribeForwardTableEntriesResponseBody = {
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  pageNumber?: int32(name='PageNumber'),
  totalCount?: int32(name='TotalCount'),
  forwardTableEntries?: {
    forwardTableEntry?: [ 
    {
      status?: string(name='Status'),
      forwardEntryId?: string(name='ForwardEntryId'),
      internalIp?: string(name='InternalIp'),
      internalPort?: string(name='InternalPort'),
      forwardTableId?: string(name='ForwardTableId'),
      externalPort?: string(name='ExternalPort'),
      ipProtocol?: string(name='IpProtocol'),
      externalIp?: string(name='ExternalIp'),
    }
  ](name='ForwardTableEntry')
  }(name='ForwardTableEntries'),
}

model DescribeForwardTableEntriesResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeForwardTableEntriesResponseBody(name='body'),
}

async function describeForwardTableEntries(request: DescribeForwardTableEntriesRequest): DescribeForwardTableEntriesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeForwardTableEntries', 'POST', 'undefined', 'json', false, 'none', request);
}

model CreateImageComponentRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  resourceGroupId?: string(name='ResourceGroupId', position='Query'),
  tag?: [ 
    {
      key?: string(name='Key', description='标签键。N的取值范围：1~20。一旦传入该值，则不允许为空字符串。最多支持128个字符，不能以aliyun和acs:开头，不能包含http://或者https://。'),
      value?: string(name='Value', description='标签值。N的取值范围：1~20。一旦传入该值，可以为空字符串。最多支持128个字符，不能以acs:开头，不能包含http://或者https://。'),
    }
  ](name='Tag', position='Query'),
  systemType?: string(name='SystemType', description='The operating system supported by the component. Currently, only Linux is supported. Set the value to Linux.

Default value: Linux', position='Query'),
  name?: string(name='Name', description='The name of the component. The description must be 2 to 128 characters in length. It must start with a letter and cannot start with http:// or https. It can contain letters, digits, colons (:), underscores (_), periods (.), and hyphens (-).

> If "Name" is not set, "ImageComponentId" is returned by default.', position='Query'),
  description?: string(name='Description', description='The description. The description must be 2 to 256 characters in length and cannot start with http:// or https.', position='Query'),
  componentType?: string(name='ComponentType', description='The type of the component. Currently, only Image building components are supported. Set the value to Build.

Default value: Build', position='Query'),
  clientToken?: string(name='ClientToken', description='Ensure the idempotence of the request. Generate a parameter value from your client. Make sure that the value is unique among different requests. **ClientToken** supports only ASCII characters and cannot exceed 64 characters. For more information, see [how to ensure idempotence](~~ 25693 ~~).', position='Query'),
  content?: string(name='Content', description='<props = "china"> component content. It consists of multiple commands. The maximum number of commands cannot exceed 127. For more information about supported commands and command formats, see [commands supported by image building service](~~ 200206 ~~). </props>

<props = "intl"> component content. It consists of multiple commands. The maximum number of commands cannot exceed 127. </props>

<props = "partner"> component content. It consists of multiple commands. The maximum number of commands cannot exceed 127. </props>
', position='Query'),
}

model CreateImageComponentResponseBody = {
  imageComponentId?: string(name='ImageComponentId', description='The ID of the image component.'),
  requestId?: string(name='RequestId', description='The ID of the request.'),
}

model CreateImageComponentResponse = {
  headers: map[string]string(name='headers'),
  body: CreateImageComponentResponseBody(name='body'),
}

/**
 * ## API description

Before creating an image component, note the following:

-You can only create custom image components.
-Only Linux systems are supported, that is, "SystemType = Linux ".
-You can only set the component type to build images, that is, "ComponentType = Build ".
-You can edit the content of an image component by using the Dockerfile and pass the content to the "Content" parameter. The size of the content cannot exceed 16KB. The "FROM" command is not supported. A single image component supports a maximum of 127 commands. For more information about supported commands, see [commands supported by image building service](~~ 200206 ~~).

You cannot use an API to create an image template. This feature is only supported by console operations. For more information, see [image building Overview](~~ 197410 ~~).



 */
async function createImageComponent(request: CreateImageComponentRequest): CreateImageComponentResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateImageComponent', 'POST', 'undefined', 'json', false, 'none', request);
}

model DescribeSecurityGroupReferencesRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='The account name of the resource master account.', position='Query'),
  regionId?: string(name='RegionId', description='The region to which the security group belongs.', position='Query'),
  securityGroupId?: [ string ](name='SecurityGroupId', description='The nth SecurityGroupId to be queried. Valid values of N: 1 to 10.', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', description='The ID of the resource master account, that is, the UID.', position='Query'),
  ownerAccount?: string(name='OwnerAccount', description='The logon name of the RAM user.', position='Query'),
}

model DescribeSecurityGroupReferencesResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.'),
  securityGroupReferences?: {
    securityGroupReference?: [ 
    {
      securityGroupId?: string(name='SecurityGroupId', description='The security group that you want to query.'),
      referencingSecurityGroups?: {
        referencingSecurityGroup?: [ 
        {
          securityGroupId?: string(name='SecurityGroupId', description='The ID of the security group.'),
          aliUid?: string(name='AliUid', description='The ID of the user to which the security group belongs.'),
        }
      ](name='ReferencingSecurityGroup')
      }(name='ReferencingSecurityGroups', description='The information about other security groups that are being authorized to this security group.'),
    }
  ](name='SecurityGroupReference')
  }(name='SecurityGroupReferences', description='The complete authorization information of all user-specified security groups.'),
}

model DescribeSecurityGroupReferencesResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeSecurityGroupReferencesResponseBody(name='body'),
}

/**
 * ## API description

When you call this operation, note that:

-Authorization includes inbound and outbound authorization.

-This operation can return up to 100 records at a time.

-If you cannot delete a security group ([DeleteSecurityGroup](~~ 25558 ~~)), you can call this operation to check whether the specified security group has been authorized by other security groups. If the specified security group has been authorized, you must revoke the authorization before deleting the security group.
 */
async function describeSecurityGroupReferences(request: DescribeSecurityGroupReferencesRequest): DescribeSecurityGroupReferencesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeSecurityGroupReferences', 'POST', 'undefined', 'json', false, 'none', request);
}

model DeleteRouterInterfaceRequest {
  regionId?: string(name='RegionId', position='Query'),
  routerInterfaceId?: string(name='RouterInterfaceId', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  clientToken?: string(name='ClientToken', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  userCidr?: string(name='UserCidr', position='Query'),
}

model DeleteRouterInterfaceResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteRouterInterfaceResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteRouterInterfaceResponseBody(name='body'),
}

async function deleteRouterInterface(request: DeleteRouterInterfaceRequest): DeleteRouterInterfaceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteRouterInterface', 'POST', 'undefined', 'json', false, 'none', request);
}

model AttachVolumeRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  instanceId?: string(name='InstanceId', position='Query'),
  volumeId?: string(name='VolumeId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
}

model AttachVolumeResponseBody = {
  requestId?: string(name='RequestId'),
}

model AttachVolumeResponse = {
  headers: map[string]string(name='headers'),
  body: AttachVolumeResponseBody(name='body'),
}

async function attachVolume(request: AttachVolumeRequest): AttachVolumeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'AttachVolume', 'POST', 'undefined', 'json', false, 'none', request);
}

model ModifyReservedInstancesRequest {
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  configuration?: [ 
    {
      reservedInstanceName?: string(name='ReservedInstanceName', description='预留实例券的名称。N的取值范围：1~100

长度为2~128个英文或中文字符。必须以大小写字母或中文开头，不能以http://和https://开头。可以包含数字、半角冒号（:）、下划线（_）或者连字符（-）。'),
      zoneId?: string(name='ZoneId', description='预留实例券所属的可用区编号。N的取值范围：1~100

`Scope`参数值为`Zone`时，该参数为必填参数。

您可以调用[DescribeZones](~~25609~~)获取可用区列表。 '),
      scope?: string(name='Scope', description='预留实例券的范围。取值范围： 

- Region：地域级别
- Zone：可用区级别

N的取值范围：1~100

默认值：Region  '),
      instanceType?: string(name='InstanceType', description='预留实例券可以同时匹配的实例规格。N的取值范围：1~100

- 可用区级别预留实例券能够匹配的实例规格族包括：c6、g6、r6、c5、g5、r5、hfc5、hfg5、ic5、se1ne、sn1ne、sn2ne、i2、t5、t6

- 地域级别预留实例券能够匹配的实例规格族包括：c6、g6、r6、c5、g5、r5、hfc5、hfg5、ic5、se1ne、sn1ne、sn2ne、i2'),
      instanceAmount?: int32(name='InstanceAmount', description='预留实例券可以同时匹配同规格按量付费实例的数量。取值范围：大于等于1。N的取值范围：1~100'),
    }
  ](name='Configuration', position='Query'),
  reservedInstanceId?: [ string ](name='ReservedInstanceId', description='The ID of the reserved instance. Valid values of N: 1 to 20.', position='Query'),
  regionId?: string(name='RegionId', description='The ID of the region to which the reserved instance belongs.

You can call [DescribeRegions](~~ 25609 ~~) to view the latest region list.', position='Query'),
}

model ModifyReservedInstancesResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.'),
  reservedInstanceIdSets?: {
    reservedInstanceId?: [ string ](name='ReservedInstanceId')
  }(name='ReservedInstanceIdSets'),
}

model ModifyReservedInstancesResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyReservedInstancesResponseBody(name='body'),
}

/**
 * ## Description

Note the following when you change Reserved instances:

-You can change the zone. You can change the region and zone. However, you cannot change the region.

-You can change the instance size, but you cannot change the instance type family.

-When merging Reserved instances, if the original ris are regional Reserved instances, they must be in the same region. If the original ris are regional Reserved instances, they must be in the same zone.

-When you merge Reserved instances, the expiration date of the original ris must be the same.

-After the Reserved Instances are split, merged, or adjusted, the status of the original instances becomes invalid.

-Burstable instances t5 and t6 only support zone-Level Reserved instances, but do not support regional Reserved Instances, and do not support merging, splitting, or range adjustment of Reserved Instances.
 */
async function modifyReservedInstances(request: ModifyReservedInstancesRequest): ModifyReservedInstancesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyReservedInstances', 'POST', 'undefined', 'json', false, 'none', request);
}

model CancelAutoSnapshotPolicyRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  regionId?: string(name='regionId', description='The ID of the region where the automatic snapshot policy and disk are located. You can call [DescribeRegions](~~ 25609 ~~) to view the latest region list.', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='The account name of the resource master account.', position='Query'),
  ownerId?: long(name='OwnerId', description='The ID of the RAM user.', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', description='The ID of the resource master account, that is, the UID.', position='Query'),
  diskIds?: string(name='diskIds', description='The ID of the target disk. If you want to cancel the automatic snapshot policy for multiple disks, use the same format as "d-xxxxxxxxx", "d-yyyyyyyyy",... The JSON Array of "d-zzzzzzzzz" indicates that the disk IDs are separated by commas (,).', position='Query'),
}

model CancelAutoSnapshotPolicyResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.'),
}

model CancelAutoSnapshotPolicyResponse = {
  headers: map[string]string(name='headers'),
  body: CancelAutoSnapshotPolicyResponseBody(name='body'),
}

async function cancelAutoSnapshotPolicy(request: CancelAutoSnapshotPolicyRequest): CancelAutoSnapshotPolicyResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CancelAutoSnapshotPolicy', 'POST', 'undefined', 'json', false, 'none', request);
}

model DeleteNetworkInterfaceRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', description='The ID of the resource master account, that is, the UID.', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='The account name of the resource master account.', position='Query'),
  ownerId?: long(name='OwnerId', description='The ID of the RAM user.', position='Query'),
  regionId?: string(name='RegionId', description='The region ID. You can call [DescribeRegions](~~ 25609 ~~) to view the latest region list.', position='Query'),
  networkInterfaceId?: string(name='NetworkInterfaceId', description='The ID of the Eni.', position='Query'),
}

model DeleteNetworkInterfaceResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.'),
}

model DeleteNetworkInterfaceResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteNetworkInterfaceResponseBody(name='body'),
}

/**
 * ## Description

-The Eni must be in the Available state.

-If an Eni is attached to an ECS instance, you must detach the Eni from the instance ([DetachNetworkInterface](~~ 58514 ~~) before deleting the Eni.

-After the Eni is deleted:

-The primary private IP address (PrimaryIpAddress) of the Eni is automatically released.

-The deleted Eni exits all security groups.
 */
async function deleteNetworkInterface(request: DeleteNetworkInterfaceRequest): DeleteNetworkInterfaceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteNetworkInterface', 'POST', 'undefined', 'json', false, 'none', request);
}

model CreateDedicatedBlockStorageClusterRequest {
  fromApp?: string(name='FromApp', position='Query'),
  category?: string(name='Category', description='The type of cloud disk that can be created in the exclusive block storage cluster.

The value can only be cloud_essd, that is, ESSD.', position='Query'),
  zoneId?: string(name='ZoneId', description='The ID of the zone to which the cluster belongs. You can call [DescribeZones](~~ 25610 ~~) to obtain the list of zones.', position='Query'),
  dedicatedBlockStorageClusterName?: string(name='DedicatedBlockStorageClusterName', description='The name of the dedicated block storage cluster.', position='Query'),
  capacity?: int32(name='Capacity', description='The capacity of the dedicated cluster. Valid values: 60 to 2304. Unit: TiB.', position='Query'),
  description?: string(name='Description', description='The description of the dedicated block storage cluster.', position='Query'),
  type?: string(name='Type', description='The performance type of the cluster. Valid values:

-Standard: Basic. ESSD PL0 disks can be created in exclusive block storage clusters of this type.
-Premium: performance type. ESSD PL1 cloud disks can be created in exclusive block storage clusters of this type.

Default value: Premium', position='Query'),
  period?: int32(name='Period', description='The duration of the cluster to be purchased. Unit: "__Dune. Valid values:

-When "PeriodUnit = Year", the value range of this parameter is {"1", "2", "3", "4"}.

-When "PeriodUnit = Month", the value range of this parameter is {"6", "7", "8", "9", "10", "11"}.

> Exclusive block storage clusters only support the subscription billing method. Therefore, you must set the **and** duncles parameters.', position='Query'),
  clientToken?: string(name='ClientToken', description='Ensure the idempotence of the request. Generate a parameter value from your client. Make sure that the value is unique among different requests.

"ClientToken" only supports ASCII characters and cannot exceed 64 characters in length. For more information, see [how to ensure idempotence](~~ 25693 ~~).', position='Query'),
  regionId?: string(name='RegionId', description='Clusters belong geo ID. You can call [DescribeRegions](~~ 25609 ~~) to view the latest region list.', position='Query'),
  periodUnit?: string(name='PeriodUnit', description='The duration of the cluster. Unit. Valid values:

-Year: Year

-Month: Month

> Exclusive block storage clusters only support the subscription billing method. Therefore, you must set the **and** duncles parameters.', position='Query'),
}

model CreateDedicatedBlockStorageClusterResponseBody = {
  dedicatedBlockStorageClusterOrderId?: string(name='DedicatedBlockStorageClusterOrderId', description='The ID of the order.'),
  requestId?: string(name='RequestId', description='The ID of the request.'),
  dedicatedBlockStorageClusterId?: string(name='DedicatedBlockStorageClusterId', description='The ID of the dedicated block storage cluster.'),
}

model CreateDedicatedBlockStorageClusterResponse = {
  headers: map[string]string(name='headers'),
  body: CreateDedicatedBlockStorageClusterResponseBody(name='body'),
}

/**
 * ## API description

> The exclusive block storage cluster feature currently supports the China South 2 (Heyuan), Indonesia (Jakarta), and China South 1 (Shenzhen) regions of the financial cloud.

Exclusive Block Storage Cluster (Dedicated Block Storage Cluster) is a Block Storage service that is physically isolated from other public Block Storage clusters and the owner can exclusively enjoy the entire Cluster resources. For more information, see [what is exclusive block storage cluster](~~ 208883 ~~).

Disks created in the exclusive block storage cluster can only be attached to ECS instances in the same zone. Before creating an exclusive block storage cluster, you must plan the region and zone to which the resource belongs.

 */
async function createDedicatedBlockStorageCluster(request: CreateDedicatedBlockStorageClusterRequest): CreateDedicatedBlockStorageClusterResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateDedicatedBlockStorageCluster', 'POST', 'undefined', 'json', false, 'none', request);
}

model ConnectRouterInterfaceRequest {
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  routerInterfaceId?: string(name='RouterInterfaceId', position='Query'),
}

model ConnectRouterInterfaceResponseBody = {
  requestId?: string(name='RequestId'),
}

model ConnectRouterInterfaceResponse = {
  headers: map[string]string(name='headers'),
  body: ConnectRouterInterfaceResponseBody(name='body'),
}

async function connectRouterInterface(request: ConnectRouterInterfaceRequest): ConnectRouterInterfaceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ConnectRouterInterface', 'POST', 'undefined', 'json', false, 'none', request);
}

model ModifyMaintenancePropertyRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  startTime?: string(name='StartTime', position='Query'),
  endTime?: string(name='EndTime', position='Query'),
  actionOnMaintenance?: string(name='ActionOnMaintenance', position='Query'),
  instanceId?: [ string ](name='InstanceId', position='Query'),
}

model ModifyMaintenancePropertyResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyMaintenancePropertyResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyMaintenancePropertyResponseBody(name='body'),
}

async function modifyMaintenanceProperty(request: ModifyMaintenancePropertyRequest): ModifyMaintenancePropertyResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyMaintenanceProperty', 'POST', 'undefined', 'json', false, 'none', request);
}

model CreateSimulatedSystemEventsRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='The account name of the resource master account.', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', description='The ID of the resource master account, that is, the UID.', position='Query'),
  regionId?: string(name='RegionId', description='The ID of the region. You can call [DescribeRegions](~~ 25609 ~~) to view the latest region list.', position='Query'),
  ownerId?: long(name='OwnerId', description='The ID of the RAM user.', position='Query'),
  instanceId?: [ string ](name='InstanceId', description='The ID of one or more ECS instances. Valid values of N: 1 to 100. Multiple values are in the form of duplicate lists.', position='Query'),
  notBefore?: string(name='NotBefore', description='The start time of the scheduled event execution. The time follows the [ISO8601](~~ 25696 ~~) standard and uses UTC +0. The format is yyyy-MM-ddTHH:mm:ssZ.

> for abnormal events caused by system errors or instance errors, after the event is created, the event is in the "Executing" state. In this case, the "NotBefore" parameter indicates that the event enters the "Executed" state. The time of the status.', position='Query'),
  eventType?: string(name='EventType', description='The type of the system event. Valid values:
-SystemMaintenance.Reboot: The instance is restarted due to system maintenance.
-SystemFailure.Reboot: The instance is restarted due to a system error.
-InstanceFailure.Reboot: The instance is restarted due to an instance error.
-SystemMaintenance.Stop: the instance is stopped due to system maintenance.
-SystemMaintenance.Redeploy: the instance is redeployed due to system maintenance.
-SystemFailure.Redeploy: the instance is redeployed due to a system error.
-SystemFailure.Stop: the instance is stopped again due to a system error.
-InstanceFailure.Reboot: The instance is restarted due to an instance error.', position='Query'),
}

model CreateSimulatedSystemEventsResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.'),
  eventIdSet?: {
    eventId?: [ string ](name='EventId')
  }(name='EventIdSet'),
}

model CreateSimulatedSystemEventsResponse = {
  headers: map[string]string(name='headers'),
  body: CreateSimulatedSystemEventsResponseBody(name='body'),
}

/**
 * ## API description

After an event is scheduled, you can view the scheduled event in the ECS console, [ECS API](~~ 63962 ~~), and cloudmonitor.

The following table describes the lifecycle of simulated system events:

-Scheduled (planning): After an appointment, the simulated system event automatically switches to the Scheduled state.
-Executed (completed): the simulated system event automatically changes to NotBefore at a specified point in time (Executed) without human intervention.
-Canceled (Canceled): After you call [CancelSimulatedSystemEvents](~~ 88808 ~~) to cancel a simulated system event, it becomes Canceled.
-Avoided (Avoided): for instance restart due to system maintenance (SystemMaintenance.Reboot) simulates system events and changes to the Avoided state by [restarting the instance](~~ 25502 ~~) before the specified time point.
 */
async function createSimulatedSystemEvents(request: CreateSimulatedSystemEventsRequest): CreateSimulatedSystemEventsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateSimulatedSystemEvents', 'POST', 'undefined', 'json', false, 'none', request);
}

model CancelTaskRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  ownerId?: long(name='OwnerId', description='The ID of the RAM user.', position='Query'),
  taskId?: string(name='TaskId', description='The ID of the task. You can call [DescribeTasks](~~ 25622 ~~) to view the task ID list.', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', description='The ID of the resource master account, that is, the UID.', position='Query'),
  regionId?: string(name='RegionId', description='The ID of the region. You can call [DescribeRegions](~~ 25609 ~~) to view the latest region list.', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='The account name of the resource master account.', position='Query'),
}

model CancelTaskResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.'),
}

model CancelTaskResponse = {
  headers: map[string]string(name='headers'),
  body: CancelTaskResponseBody(name='body'),
}

async function cancelTask(request: CancelTaskRequest): CancelTaskResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CancelTask', 'POST', 'undefined', 'json', false, 'none', request);
}

model RedeployInstanceRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='The account name of the resource master account.', position='Query'),
  ownerId?: long(name='OwnerId', description='The ID of the RAM user.', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', description='The ID of the resource master account, that is, the UID.', position='Query'),
  instanceId?: string(name='InstanceId', description='The ID of the instance that is in the running or stopped state.', position='Query'),
  forceStop?: boolean(name='ForceStop', description='Specifies whether to forcibly stop Running (Running) instances.

Default value: false

> force stop is equivalent to a typical server shutdown, data that has not been written to the storage device in the instance operating system will be lost. We recommend that you redeploy stopped instances.', position='Query'),
}

model RedeployInstanceResponseBody = {
  taskId?: string(name='TaskId', description='The ID of the redeployment task.

You can call the [DescribeTasks](~~ 25622 ~~) operation to query the migration results.
'),
  requestId?: string(name='RequestId', description='The ID of the request.'),
}

model RedeployInstanceResponse = {
  headers: map[string]string(name='headers'),
  body: RedeployInstanceResponseBody(name='body'),
}

/**
 * ## API description

RedeployInstance an Asynchronous call, the instance is restarted and migrated. After the instance is redeployed, the instance enters the running ("Running") state. When the redeployment fails, the instance returns to the original physical server and returns to the state before redeployment.

When you call this operation, note that:

-The target instance must be in the running or stopped state. The instance status changes after the API is called:

-The running ("Running") instance enters the stopped ("Stopping") state.

-When the instance is in the stopped ("Stopped") state, it enters the starting ("Starting") state.

-You cannot redeploy instances on dedicated hosts.

-When "OperationLocks" is marked with ""LockReason": "security", the instance cannot be redeployed.

-You cannot respond to simulated events created by CreateSimulatedSystemEvent.

-In the system event process of isolating the local disk, the damaged local disk has been isolated but has not been sent out **restart due to system maintenance plan and reinitialize the damaged disk** event (SystemMaintenance.RebootAndReInitErrorDisk), you can also call RedeployInstance. For more information, see [local disk instance system Event Overview](~~ 107693 ~~).

For more information about the types and status of system events that can be responded to RedeployInstance, see the following table.

| Event name and parameters | Event status |
| --- | --- |
| Instance restart due to system maintenance (SystemMaintenance.Reboot)| Inquiring, Scheduled |
| Instance redeployment due to system maintenance (SystemMaintenance.Redeploy)| Inquiring, Scheduled |
| Restart due to system maintenance and replace the damaged disk (SystemMaintenance.RebootAndIsolateErrorDisk)| Inquiring |
| Restart due to system maintenance and reinitialize the damaged disk (SystemMaintenance.RebootAndReInitErrorDisk)| Inquiring |
| Redeploy an instance due to a system error (SystemFailure.Redeploy)| Inquiring, Scheduled |
| Only ECS instances that use local disks: the instance is restarted due to a system error (SystemFailure.Reboot)| Executing |
| Damaged disk due to system maintenance (SystemMaintenance.IsolateErrorDisk) | Inquiring |
| Reinitialize the damaged disk due to system maintenance (SystemMaintenance.ReInitErrorDisk) | Inquiring |

> redeploy the local disk instance will reinitialize the local disk and the data of the storage device will be cleared.
 */
async function redeployInstance(request: RedeployInstanceRequest): RedeployInstanceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'RedeployInstance', 'POST', 'undefined', 'json', false, 'none', request);
}

model CreateDemandRequest {
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  zoneId?: string(name='ZoneId', description='The ID of the zone to which the reported instance belongs. For more information, see [DescribeZones](~~ 25610 ~~) for a list of zones.

Default value: Null.

', position='Query'),
  demandDescription?: string(name='DemandDescription', description='The description of the report. The description must be 2 to 256 characters in length and cannot start with http:// or https.', position='Query'),
  regionId?: string(name='RegionId', description='The ID of the region to which the instance belongs. You can call [DescribeRegions](~~ 25609 ~~) to view the latest region list.', position='Query'),
  startTime?: string(name='StartTime', description='The earliest purchase time. The time follows the [ISO8601](~~ 25696 ~~) standard and uses UTC +0. The format is yyyy-MM-dd HH:mm:ss.

If the value of seconds (ss) is not 00, it is automatically set to the beginning of the current minute (mm).
The latest purchase time is later than the earliest purchase time.
The time span between morning and evening is generally not allowed to exceed 10 days.', position='Query'),
  instanceType?: string(name='InstanceType', description='The resource type of the reported instance. See [instance type family](~~ 25378 ~~) or call [DescribeInstanceTypes](~~ 25620 ~~) to view the performance data of the target instance type, or see [select configuration](~~ 58291 ~~) learn how to select an instance type.', position='Query'),
  demandName?: string(name='DemandName', description='The name of the report. The description must be 2 to 128 characters in length. It must start with a letter and cannot start with http:// or https. It can contain letters, digits, colons (:), underscores (_), periods (.), and hyphens (-).

Default value: the name of the instance type.', position='Query'),
  amount?: int32(name='Amount', description='The number of required specifications. Valid values: 1 to 100000.', position='Query'),
  periodUnit?: string(name='PeriodUnit', description='The duration of the resource purchase. Valid values:

* Day
* Week
* Month (default)', position='Query'),
  instanceChargeType?: string(name='InstanceChargeType', description='The billing method of the reported instance. Valid values:

* PrePaid: Subscription
* PostPaid (default): Pay-as-you-go', position='Query'),
  clientToken?: string(name='ClientToken', description='Ensure the idempotence of the request. Generate a parameter value from your client. Make sure that the value is unique among different requests. "ClientToken" only supports ASCII characters and cannot exceed 64 characters in length. For more information, see [how to ensure idempotence](~~ 25693 ~~).', position='Query'),
  endTime?: string(name='EndTime', description='The latest purchase time. The time follows the [ISO8601](~~ 25696 ~~) standard and uses UTC +0. The format is yyyy-MM-dd HH:mm:ss.

If the value of seconds (ss) is not 00, it is automatically set to the beginning of the current minute (mm).
The latest purchase time is later than the earliest purchase time.
The length of time in the morning and evening cannot exceed 10 days.
', position='Query'),
  period?: int32(name='Period', description='The duration of the resource to be purchased. This parameter is required. Valid values:

* When the PeriodUnit is Day, the value of Period is {"1", "2", "3", "4", "5", "6"}.

* When the PeriodUnit is set to Week, the value of Period is {"1", "2", "3", "4"}.

* When the PeriodUnit is Month, the value of Period is {"1", "2", "3", "4", "5", "6", "7", "8", "9", "12", "24", "36", "48", "60"}', position='Query'),
}

model CreateDemandResponseBody = {
  demandId?: string(name='DemandId', description='The report ID(DemandId).'),
  requestId?: string(name='RequestId', description='The ID of the request.
'),
}

model CreateDemandResponse = {
  headers: map[string]string(name='headers'),
  body: CreateDemandResponseBody(name='body'),
}

/**
 * ## API description

You can call this operation to submit instance type requirements. Alibaba Cloud provides relevant resources based on your requirements.

Only I/O optimized instance types and VPC-connected ECS instances can be reported.

> This API is in use for internal testing and has not been officially launched. We recommend that you do not use this API. Please wait.
 */
async function createDemand(request: CreateDemandRequest): CreateDemandResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateDemand', 'POST', 'undefined', 'json', false, 'none', request);
}

model ModifyVSwitchAttributeRequest {
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  vSwitchId?: string(name='VSwitchId', position='Query'),
  vSwitchName?: string(name='VSwitchName', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  description?: string(name='Description', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
}

model ModifyVSwitchAttributeResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyVSwitchAttributeResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyVSwitchAttributeResponseBody(name='body'),
}

async function modifyVSwitchAttribute(request: ModifyVSwitchAttributeRequest): ModifyVSwitchAttributeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyVSwitchAttribute', 'POST', 'undefined', 'json', false, 'none', request);
}

model ModifyInstanceAttributeRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  recyclable?: boolean(name='Recyclable', position='Query'),
  ownerId?: long(name='OwnerId', description='The ID of the RAM user.', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='The account name of the resource master account.', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', description='The ID of the resource master account, that is, the UID.', position='Query'),
  description?: string(name='Description', description='The description of the instance. The description must be 2 to 256 characters in length and cannot start with http:// or https.

Default value: None', position='Query'),
  password?: string(name='Password', description='The password of the instance. The description must be 8 to 30 characters in length and must contain letters, digits, and special characters. Special symbols can be:

"""
()"~! @%& *-_+ =} [],.?/
"""

The Windows instance cannot start with a slash (/).

> If the "Password" parameter is specified, we recommend that you send requests over HTTPS to avoid password leakage.', position='Query'),
  instanceId?: string(name='InstanceId', description='The ID of the instance.', position='Query'),
  hostName?: string(name='HostName', description='The hostname of the operating system. After you modify the hostname, call the RebootInstance to make the modification take effect.

-Windows Server: the system must be 2 to 15 characters in length and can contain uppercase and lowercase letters, digits, and hyphens (-). It cannot start or end with a hyphen (-). It cannot contain consecutive hyphens (-) or digits.

-Other types of instances (such as Linux): The name must be 2 to 64 characters in length and can contain periods (.). Separate multiple segments. Each segment can contain uppercase and lowercase letters, digits, or hyphens (-), but cannot contain periods (.). Or hyphens (-). It cannot start or end with a dot (.) or a hyphen (-).', position='Query'),
  instanceName?: string(name='InstanceName', description='The name of the instance. The description must be 2 to 128 characters in length. It must start with a letter and cannot start with http:// or https. It can contain numbers, colons (:), underscores (_), and hyphens (-).', position='Query'),
  networkInterfaceQueueNumber?: int32(name='NetworkInterfaceQueueNumber', description='The number of queues for the primary Eni.
', position='Query'),
  creditSpecification?: string(name='CreditSpecification', description='Modify the running mode of a burstable instance. Valid values:

-Standard: Standard mode. For more information about instance performance, see performance constraint mode in [What is burstable instance](~~ 59977 ~~).
-Unlimited: Unlimited Mode. For more information about instance performance, see Unlimited mode in [What is burstable instance](~~ 59977 ~~).

Default value: None', position='Query'),
  deletionProtection?: boolean(name='DeletionProtection', description='The release protection property of the instance, which specifies whether to release the instance through the console or API([DeleteInstance](~~ 25507 ~~)).

Default value: None

> This attribute applies only to pay-as-you-go instances and can only restrict manual release operations. This attribute does not take effect for system release operations.', position='Query'),
  userData?: string(name='UserData', description='The user data of the instance, which must be base64-encoded.

Before encoding, the raw data cannot exceed 16kB. We recommend that you do not pass sensitive information in plaintext, such as passwords and private keys. If sensitive information is required, we recommend that you encrypt it before passing it in Base64 encoding, and decrypt it in the same way inside the instance.', position='Query'),
  securityGroupIds?: [ string ](name='SecurityGroupIds', description='The list of security groups to which the instance is added.

-The security group ID must be unique.
-The instance will leave the current security group. To retain the settings, you must add the current security group ID to the list.
-You can change the security group type. However, the security group list cannot contain both basic and enterprise security groups.
-The security group and the instance must belong to the same VPC.
The value range of-N depends on the number of security groups that the instance can join. For more information, see [limits](~~ 25412#SecurityGroupQuota1 ~~) security groups.
-After the security group is modified, it will soon take effect on the corresponding instance, but there may be a small delay.', position='Query'),
}

model ModifyInstanceAttributeResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.'),
}

model ModifyInstanceAttributeResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyInstanceAttributeResponseBody(name='body'),
}

/**
 * ## API description

When querying ECS instance information, if the returned data contains "{"OperationLocks": {"LockReason" : "security"}}", all operations are prohibited.

When you call this operation, note that:

-Modify the hostname ("HostName"): After the instance is restarted, the modification takes effect and must be [restarted in the ECS console](~~ 25440 ~~) or call the API [RebootInstance](~~ 25502 ~~). Restart the new hostname to take effect. A restart within the operating system does not take effect.

-Reset the password ("Password"):

-The instance status cannot be **starting**("Starting").

-After the instance is restarted, the reset takes effect. The new password takes effect only after the instance is restarted from [restart in the ECS console](~~ 25440 ~~) or by calling the API [RebootInstance](~~ 25502 ~~). A restart within the operating system does not take effect.

-Modify custom data ("UserData"):

-The instance status must be **stopped**("Stopped").

-The instance must meet the custom data usage limits. For more information, see [generate instance Custom Data](~~ 49121 ~~).

-Replace the instance Security Group ("SecurityGroupIds....):

-You can change the security group type.

When an ECS instance switches between different types of security groups, you must fully understand the differences between the two security group rules to avoid affecting the network of the instance.

-Classic network instances are not supported.

For more information, see the parameter description of "SecurityGroupIds.

-Modify the number of primary Nic queues ("networkinterfacequeuenumerber"):

-The instance must be in the stopped ("Stopped") state.

-The maximum number of queues per Nic allowed by the instance type.

-The number of accumulated queues for all NICs of an instance cannot exceed the total number of queues allowed by the instance type. You can call the [DescribeInstanceTypes](~~ 25620 ~~) operation to query the maximum number of queues and total quotas of an Eni.

-If the value is -1, the number of active Nic queues is reset to the default value of the corresponding instance type. You can call the [DescribeInstanceTypes](~~ 25620 ~~) operation to query the "primaryeniqueuenumerber" field for the default number of Enis of the instance type.
 */
async function modifyInstanceAttribute(request: ModifyInstanceAttributeRequest): ModifyInstanceAttributeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyInstanceAttribute', 'POST', 'undefined', 'json', false, 'none', request);
}

model DescribeSecurityGroupsRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  isQueryEcsCount?: boolean(name='IsQueryEcsCount', position='Query'),
  fuzzyQuery?: boolean(name='FuzzyQuery', position='Query'),
  tag?: [ 
    {
      key?: string(name='key', description='安全组的标签键。

> 为提高兼容性，建议您尽量使用Tag.N.Key参数。'),
      value?: string(name='Value', description='安全组的标签值。N的取值范围：1~20'),
    }
  ](name='Tag', position='Query'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group to which the security group belongs. When you use this parameter to filter resources, the number of resources cannot exceed 1,000.', position='Query'),
  securityGroupIds?: string(name='SecurityGroupIds', description='The list of security group IDs. You can specify a maximum of 100 security group IDs at a time. Separate the IDs with commas (,). The format is a JSON Array.', position='Query'),
  regionId?: string(name='RegionId', description='The ID of the region. You can call [DescribeRegions](~~ 25609 ~~) to view the latest region list.', position='Query'),
  maxResults?: int32(name='MaxResults', description='The maximum number of entries to return on each page. Maximum Value: 100

Default value: 10', position='Query'),
  securityGroupType?: string(name='SecurityGroupType', description='The type of the security group. Valid values:
-normal: normal security group
-enterprise: enterprise Security Group
> If you do not specify this parameter, all types of security groups are queried.', position='Query'),
  securityGroupId?: string(name='SecurityGroupId', description='The ID of the security group.', position='Query'),
  nextToken?: string(name='NextToken', description='Query the credential (Token). The value of this parameter is the NextToken value returned by the last call to the API. You do not need to set this parameter when you call the API for the first time.', position='Query'),
  vpcId?: string(name='VpcId', description='The ID of the VPC to which the security group belongs.', position='Query'),
  networkType?: string(name='NetworkType', description='The network type of the security group. Valid values:

-vpc
-classic', position='Query'),
  dryRun?: boolean(name='DryRun', description='Specifies whether to PreCheck only this request. Valid values:

-true: sends a check request without querying the resource status. Check whether the AccessKey is valid, whether the RAM user is authorized, and whether required parameters are specified. If the check fails, the corresponding error is returned. If the check succeeds, an error code DryRunOperation is returned.
-false: a normal request is sent. After the request passes the check, the 2XX HTTP status code is returned and the resource status is directly queried.

Default value: false', position='Query'),
  pageSize?: int32(name='PageSize', description='The number of entries to return on each page.

Maximum Value: 50

Default value: 10

> This parameter is about to be offline. We recommend that you use the NextToken and MaxResults to complete the paging query.', position='Query'),
  pageNumber?: int32(name='PageNumber', description='The page number of the security group list.

Start value: 1

Default value: 1.

> This parameter is about to be offline. We recommend that you use the NextToken and MaxResults to complete the paging query.', position='Query'),
  securityGroupName?: string(name='SecurityGroupName', description='The name of the security group.', position='Query'),
}

model DescribeSecurityGroupsResponseBody = {
  pageSize?: int32(name='PageSize', description='The number of rows per page.

> This parameter is about to be offline. We recommend that you use the NextToken and MaxResults to complete the paging query.'),
  pageNumber?: int32(name='PageNumber', description='The current page number.

> This parameter is about to be offline. We recommend that you use the NextToken and MaxResults to complete the paging query.'),
  requestId?: string(name='RequestId', description='The ID of the request.'),
  totalCount?: int32(name='TotalCount', description='The total number of security groups.'),
  regionId?: string(name='RegionId', description='The ID of the region to which the security group belongs.'),
  securityGroups?: {
    securityGroup?: [ 
    {
      creationTime?: string(name='CreationTime', description='The creation time. The time follows the [ISO8601](~~ 25696 ~~) standard and uses UTC time. The format is yyyy-MM-ddThh:mmZ.'),
      vpcId?: string(name='VpcId', description='The VPC to which the security group belongs.'),
      serviceManaged?: boolean(name='ServiceManaged', description='Whether the owner of the security group is a cloud product or virtual business.'),
      description?: string(name='Description', description='The description of the security group.'),
      securityGroupId?: string(name='SecurityGroupId', description='The ID of the security group.'),
      resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group to which the security group belongs.'),
      securityGroupName?: string(name='SecurityGroupName', description='The name of the security group.'),
      ecsCount?: int32(name='EcsCount', description='> This parameter is being invited for testing and is not currently available.'),
      serviceID?: long(name='ServiceID', description='The ID of the virtual merchant corresponding to the security group.'),
      securityGroupType?: string(name='SecurityGroupType', description='The type of the security group. Possible values:

-normal: normal security group
-enterprise: enterprise Security Group'),
      availableInstanceAmount?: int32(name='AvailableInstanceAmount', description='> This parameter is being invited for testing and is not currently available.'),
      tags?: {
        tag?: [ 
        {
          tagValue?: string(name='TagValue', description='The tag value of the security group.'),
          tagKey?: string(name='TagKey', description='The tag key of the security group.'),
        }
      ](name='Tag')
      }(name='Tags', description='The tag of the security group.'),
    }
  ](name='SecurityGroup')
  }(name='SecurityGroups', description='The collection of security group information.'),
  nextToken?: string(name='NextToken', description='The Token returned by this call. If you use MaxResults or NextToken to query data by page and the return value is empty, no more data is returned.'),
}

model DescribeSecurityGroupsResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeSecurityGroupsResponseBody(name='body'),
}

/**
 * 
## API description

Before calling an API, note the following:

-The basic information of a security group includes the security group ID and security group description. The returned parameters are sorted in descending order by security group ID.

-We recommend that you use the MaxResults and NextToken parameters to query data by page. Note: When querying the homepage by page, you only need to set the MaxResults to limit the number of entries returned. The NextToken in the returned results are used as the credentials for querying subsequent pages. When querying subsequent pages, set the NextToken parameter to the NextToken obtained from the last returned result as the query credential, and set the MaxResults to limit the number of returned entries. If the NextToken in the returned result is empty, the page is the last page and no subsequent pages exist.

-When calling an API through Alibaba Cloud CLI, the request parameter values of different data types must comply with certain format requirements. For more information, see [CLI parameter format description](~~ 110340 ~~).
 */
async function describeSecurityGroups(request: DescribeSecurityGroupsRequest): DescribeSecurityGroupsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeSecurityGroups', 'POST', 'undefined', 'json', false, 'none', request);
}

model ResizeDiskRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', description='The ID of the RAM user.', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', description='The ID of the resource master account, that is, the UID.', position='Query'),
  type?: string(name='Type', description='How to resize a cloud disk. Valid values:

-offline (default): scale out offline. After resizing, you must [restart the instance](~~ 25440 ~~) in the console or call the API [RebootInstance](~~ 25502 ~~) to make the operation take effect.

-online: scale out online without restarting the instance. You can use ultra disks, standard SSDs, and enhanced SSDs.', position='Query'),
  diskId?: string(name='DiskId', description='The ID of the disk.', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='The account name of the resource master account.', position='Query'),
  clientToken?: string(name='ClientToken', description='Ensure the idempotence of the request. Generate a parameter value from your client. Make sure that the value is unique among different requests. **ClientToken** supports only ASCII characters and cannot exceed 64 characters. For more information, see [how to ensure idempotence](~~ 25693 ~~).', position='Query'),
  newSize?: int32(name='NewSize', description='The size of the disk you want to resize. The unit is GiB. Valid values:

-Ultra disk (cloud_efficiency):20 to 32768
-SSD cloud disk (cloud_ssd):20 to 32768
-Enhanced SSDs (cloud_essd):20 to 32768
-Basic cloud: 5 to 2000

The capacity of the new disk must be larger than that of the original disk.', position='Query'),
}

model ResizeDiskResponseBody = {
  orderId?: string(name='OrderId', description='The ID of the generated order.

> The Order ID is returned only when the disk is resized.'),
  requestId?: string(name='RequestId', description='The ID of the request.'),
}

model ResizeDiskResponse = {
  headers: map[string]string(name='headers'),
  body: ResizeDiskResponseBody(name='body'),
}

/**
 * ## API description

> before resizing, be sure to query the partition format used by the cloud disk. If the MBR format is used, it cannot be scaled up to more than 2TiB. Otherwise, data will be lost. For MBR partition expansion, we recommend that you recreate and mount a data disk in GPT partition format before copying the existing data to the new data disk. For more information, see [resize disk capacity](~~ 44986 ~~).

-The types of cloud disks that can be resized include basic cloud disks ("cloud"), ultra cloud disks ("cloud_efficiency "), SSD cloud disks ("cloud_ssd"), and ESSD("cloud_essd").

-You cannot scale out a disk when it is creating a snapshot.

-The status of the instance attached to the disk must be **running**("Running") or **stopped**("Stopped").

-When resizing, the disk partitions and file systems are not modified. You need to allocate your own storage space after resizing.

-<props = "china"> disks with multiple mount features can only be scaled out offline. Before resizing, you must ensure that all instances attached are in the **stopped**("Stopped") status. </props>

 */
async function resizeDisk(request: ResizeDiskRequest): ResizeDiskResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ResizeDisk', 'POST', 'undefined', 'json', false, 'none', request);
}

model ModifyDedicatedHostAttributeRequest {
  networkAttributes?: {
    udpTimeout?: int32(name='UdpTimeout', description='Set the UDP session timeout period for user access for cloud services running on the DDH. Unit: seconds. Valid values: 15 to 310', position=''),
    slbUdpTimeout?: int32(name='SlbUdpTimeout', description='The UDP session timeout period of the SLB connection. Unit: seconds. Valid values: 15 to 310', position=''),
  }(name='NetworkAttributes'),
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  regionId?: string(name='RegionId', description='The ID of the region to which the dedicated host belongs. You can call [DescribeRegions](~~ 25609 ~~) to view the latest region list.', position='Query'),
  dedicatedHostName?: string(name='DedicatedHostName', description='The name of the dedicated host. The description must be 2 to 128 characters in length. It must start with a letter and cannot start with http:// or https. It can contain numbers, colons (:), underscores (_), and hyphens (-).', position='Query'),
  dedicatedHostId?: string(name='DedicatedHostId', description='The ID of the dedicated host.', position='Query'),
  autoPlacement?: string(name='AutoPlacement', description='Specifies whether the dedicated host is added to the automatic deployment resource pool. When you create an instance on a DDH without specifying **DedicatedHostId**, Alibaba Cloud automatically selects a DDH from the resource pool to place the instance. Valid values:

-on: added to the automatic deployment resource pool.

-off: does not join the automatic deployment resource pool.

For more information, see [features](~~ 118938 ~~).', position='Query'),
  cpuOverCommitRatio?: float(name='CpuOverCommitRatio', description='CPU oversold ratio. You can set the CPU oversell ratio only for g6s, c6s, and r6s specifications. Valid values: 1 to 5.

CPU oversold ratio affects the number of available VCPUs of a DDH. The number of available vCPUs of a DDH = number of physical CPU cores * 2* CPU oversold ratio. For example, the number of physical CPU cores of g6s is 52. If the CPU oversell ratio is set to 4, the total number of VCPUs after modification is 416. For scenarios where the absolute stability of CPU is not strict or the CPU load is not high, for example, in the development and testing environment, increasing the overselling ratio can increase the number of available vCPU to deploy more ECS instances of the same specification, reduce unit deployment costs.

', position='Query'),
  description?: string(name='Description', description='The description of the dedicated host. The description must be 2 to 256 characters in length and cannot start with http:// or https.', position='Query'),
  dedicatedHostClusterId?: string(name='DedicatedHostClusterId', description='The ID of the DDH cluster.', position='Query'),
  actionOnMaintenance?: string(name='ActionOnMaintenance', description='When a dedicated host fails or is repaired online, you can configure a migration solution for the host. Valid values:

-Migrate: Migrate the instance to another physical machine and restart the instance.

-Stop: Stop the instance on the current DDH. After confirming that the DDH cannot be repaired, migrate the instance to another physical machine and restart the instance.

If a cloud disk is attached to a dedicated host, the default value is Migrate.

If a local disk is mounted on a dedicated host, the default value is Stop.', position='Query'),
}

model ModifyDedicatedHostAttributeResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.'),
}

model ModifyDedicatedHostAttributeResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyDedicatedHostAttributeResponseBody(name='body'),
}

/**
 * ## API description

-When you modify the CPU oversell ratio, the ECS instance on the DDH must be in the stopped ("Stopped") state.
-Modifying the CPU oversell ratio does not affect the running status of the DDH. However, note that the number of VCPUs allocated to the DDH cannot exceed the modified total number of VCPUs, otherwise, excessive ECS instances cannot be started.
 */
async function modifyDedicatedHostAttribute(request: ModifyDedicatedHostAttributeRequest): ModifyDedicatedHostAttributeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyDedicatedHostAttribute', 'POST', 'undefined', 'json', false, 'none', request);
}

model DescribeCapacityReservationInstancesRequest {
  privatePoolOptions?: {
    id?: string(name='Id', description='The ID of the subscription service.', position=''),
  }(name='PrivatePoolOptions'),
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  packageType?: string(name='PackageType', position='Query'),
  maxResults?: int32(name='MaxResults', description='The number of entries to return on each page.

Maximum Value: 100

Default value: 10', position='Query'),
  regionId?: string(name='RegionId', description='The ID of the region to which the capacity reservation service belongs. You can call [DescribeRegions](~~ 25609 ~~) to view the latest region list.', position='Query'),
  nextToken?: string(name='NextToken', description='The start flag of the capacity reservation service query. This parameter is obtained from the last request.', position='Query'),
}

model DescribeCapacityReservationInstancesResponseBody = {
  nextToken?: string(name='NextToken', description='The start flag of the next query in the capacity reservation service.'),
  requestId?: string(name='RequestId', description='The ID of the request.'),
  totalCount?: int32(name='TotalCount', description='The number of records that meet the query criteria.'),
  maxResults?: int32(name='MaxResults', description='The number of rows displayed on each page of the capacity reservation service.'),
  capacityReservationItem?: {
    instanceIdSet?: [ 
    {
      instanceId?: string(name='InstanceId', description='The ID of the instance.'),
    }
  ](name='InstanceIdSet')
  }(name='CapacityReservationItem', description='The list of instances that have been matched by the capacity reservation service.'),
}

model DescribeCapacityReservationInstancesResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeCapacityReservationInstancesResponseBody(name='body'),
}

async function describeCapacityReservationInstances(request: DescribeCapacityReservationInstancesRequest): DescribeCapacityReservationInstancesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeCapacityReservationInstances', 'POST', 'undefined', 'json', false, 'none', request);
}

model ModifyFleetRequest {
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  fleetId?: string(name='FleetId', position='Query'),
  excessCapacityTerminationPolicy?: string(name='ExcessCapacityTerminationPolicy', position='Query'),
  defaultTargetCapacityType?: string(name='DefaultTargetCapacityType', position='Query'),
  terminateInstancesWithExpiration?: boolean(name='TerminateInstancesWithExpiration', position='Query'),
  maxSpotPrice?: float(name='MaxSpotPrice', position='Query'),
  totalTargetCapacity?: string(name='TotalTargetCapacity', position='Query'),
  onDemandTargetCapacity?: string(name='OnDemandTargetCapacity', position='Query'),
  spotTargetCapacity?: string(name='SpotTargetCapacity', position='Query'),
}

model ModifyFleetResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyFleetResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyFleetResponseBody(name='body'),
}

async function modifyFleet(request: ModifyFleetRequest): ModifyFleetResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyFleet', 'POST', 'undefined', 'json', false, 'none', request);
}

model AttachKeyPairRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  instanceIds?: string(name='InstanceIds', description='The ID of the instance to which the SSH key pair is bound. The value can be a JSON Array consisting of multiple instance IDs. A maximum of 50 IDs can be entered. Separate IDs with commas (,).', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='The account name of the resource master account.', position='Query'),
  regionId?: string(name='RegionId', description='The region ID of the SSH key pair. You can call [DescribeRegions](~~ 25609 ~~) to view the latest region list.', position='Query'),
  keyPairName?: string(name='KeyPairName', description='The name of the SSH key pair.', position='Query'),
  ownerId?: long(name='OwnerId', description='The ID of the RAM user.', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', description='The ID of the resource master account, that is, the UID.', position='Query'),
}

model AttachKeyPairResponseBody = {
  keyPairName?: string(name='KeyPairName', description='The name of the key pair.'),
  requestId?: string(name='RequestId', description='The ID of the request.'),
  totalCount?: string(name='TotalCount', description='The total number of instances associated with key pairs.'),
  failCount?: string(name='FailCount', description='The number of instances that failed to bind the key pair.'),
  results?: {
    result?: [ 
    {
      code?: string(name='Code', description='The operation status code. A value of 200 indicates that the operation is successful.'),
      message?: string(name='Message', description='The operation information passed. When code = 200, the message is successful.'),
      instanceId?: string(name='InstanceId', description='The ID of the instance.'),
      success?: string(name='Success', description='Indicates whether the operation is successful.'),
    }
  ](name='Result')
  }(name='Results', description='The result set of successful or failed key pair binding.'),
}

model AttachKeyPairResponse = {
  headers: map[string]string(name='headers'),
  body: AttachKeyPairResponseBody(name='body'),
}

/**
 * ## API description

When you use this API, note that:

-Windows instance does not support SSH key pairs.
-After you bind an SSH key pair, the authentication method of username and password is disabled.
-If the instance is in the **Running**(Running) state, restart the instance ([RebootInstance](~~ 25502 ~~)) and the SSH key pair takes effect.
-If the instance is in the **Stopped**(Stopped) status, the SSH key pair takes effect after the instance is started ([StartInstance](~~ 25500 ~~).
-If the instance is bound with an SSH key pair, the new SSH key pair automatically replaces the original SSH key pair.
 */
async function attachKeyPair(request: AttachKeyPairRequest): AttachKeyPairResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'AttachKeyPair', 'POST', 'undefined', 'json', false, 'none', request);
}

model DescribeInvocationsRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  commandId?: string(name='CommandId', description='The ID of the command. You can call the [DescribeCommands](~~ 64843 ~~) operation to query all available CommandId.', position='Query'),
  commandType?: string(name='CommandType', description='The type of the command.', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='The account name of the resource master account.', position='Query'),
  ownerId?: long(name='OwnerId', description='The ID of the RAM user.', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', description='The ID of the resource master account, that is, the UID.', position='Query'),
  regionId?: string(name='RegionId', description='The ID of the region. You can call [DescribeRegions](~~ 25609 ~~) to view the latest region list.', position='Query'),
  repeatMode?: string(name='RepeatMode', description='The command execution method. Valid values:

-Once: run the command immediately.
-Period: run the command regularly.
-NextRebootOnly: When the instance starts next time, the command is automatically executed.
-EveryReboot: The command is automatically executed each time the instance is started.

Default value: Null.', position='Query'),
  pageNumber?: long(name='PageNumber', description='The current page number.

Start value: 1

Default value: 1.', position='Query'),
  invokeId?: string(name='InvokeId', description='The ID of the command execution.', position='Query'),
  commandName?: string(name='CommandName', description='The name of the command.', position='Query'),
  pageSize?: long(name='PageSize', description='The number of entries to return on each page.

Maximum Value: 50

Default value: 10', position='Query'),
  instanceId?: string(name='InstanceId', description='The ID of the instance. When you specify this parameter, all command execution records of the instance are queried.', position='Query'),
  includeOutput?: boolean(name='IncludeOutput', description='Indicates whether to return the output information of the command run in the result.

-true: returns. You must specify at least the "InvokeId" or "InstanceId" parameters ".
-false: does not return.

Default value: false', position='Query'),
  contentEncoding?: string(name='ContentEncoding', description='Specifies the encoding method of the "CommandContent" and "Output" fields in the returned data. Valid values:

-PlainText: returns the original command content and output information.
-Base64: returns the base64-encoded command content and output information.

Default value: Base64', position='Query'),
  timed?: boolean(name='Timed', description='Whether the query command will be automatically executed in the future. Valid values:

-true: when the "RunCommand" or "InvokeCommand" command is called, the value of the "RepeatMod" parameter is "1", "n"bootone", or "EveryReboot", and the command is in the uncompleted state or unstopped state.
-false: the command to query the following two statuses:
-When "RunCommand" or "InvokeCommand" is called to execute a command, the value of "RepeatMod" is "Once ".
-Canceled, stopped, or completed commands.

Default value: false', position='Query'),
  invokeStatus?: string(name='InvokeStatus', description='The total invocation status of the command. The total execution status depends on the co-execution status of one or more instances in the execution process. Valid values:

-Running:
-Periodic invocation: the invocation status remains in progress until the periodic invocation command is manually stopped.
-Single execution: Once a command process is in progress, the overall execution status is in progress.
-Finished:
-Periodic execution: the command process cannot be executed.
-Single execution: all instances are executed. Alternatively, you can manually stop the command processes of some instances, and all other instances are executed.
-Failed:
-Periodic execution: the command process cannot fail to be executed.
-Single execution: all instances fail to be executed.
-PartialFailed:
-Periodic execution: the command process cannot be partially failed.
-Single execution: if some instances have failed command execution processes, the total execution status is partially failed.
-Stopped: stop the command.

Default value: Running', position='Query'),
}

model DescribeInvocationsResponseBody = {
  pageSize?: long(name='PageSize', description='The number of rows per page.'),
  requestId?: string(name='RequestId', description='The ID of the request.'),
  pageNumber?: long(name='PageNumber', description='The page number of the query result.'),
  totalCount?: long(name='TotalCount', description='The total number of commands.'),
  invocations?: {
    invocation?: [ 
    {
      creationTime?: string(name='CreationTime', description='The time when the task was created.'),
      frequency?: string(name='Frequency', description='The execution cycle of a periodic command. The value structure of this parameter is based on the [Cron expression](~~ 64769 ~~).'),
      invocationStatus?: string(name='InvocationStatus', description='The total invocation status of the command. The total invocation status depends on the common invocation status of all instances in this call. Valid values:
-Pending: The system is verifying or sending commands. If the command execution status of at least one instance is Pending, the total execution status is Pending.
-Scheduled: the periodically executed command has been sent and is waiting to run. If the command execution status of at least one instance is Scheduled, the total execution status is Scheduled.
-Running: The command is Running on the instance. If the command execution status of at least one instance is Running, the total execution status is Running.
-Success: the command execution status on each instance is Stopped or Success, and the command execution status of at least one instance is Success, the total execution status is Success.
-Run immediately: the command is executed and the exit code is 0.
-Recurring tasks: the last successful execution with the exit code 0 and the specified cycle has been completed.
-Failed: If the command execution status on each instance is Stopped or Failed, the total execution status is Failed. When one or more of the command execution statuses on an instance are in the following status, the return value is Failed:
-Command verification failed (Invalid)
-Command sending failed (Aborted)
-Command execution completed but the exit code is not 0(Failed)
-Command execution Timeout (Timeout)
-Command execution exception (Error)
-Stopping: The task is being stopped. If the command execution status of at least one instance is Stopping, the total execution status is Stopping.
-Stopped: The task is Stopped. If the command execution status of all instances is Stopped, the total execution status is Stopped. When the command execution status on the instance is as follows, the return value is Stopped:
-Task canceled (Cancelled)
-Task Terminated (Terminated)
-PartialFailed: Some instances are executed successfully and some instances fail. If the command execution status of each instance is Success, Failed, or Stopped, the total execution status is PartialFailed.
> "InvokeStatus" in the response parameter has similar meanings to this parameter, but we recommend that you view the return value.
'),
      repeatMode?: string(name='RepeatMode', description='The command execution method. Possible values:

-Once: run the command immediately.
-Period: run the command regularly.
-NextRebootOnly: When the instance starts next time, the command is automatically executed.
-EveryReboot: The command is automatically executed each time the instance is started.'),
      commandId?: string(name='CommandId', description='The ID of the command.'),
      commandType?: string(name='CommandType', description='The type of the command.'),
      invokeStatus?: string(name='InvokeStatus', description='The overall invocation status of the command.
> We do not recommend that you view the return value. We recommend that you view the return value of "InvocationStatus.'),
      parameters?: string(name='Parameters', description='The custom parameters in the command.'),
      timed?: boolean(name='Timed', description='Whether the query command will be automatically executed in the future.'),
      commandContent?: string(name='CommandContent', description='The command content, which is Base64-encoded and then transmitted.'),
      commandName?: string(name='CommandName', description='The name of the command.'),
      invokeId?: string(name='InvokeId', description='The ID of the command execution.'),
      username?: string(name='Username', description='The name of the user who runs the command on the ECS instance.'),
      invokeInstances?: {
        invokeInstance?: [ 
        {
          creationTime?: string(name='CreationTime', description='The start time of the command.'),
          updateTime?: string(name='UpdateTime', description='The time when the command status was updated.'),
          finishTime?: string(name='FinishTime', description='The end time of the command process.'),
          invocationStatus?: string(name='InvocationStatus', description='The command progress status of a single instance. Valid values:
-Pending: The system is verifying or sending commands.
-Invalid: The Specified Command type or parameter is incorrect.
-Aborted: failed to send the command to the instance. The instance must be running and the command can be sent within 1 minute.
-Running: The command is Running on the instance.
-Success:
-Single command: the command is executed and the exit code is 0.
-Run the command periodically: The Last Run succeeds, the exit code is 0, and the specified cycle has ended.
-Failed:
-Single command: the command is executed and the exit code is not 0.
-Run the command periodically: The Last Run succeeds and the exit code is not 0. The specified cycle is aborted.
-Error: An Error occurred while running the command and cannot continue.
-Timeout: the command execution times out.
-Cancelled: the command execution has been canceled and the command has not been started.
-Stopping: The task is being stopped.
-Terminated: The command is Terminated when it is run.
-Scheduled:
-Single-Run command: not applicable and does not appear.
-Periodically run commands: wait to run.'),
          repeats?: int32(name='Repeats', description='The number of times that the command is run on the instance.
-If the execution mode is single execution, the value is 0 or 1.
-If the execution mode is periodic, the value is the number of executions.'),
          instanceId?: string(name='InstanceId', description='The ID of the instance.'),
          output?: string(name='Output', description='The output information of the command.'),
          dropped?: int32(name='Dropped', description='If the text length in the Output field exceeds 24KB, the discarded text length is truncated.'),
          stopTime?: string(name='StopTime', description='If "StopInvocation" is called, it indicates the call time.'),
          exitCode?: long(name='ExitCode', description='The exit code of the command process. Possible values:

-Linux instance is the exit code of the Shell process.
-Windows the exit code of the Bat or PowerShell process.'),
          startTime?: string(name='StartTime', description='The time when the command starts to run in the instance.'),
          errorInfo?: string(name='ErrorInfo', description='The error message returned because the command failed to be issued or failed to be executed. Valid values:
-Null: The Command runs normally.
-the specified instance does not exists: the specified instance does not exist or has been released.
-the instance has released when create task: the instance is released during command execution.
-the instance is not running when create task: the instance is not running when the command is started.
-the command is not applicable: the command does not apply to the specified instance.
-the specified account does not exists: the specified account does not exist.
-the specified directory does not exists: the specified directory does not exist.
-the cron job expression is invalid: the specified periodic expression is invalid.
-the aliyun service is not running on the instance: the cloud assistant client is not running.
-the aliyun service in the instance does not response: the cloud assistant client does not respond.
-the aliyun service in the instance is upgrading now: the cloud assistant client is being upgraded.
-the aliyun service in the instance need upgrade: the cloud assistant client needs to be upgraded.
-the command delivery has been timeout.
-the command execution has been timeout: command execution timed out.
-the command execution got an exception.
-the command execution has been interrupted.
-the command execution exit code is not zero: the command execution ends and the exit code is not zero.
'),
          errorCode?: string(name='ErrorCode', description='The code for the reason why the command fails to be issued or executed. Valid values:
-Null: The Command runs normally.
-InstanceNotExists: the specified instance does not exist or has been released.
-InstanceReleased: the instance is released during command execution.
-InstanceNotRunning: the instance is not running when the command is started.
-CommandNotApplicable: the command does not apply to the specified instance.
-AccountNotExists: the specified account does not exist.
-DirectoryNotExists: the specified directory does not exist.
-BadCronExpression: the specified periodic expression is invalid.
-ClientNotRunning: The cloud assistant client is not running.
-ClientNotResponse: The cloud assistant client does not respond.
-ClientIsUpgrading: The cloud assistant client is being upgraded.
-ClientNeedUpgrade: The cloud assistant client needs to be upgraded.
-DeliveryTimeout: the sending command timed out.
-ExecutionTimeout: the command execution times out.
-ExecutionException: command execution exception occurs.
-ExecutionInterrupted: the command execution task is interrupted.
-ExitCodeNonzero: The command is executed and the exit code is not 0.
'),
          timed?: boolean(name='Timed', description='Whether the query command will be automatically executed in the future.'),
          instanceInvokeStatus?: string(name='InstanceInvokeStatus', description='> We do not recommend that you view the return value. We recommend that you view the return value of "InvocationStatus.'),
        }
      ](name='InvokeInstance')
      }(name='InvokeInstances', description='The type of the target instance set.'),
    }
  ](name='Invocation')
  }(name='Invocations', description='An array of command execution records.'),
}

model DescribeInvocationsResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeInvocationsResponseBody(name='body'),
}

/**
 * ## API description

-After you execute a command, it does not necessarily mean that the command runs successfully and has the expected command effect. You need to view the actual execution result through the return value of the interface, which is subject to the actual output result.

-You can query the execution information of the last two weeks. The maximum number of execution information is 100,000.
 */
async function describeInvocations(request: DescribeInvocationsRequest): DescribeInvocationsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeInvocations', 'POST', 'undefined', 'json', false, 'none', request);
}

model CreateRouterInterfaceRequest {
  regionId?: string(name='RegionId', position='Query'),
  role?: string(name='Role', position='Query'),
  oppositeRegionId?: string(name='OppositeRegionId', position='Query'),
  spec?: string(name='Spec', position='Query'),
  routerType?: string(name='RouterType', position='Query'),
  routerId?: string(name='RouterId', position='Query'),
  oppositeInterfaceId?: string(name='OppositeInterfaceId', position='Query'),
  oppositeRouterId?: string(name='OppositeRouterId', position='Query'),
  oppositeRouterType?: string(name='OppositeRouterType', position='Query'),
  oppositeInterfaceOwnerId?: string(name='OppositeInterfaceOwnerId', position='Query'),
  healthCheckSourceIp?: string(name='HealthCheckSourceIp', position='Query'),
  healthCheckTargetIp?: string(name='HealthCheckTargetIp', position='Query'),
  accessPointId?: string(name='AccessPointId', position='Query'),
  oppositeAccessPointId?: string(name='OppositeAccessPointId', position='Query'),
  description?: string(name='Description', position='Query'),
  name?: string(name='Name', position='Query'),
  period?: int32(name='Period', position='Query'),
  instanceChargeType?: string(name='InstanceChargeType', position='Query'),
  autoPay?: boolean(name='AutoPay', position='Query'),
  pricingCycle?: string(name='PricingCycle', position='Query'),
  clientToken?: string(name='ClientToken', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  userCidr?: string(name='UserCidr', position='Query'),
}

model CreateRouterInterfaceResponseBody = {
  requestId?: string(name='RequestId'),
  orderId?: long(name='OrderId'),
  routerInterfaceId?: string(name='RouterInterfaceId'),
}

model CreateRouterInterfaceResponse = {
  headers: map[string]string(name='headers'),
  body: CreateRouterInterfaceResponseBody(name='body'),
}

async function createRouterInterface(request: CreateRouterInterfaceRequest): CreateRouterInterfaceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateRouterInterface', 'POST', 'undefined', 'json', false, 'none', request);
}

model TagResourcesRequest {
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  tag?: [ 
    {
      key?: string(name='Key', description='资源的标签键。N的取值范围：1~20。一旦传入该值，则不允许为空字符串。最多支持128个字符，不能以`aliyun`和`acs:`开头，不能包含`http://`或者`https://`。'),
      value?: string(name='Value', description='资源的标签值。N的取值范围：1~20。一旦传入该值，可以为空字符串。最多支持128个字符，不能以`acs:`开头，不能包含`http://`或者`https://`。'),
    }
  ](name='Tag', position='Query'),
  regionId?: string(name='RegionId', description='The ID of the region to which the resource belongs. You can call [DescribeRegions](~~ 25609 ~~) to view the latest region list.', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='The account name of the resource master account.', position='Query'),
  ownerId?: long(name='OwnerId', description='The ID of the RAM user.', position='Query'),
  resourceId?: [ string ](name='ResourceId', description='The ID of the resource. Valid values of N: 1 to 50.', position='Query'),
  resourceType?: string(name='ResourceType', description='The definition of the resource type. Valid values:

-instance:ECS instance
-disk: disk
-snapshot: snapshot
-image: image
-securitygroup: Security Group
-volume: storage volume
-eni: eni
-ddh: Dedicated host
-ddhcluster: Dedicated host cluster
-keypair:SSH key pair
-launchtemplate: launch Template
-reservedinstance: Reserved Instance
-snapshotpolicy: automatic snapshot policy
-elasticityassurance: elastic assurance
-capacityreservation: capacity reservation', position='Query'),
}

model TagResourcesResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.'),
}

model TagResourcesResponse = {
  headers: map[string]string(name='headers'),
  body: TagResourcesResponseBody(name='body'),
}

/**
 * ## API description

Before binding tags, Alibaba Cloud verifies the number of existing tags. If the limit is exceeded, an error message is returned. For more information, see [limits](~~ 25412 ~~).
 */
async function tagResources(request: TagResourcesRequest): TagResourcesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'TagResources', 'POST', 'undefined', 'json', false, 'none', request);
}

model CheckDiskEnableAutoSnapshotValidationRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  diskIds?: string(name='DiskIds', position='Query'),
}

model CheckDiskEnableAutoSnapshotValidationResponseBody = {
  requestId?: string(name='RequestId'),
  isPermitted?: string(name='IsPermitted'),
  autoSnapshotOccupation?: int32(name='AutoSnapshotOccupation'),
}

model CheckDiskEnableAutoSnapshotValidationResponse = {
  headers: map[string]string(name='headers'),
  body: CheckDiskEnableAutoSnapshotValidationResponseBody(name='body'),
}

async function checkDiskEnableAutoSnapshotValidation(request: CheckDiskEnableAutoSnapshotValidationRequest): CheckDiskEnableAutoSnapshotValidationResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CheckDiskEnableAutoSnapshotValidation', 'POST', 'undefined', 'json', false, 'none', request);
}

model ModifyLaunchTemplateDefaultVersionRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='The account name of the resource master account.', position='Query'),
  launchTemplateName?: string(name='LaunchTemplateName', description='The name of the launch template. You must specify LaunchTemplateId or LaunchTemplateName to determine the template.', position='Query'),
  regionId?: string(name='RegionId', description='The ID of the region to which the template belongs. You can call [DescribeRegions](~~ 25609 ~~) to view the latest region list.', position='Query'),
  ownerId?: long(name='OwnerId', description='The ID of the RAM user.', position='Query'),
  launchTemplateId?: string(name='LaunchTemplateId', description='The ID of the launch template. You must specify LaunchTemplateId or LaunchTemplateName to determine the template.', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', description='The ID of the resource master account, that is, the UID.', position='Query'),
  defaultVersionNumber?: long(name='DefaultVersionNumber', description='The version number of the launch template that is set to the default version.', position='Query'),
}

model ModifyLaunchTemplateDefaultVersionResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.'),
}

model ModifyLaunchTemplateDefaultVersionResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyLaunchTemplateDefaultVersionResponseBody(name='body'),
}

async function modifyLaunchTemplateDefaultVersion(request: ModifyLaunchTemplateDefaultVersionRequest): ModifyLaunchTemplateDefaultVersionResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyLaunchTemplateDefaultVersion', 'POST', 'undefined', 'json', false, 'none', request);
}

model RunInstancesRequest {
  hibernationOptions?: {
    configured?: boolean(name='Configured', position=''),
  }(name='HibernationOptions'),
  systemDisk?: {
    diskName?: string(name='DiskName', description='System disk name. The description must be 2 to 128 characters in length. It must start with a letter and cannot start with "http:// "or "https. It can contain numbers, periods (.), colons (:), underscores (_), and hyphens (-).

Default value: Null.', position=''),
    description?: string(name='Description', description='The description of the system disk. The description must be 2 to 256 characters in length and cannot start with "http:// "or "https.', position=''),
    size?: string(name='Size', description='The size of the system disk. Unit: GiB. Valid values: 20 to 500.

The value of this parameter must be greater than or equal to max{20, ImageSize}.

Default value: max{40. The size of the image corresponding to the parameter ImageId}.', position=''),
    category?: string(name='Category', description='The type of the system disk. Valid values:

-cloud_efficiency: Ultra disk
-cloud_ssd:SSD cloud disk
-cloud_essd:ESSD
-cloud: basic cloud disk

For phased-out instance types and non-I/O optimized instances, the default value is cloud. Otherwise, the default value is cloud_efficiency.', position=''),
    autoSnapshotPolicyId?: string(name='AutoSnapshotPolicyId', description='The ID of the automatic snapshot policy used by the system disk.', position=''),
    performanceLevel?: string(name='PerformanceLevel', description='When you create an ESSD as a system disk, set the performance level of the disk. Valid values:

-PL0: The maximum random read/write IOPS per disk is 10,000
-PL1 (default): The maximum random read/write IOPS per disk is 50,000.
-PL2: The maximum random read/write IOPS per disk is 100,000
-PL3: The maximum random read/write IOPS per disk is 1 million

For more information about how to select an ESSD performance level, see [ESSD cloud disk](~~ 122389 ~~).', position=''),
  }(name='SystemDisk'),
  securityOptions?: {
    confidentialComputingMode?: string(name='ConfidentialComputingMode', description='The confidential computing mode. Value: Enclave

If this parameter is set to Enclave, the ECS instance uses Enclave to build a confidential computing environment. Currently, only instance type families c7, g7, and R7. you can specify this parameter to use Enclave confidential computing when calling "RunInstances. Note:

-The confidential computing feature is being invited for testing. To use it, open a ticket.

-You can only call the "RunInstances" implementation when creating an ECS instance OpenAPI confidential computing through Enclave. The "CreateInstance" parameter cannot be set to "SecurityOptions. Renewentialcomputingmode.

-Enclave confidential computing is implemented by a trusted system (vTPM). When you specify an ECS instance to use Enclave to build a confidential computing environment, the trusted system is also enabled for the instance. Therefore, call the interface, if you set the "securityoptions. ConfidentialComputingMode = enclavespec, regardless of whether you have set "SecurityOptions.TrustedSystemMode = vTPM", all the created ECS instances use Enclave confidential computing mode and trusted system.

For more information about confidential computing, see [use Enclave to build a confidential Computing Environment](~~ 203433 ~~).

Default value: Null.
', position=''),
    trustedSystemMode?: string(name='TrustedSystemMode', description='The trusted system mode. Set the value to vTPM.

Currently, the trusted system mode supports the following instance type families:
-g7, c7, r7
-Security Enhanced (g7t, c7t, r7t)

This parameter is required when you create an ECS instance of the preceding instance type family. The details are as follows:

-If you are using the Alibaba Cloud trusted system, set this parameter to vTPM. When the instance is started, it can be verified through the Alibaba Cloud trusted system.
-If you do not use the Alibaba Cloud trusted system, you do not need to set this parameter. However, note that if the ECS instance you created uses the Enclave confidential computing mode ("SecurityOptions.ConfidentialComputingMode = enclavespec), the ECS instance also enables the trusted system.
-When you create an ECS instance of a trusted system through OpenAPI, you can only call the "RunInstances" implementation. The "CreateInstance" parameter cannot be set to "SecurityOptions.TrustedSystemMode.

For more information about trusted systems, see [Overview of trusted features for security-enhanced instances](~~ 201394 ~~).

Default value: Null.', position=''),
  }(name='SecurityOptions'),
  privatePoolOptions?: {
    matchCriteria?: string(name='MatchCriteria', description='The capacity of the private pool that the instance starts. After the elastic protection service or the capacity reservation service takes effect, the private pool capacity is generated for you to select when the instance is started. Valid values:

-Open: Open mode. The capacity of the open private pool is automatically matched. If the capacity of the private pool does not meet the conditions, use the public pool resources to start. In this mode, you do not need to set the "PrivatePoolOptions.Id" parameter.
-Target: specifies the mode. Start an instance with the specified private pool capacity. If the private pool capacity is unavailable, the instance fails to start. The private pool ID must be specified in this mode, that is, the "PrivatePoolOptions.Id" parameter is required.
-None: the mode is not used. No private pool capacity is used when the instance is started.

Default value: None

In any of the following scenarios, the private pool capacity option can only be set to "None" or no value.
-Create a preemptible instance.
-Create an ECS instance of the classic network type.
-Create an ECS instance on a DDH.', position=''),
    id?: string(name='Id', description='The ID of the private pool. The ID of the elastic protection service or the capacity reservation service.', position=''),
  }(name='PrivatePoolOptions'),
  cpuOptions?: {
    numa?: string(name='Numa', description='The number of CPU Numa nodes.', position=''),
    core?: int32(name='Core', description='The number of CPU cores. This parameter does not support custom settings. You can only use the default value.

<props = "china"> Default value: see [custom CPU options](~~ 145895 ~~). </props>
', position=''),
    threadsPerCore?: int32(name='ThreadsPerCore', description='The number of CPU threads. The number of VCPUs of the ECS instance = "CpuOptions.Core" value "CpuOptions.ThreadPerCore" value.

-"CpuOptions.ThreadPerCore = **indicates that CPU hyper-threading is disabled.

-Only some instance types support setting the number of CPU threads.

<props = "china"> valid values and default values: see [customize CPU options](~~ 145895 ~~). </props>
', position=''),
  }(name='CpuOptions'),
  schedulerOptions?: {
    dedicatedHostClusterId?: string(name='DedicatedHostClusterId', description='The dedicated host cluster to which the ECS instance belongs. The system automatically selects a dedicated host in the dedicated host cluster to deploy the ECS instance.

> This parameter takes effect only when "tenance" is set to "host.

When you specify both the dedicated host ("DedicatedHostId") and the dedicated host cluster ("SchedulerOptions.DedicatedHostClusterId"):
-If the DDH belongs to a DDH cluster, the ECS instance is preferentially deployed on the specified DDH.
-If the DDH does not belong to the DDH cluster, the ECS instance fails to be created.

<props = "china"> You can use [DescribeDedicatedHostClusters](~~ 184145 ~~) to query the ID List of dedicated host clusters. </props>

<props = "intl"> You can use [DescribeDedicatedHostClusters](~~ 184145 ~~) to query the ID List of dedicated host clusters. </props>

<props = "partner"> You can use [DescribeDedicatedHostClusters](~~ 184145 ~~) to query the ID List of dedicated host clusters. </props>', position=''),
  }(name='SchedulerOptions'),
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  deploymentSetGroupNo?: int32(name='DeploymentSetGroupNo', position='Query'),
  httpPutResponseHopLimit?: int32(name='HttpPutResponseHopLimit', position='Query'),
  isp?: string(name='Isp', position='Query'),
  hostNames?: [ string ](name='HostNames', position='Query'),
  dataDisk?: [ 
    {
      performanceLevel?: string(name='PerformanceLevel', description='创建ESSD云盘作为数据盘使用时，设置云盘的性能等级。N的取值必须和`DataDisk.N.Category=cloud_essd`中的N保持一致。取值范围：

- PL0：单盘最高随机读写IOPS 1万
- PL1（默认）：单盘最高随机读写IOPS 5万
- PL2：单盘最高随机读写IOPS 10万
- PL3：单盘最高随机读写IOPS 100万

有关如何选择ESSD性能等级，请参见[ESSD云盘](~~122389~~)。'),
      autoSnapshotPolicyId?: string(name='AutoSnapshotPolicyId', description='数据盘采用的自动快照策略ID。'),
      encrypted?: string(name='Encrypted', description='数据盘N是否加密。取值范围：
- true：加密
- false：不加密

默认值：false'),
      description?: string(name='Description', description='数据盘的描述。长度为2~256个英文或中文字符，不能以`http://`和`https://`开头。'),
      snapshotId?: string(name='SnapshotId', description='创建数据盘N使用的快照。N的取值范围为1~16。

指定参数`DataDisk.N.SnapshotId`后，参数`DataDisk.N.Size`会被忽略，实际创建的云盘大小为指定的快照的大小。不能使用早于2013年7月15日（含）创建的快照，请求会报错被拒绝。'),
      device?: string(name='Device', description='数据盘的挂载点。

>该参数即将被弃用，为提高兼容性，请尽量使用其他参数。'),
      size?: int32(name='Size', description='第n个数据盘的容量大小，N的取值范围为1~16，内存单位为GiB。取值范围：

-   cloud_efficiency：20~32768
-   cloud_ssd：20~32768
-   cloud_essd：20~32768
-   cloud：5~2000

该参数的取值必须大于等于参数`SnapshotId`指定的快照的大小。'),
      diskName?: string(name='DiskName', description='数据盘名称。长度为2~128个英文或中文字符。必须以大小字母或中文开头，不能以`http://`和`https://`开头。可以包含数字、半角句号（.）、半角冒号（:）、下划线（_）或者短划线（-）。

默认值：空'),
      category?: string(name='Category', description='数据盘N的云盘种类。取值范围：

-   cloud_efficiency：高效云盘
-   cloud_ssd：SSD云盘
-   cloud_essd：ESSD云盘
-   cloud：普通云盘。

对于I/O优化实例，默认值为cloud_efficiency。对于非I/O优化实例，默认值为cloud。'),
      encryptAlgorithm?: string(name='EncryptAlgorithm'),
      deleteWithInstance?: boolean(name='DeleteWithInstance', description='表示数据盘是否随实例释放。取值范围：
- true：数据盘随实例释放。
- false：数据盘不随实例释放。

默认值：true'),
      KMSKeyId?: string(name='KMSKeyId', description='数据盘对应的KMS密钥ID。'),
      storageClusterId?: string(name='StorageClusterId', description='专属块存储集群ID。如果您在创建ECS实例时，需要使用专属块存储集群中的云盘资源作为数据盘，请设置该参数。'),
    }
  ](name='DataDisk', position='Query'),
  arn?: [ 
    {
      roleType?: string(name='RoleType'),
      rolearn?: string(name='Rolearn'),
      assumeRoleFor?: long(name='AssumeRoleFor'),
    }
  ](name='Arn', position='Query'),
  networkInterface?: [ 
    {
      vSwitchId?: string(name='VSwitchId', description='辅助弹性网卡所属的虚拟交换机ID。N的取值：1

默认值：ECS实例所属的虚拟交换机。'),
      networkInterfaceName?: string(name='NetworkInterfaceName', description='辅助弹性网卡名称。N的取值：1'),
      description?: string(name='Description', description='辅助弹性网卡的描述。N的取值：1。长度为2~256个英文或中文字符，不能以`http://`和`https://`开头。'),
      securityGroupId?: string(name='SecurityGroupId', description='辅助弹性网卡所属的安全组ID。N的取值：1

默认值：实例所属的安全组。'),
      primaryIpAddress?: string(name='PrimaryIpAddress', description='添加一张辅助弹性网卡并设置主IP地址。N的取值范围为1。

>创建ECS实例时，您最多能添加一张辅助网卡。实例创建成功后，您可以调用[CreateNetworkInterface](~~58504~~)和[AttachNetworkInterface](~~58515~~)添加更多的辅助网卡。

默认值：从网卡所属的交换机网段中随机选择一个IP地址。'),
      queueNumber?: int32(name='QueueNumber', description='辅助弹性网卡队列数。N的取值：1
- 不能超过实例规格允许的单块网卡最大队列数。
- 实例的所有网卡累加队列数不能超过实例规格允许的队列数总配额。实例规格的单块网卡最大队列数和总配额可以通过[DescribeInstanceTypes](~~25620~~)接口查询`MaximumQueueNumberPerEni`、`TotalEniQueueQuantity`字段。'),
      securityGroupIds?: [ string ](name='SecurityGroupIds', description='将辅助弹性网卡同时加入多个安全组。`SecurityGroupIds.N`中N的取值范围与弹性网卡实例能够加入安全组配额有关，更多详情，请参见[使用限制](~~25412~~)。

>不支持同时指定`NetworkInterface.N.SecurityGroupId`和`NetworkInterface.N.SecurityGroupIds.N`。'),
    }
  ](name='NetworkInterface', position='Query'),
  tag?: [ 
    {
      key?: string(name='Key', description='实例、云盘和主网卡的标签键。N的取值范围：1~20。一旦传入该值，则不允许为空字符串。最多支持128个字符，不能以aliyun和acs:开头，不能包含http://或 https://。'),
      value?: string(name='Value', description='实例、云盘和主网卡的标签值。N的取值范围：1~20。一旦传入该值，可以为空字符串。最多支持128个字符，不能以acs:开头，不能包含http://或者https://。'),
    }
  ](name='Tag', position='Query'),
  description?: string(name='Description', description='The description of the instance. The description must be 2 to 256 characters in length and cannot start with "http:// "or "https.', position='Query'),
  userData?: string(name='UserData', description='The user data of the instance. It must be encoded in Base64. the maximum size of raw data is 16KB.', position='Query'),
  passwordInherit?: boolean(name='PasswordInherit', description='Specifies whether to use the default password of the image. Valid values:

-true: use
-false: Do not use

> When you use this parameter, the Password parameter must be empty, and you must ensure that the Password has been set for the image you are using.', position='Query'),
  ramRoleName?: string(name='RamRoleName', description='The name of the instance RAM role. You can use the RAM API [ListRoles](~~ 28713 ~~) to query the created instance RAM role.', position='Query'),
  internetChargeType?: string(name='InternetChargeType', description='The billing method of the network. Valid values:

-PayByBandwidth: pay-by-bandwidth
-PayByTraffic (default): Pay by traffic

> **pay-by-traffic** mode: The peak inbound and outbound bandwidth is the upper limit of the bandwidth and is not used as a service commitment indicator. When a resource scramble occurs, the peak bandwidth may be limited. If your business needs to be guaranteed by bandwidth, use the **pay-by-bandwidth** mode.
', position='Query'),
  minAmount?: int32(name='MinAmount', description='The minimum number of ECS instances to purchase. Valid values: 1 to 100.

-When the number of ECS instances is less than the minimum number, the creation fails.
-When ECS inventory quantities greater than equal to the minimum buy number, according to inventory quantity created.', position='Query'),
  keyPairName?: string(name='KeyPairName', description='The name of the key pair.

-Windows the instance. Ignore this parameter. The default value is null. Even if this parameter is specified, only the "Password" content is executed.
-The password logon method for Linux instances is initialized to disable.', position='Query'),
  spotInterruptionBehavior?: string(name='SpotInterruptionBehavior', description='The interrupt mode of the preemptible instance. You can only release instances Terminate by default.', position='Query'),
  spotDuration?: int32(name='SpotDuration', description='The retention period of a preemptible instance. Unit: hours. Valid values: 0 to 6.

-The retention period is 2 to 6 and is being invited for testing. If you want to activate the service, submit a ticket.
-If the value is 0, the mode is not protected.

Default value: 1.', position='Query'),
  clientToken?: string(name='ClientToken', description='Ensure the idempotence of the request. Generate a parameter value from your client. Make sure that the value is unique among different requests. **ClientToken** supports only ASCII characters and cannot exceed 64 characters. For more information, see [how to ensure idempotence](~~ 25693 ~~).', position='Query'),
  internetMaxBandwidthIn?: int32(name='InternetMaxBandwidthIn', description='The maximum inbound public bandwidth. Unit: Mbit/s. Valid values:

-When the purchased internet outbound bandwidth is less than or equal to 10Mbit/s: 1 to 10, the default value is 10.
-When the purchased internet outbound bandwidth is greater than 10Mbit/s: 1 to "InternetMaxBandwidthOut". The default value is "InternetMaxBandwidthOut.', position='Query'),
  launchTemplateVersion?: long(name='LaunchTemplateVersion', description='The version of the launch template. If you specify "LaunchTemplateId" or "LaunchTemplateName" without specifying the launch template version number, the default version is used.', position='Query'),
  internetMaxBandwidthOut?: int32(name='InternetMaxBandwidthOut', description='The maximum outbound public bandwidth. Unit: Mbit/s. Valid values: 0 to 100.

Default value: 0.', position='Query'),
  hostName?: string(name='HostName', description='The name of the instance. Limits:

-Periods (.) and hyphens (-) cannot be used as start and end characters, and cannot be used consecutively.
-Windows instance: the name must be 2 to 15 characters in length and cannot contain periods (.). It can contain uppercase and lowercase letters, digits, and hyphens (-).
-Other types of instances (such as Linux):
-The name must be 2 to 64 characters in length and can contain multiple periods (.). The periods must be separated by periods. Each paragraph can contain uppercase and lowercase letters, digits, and hyphens (-).
-You can use the placeholder "${instance_id}" to write the instance ID to the "HostName" parameter. For example, if "HostName = k8s-${instance_id}"and the ID of the created ECS instance is "i-123abc ****, the hostname of the instance is "k8s-i-123abc * * * *".

When you create multiple ECS instances, you can:

-Set multiple hostnames. For more information, see [batch set ordered instance names or host names](~~ 196048 ~~).
-Use the "HostNames.... parameter to set hostnames for multiple instances. Note that the "HostName" parameter and the "HostNames. "parameter cannot be set at the same time.', position='Query'),
  uniqueSuffix?: boolean(name='UniqueSuffix', description='Specifies whether to automatically add ordered suffixes for "HostName" and "InstanceName" when multiple instances are created. The number of ordered suffixes increases from 001 to 999. Valid values:
-true: add
-false: Do not add

Default value: false

When "HostName" or "InstanceName" is set according to the specified sorting format and the suffix "name_suffix "is not set, that is, the naming format is "name_prefix[begin_number,bits]", "UniqueSuffix" does not take effect, names are sorted only in the specified order.

For more information, see [batch set ordered instance names or host names](~~ 196048 ~~).', position='Query'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group to which the instance belongs.', position='Query'),
  autoRenew?: boolean(name='AutoRenew', description='Specifies whether to enable automatic renewal. This parameter takes effect only when the value of "InstanceChargeType" is "PrePaid. Valid values:

-true: auto renewal
-false (default): auto renewal is not performed.', position='Query'),
  deploymentSetId?: string(name='DeploymentSetId', description='The ID of the deployment set.', position='Query'),
  securityEnhancementStrategy?: string(name='SecurityEnhancementStrategy', description='Specifies whether to enable security hardening. Valid values:

-Active: enables security hardening, which takes effect only for public images.
-Deactive: does not enable security hardening and takes effect for all image types.', position='Query'),
  imageId?: string(name='ImageId', description='The ID of the image. You can use [DescribeImages](~~ 25534 ~~) to query the available image resources. If you do not specify "LaunchTemplateId" or "LaunchTemplateName" to determine the launch template, or you do not specify "imagefamile" to select the latest available custom image from the Image family, "ImageId" is required.', position='Query'),
  spotPriceLimit?: float(name='SpotPriceLimit', description='Set the maximum hourly price for an instance. A maximum of three decimal places are supported. This parameter takes effect when the value of "spotstratege" is "spotwithpricelime.', position='Query'),
  vSwitchId?: string(name='VSwitchId', description='The ID of the vSwitch. If you are creating a VPC-type ECS instance, you must specify the vSwitch ID and the security group and vSwitch are in the same VPC. You can call [DescribeVSwitches](~~ 35748 ~~) to query the information about the created vSwitch.

> If you specify the "VSwitchId" parameter, the specified "ZoneId" parameter must be consistent with the zone where the vSwitch is located. If you do not specify the "ZoneId" parameter, the system automatically selects the zone where the specified vSwitch is located.', position='Query'),
  instanceType?: string(name='InstanceType', description='The type of the instance. If you do not specify "LaunchTemplateId" or "LaunchTemplateName" to determine the launch template, "InstanceType" is required.

-Product selection: see [instance type family](~~ 25378 ~~) or call [DescribeInstanceTypes](~~ 25620 ~~) to view the performance data of the target instance type, for more information about how to select an instance type, see [select configuration](~~ 58291 ~~).
-Query inventory: call [DescribeAvailableResource](~~ 66186 ~~) to view the resource supply in a specified region or zone.', position='Query'),
  httpTokens?: string(name='HttpTokens', description='Specifies whether to use the enhanced mode (IMDSv2) when accessing instance metadata. Valid values:
-optional: not mandatory.
-required: force use. If this parameter is set, the instance metadata cannot be accessed in normal mode.

Default value: optional.
> For more information about how to access instance metadata, see [instance metadata access mode](~~ 150575 ~~).', position='Query'),
  dedicatedHostId?: string(name='DedicatedHostId', description='Specifies whether to create an ECS instance on a dedicated host. Preemptible instances cannot be created on dedicated hosts. When the "DedicatedHostId" parameter is specified, the "spotstratege" and "spotpricelime" settings in the request are automatically ignored.

<props = "china"> You can use [DescribeDedicatedHosts](~~ 134242 ~~) to query the ID List of dedicated hosts. </props>

<props = "intl"> You can use [DescribeDedicatedHosts](~~ 134242 ~~) to query the ID List of dedicated hosts. </props>
', position='Query'),
  imageFamily?: string(name='ImageFamily', description='The name of the Image family. You can set this parameter to obtain the latest available custom images in the current image family to create an instance.
-This parameter cannot be set if "ImageId" is set.
-The "ImageId" parameter is not set, but the specified "LaunchTemplateId" or "LaunchTemplateName" startup template is set to "ImageId.
-If "ImageId" is not set and "ImageId" is not set for the startup template corresponding to "LaunchTemplateId" or "LaunchTemplateName", you can set this parameter.
-If "ImageId" is not set, and "LaunchTemplateId" and "LaunchTemplateName" parameters are not set, this parameter can be set.', position='Query'),
  securityGroupIds?: [ string ](name='SecurityGroupIds', description='Add an instance to multiple security groups at the same time. The value range of N depends on the number of instances that can be added to security groups. For more information, see [security group limits](~~ 101348 ~~).

> SecurityGroupId and SecurityGroupIds.N cannot be specified at the same time.', position='Query'),
  ioOptimized?: string(name='IoOptimized', description='Indicates whether the instance is I/O optimized. The default value of [phased-out instance types](~~ 55263 ~~) is none. The default value of other instance types is optimized. Valid values:

-none: Non-I/O optimized
-optimized:I/O optimized', position='Query'),
  storageSetId?: string(name='StorageSetId', description='The ID of the storage set.', position='Query'),
  instanceName?: string(name='InstanceName', description='The name of the instance. The description must be 2 to 128 characters in length. It must start with a letter and cannot start with "http://" or "https. It can contain letters, digits, colons (:), underscores (_), periods (.), and hyphens (-). The default value is the instanceid" of the instance ".

When you create multiple ECS instances, you can set multiple instance names in batches. For more information, see [batch set ordered instance names or host names](~~ 196048 ~~).', position='Query'),
  amount?: int32(name='Amount', description='The number of ECS instances to be created. Valid values: 1 to 100.

Default value: 1.', position='Query'),
  zoneId?: string(name='ZoneId', description='The ID of the zone to which the instance belongs. You can call [DescribeZones](~~ 25610 ~~) to obtain the list of zones.

> If you specify the "VSwitchId" parameter, the specified "ZoneId" parameter must be consistent with the zone where the vSwitch is located. If you do not specify the "ZoneId" parameter, the system automatically selects the zone where the specified vSwitch is located.

Default value: automatically selected.', position='Query'),
  password?: string(name='Password', description='The password of the instance. The description must be 8 to 30 characters in length and must contain letters, digits, and special characters. Special symbols can be:

"""
()"~! @%& *-_+ =} [],.?/
"""

The Windows instance cannot start with a forward slash (/).

> If the "Password" parameter is specified, we recommend that you send requests over HTTPS to avoid password leakage.', position='Query'),
  securityGroupId?: string(name='SecurityGroupId', description='The ID of the security group to which the new instance belongs. Instances in the same security group can access each other. The number of instances in a security group depends on the security group type. For more information, see [limits](~~ 25412 ~~). Security groups.

> SecurityGroupId determines the network type of the instance. For example, if the network type of the specified security group is VPC, the instance is VPC, and you must specify the parameter VSwitchId.

If you do not specify "LaunchTemplateId" or "LaunchTemplateName" to determine the launch template, "SecurityGroupId" is required.', position='Query'),
  networkInterfaceQueueNumber?: int32(name='NetworkInterfaceQueueNumber', description='The number of queues for the primary Eni.
-The maximum number of queues per Nic allowed by the instance type.
-The number of accumulated queues for all NICs of an instance cannot exceed the total number of queues allowed by the instance type. You can call the [DescribeInstanceTypes](~~ 25620 ~~) operation to query the maximum number of queues and total quotas of an Eni.', position='Query'),
  launchTemplateName?: string(name='LaunchTemplateName', description='The name of the launch template.

When creating an instance using a launch template, you must specify "LaunchTemplateId" or "LaunchTemplateName" to confirm the launch template.', position='Query'),
  hpcClusterId?: string(name='HpcClusterId', description='The ID of the EHPC cluster to which the instance belongs.', position='Query'),
  creditSpecification?: string(name='CreditSpecification', description='Modify the running mode of a burstable instance. Valid values:

-Standard: Standard mode. For more information about instance performance, see performance constraint mode in [What is burstable instance](~~ 59977 ~~).
-Unlimited: Unlimited Mode. For more information about instance performance, see Unlimited mode in [What is burstable instance](~~ 59977 ~~).

Default value: None', position='Query'),
  dryRun?: boolean(name='DryRun', description='Specifies whether to PreCheck only this request. Valid values:

-true: sends a check request and does not create an instance. Check items include required parameters, request format, business restrictions, and ECS inventory. If the check fails, the corresponding error is returned. If the check succeeds, the error code "DryRunOperation" is returned ".
-false (default): Sends a normal request and directly creates an instance after passing the check.', position='Query'),
  autoReleaseTime?: string(name='AutoReleaseTime', description='The automatic release time of the pay-as-you-go instance. The time follows the [ISO8601](~~ 25696 ~~) standard and uses UTC +0. The format is yyyy-MM-ddTHH:mm:ssZ.

-If the value of seconds is not "00", it is automatically set to the beginning of the current minute ("mm").

-The minimum release time is half an hour later than the current time.

-The maximum release time cannot exceed three years.', position='Query'),
  privateIpAddress?: string(name='PrivateIpAddress', description='The private IP address of the instance.

When you configure a private IP address for a VPC-type ECS instance, you must select an idle CIDR block from the vSwitch ("VSwitchId").

> When "PrivateIpAddress" is set, the value of "administratt" can only be 1.', position='Query'),
  spotStrategy?: string(name='SpotStrategy', description='Quantity instance preemption strategy. This parameter takes effect only when the value of "InstanceChargeType" is "PostPaid. Valid values:

-NoSpot (default): a pay-as-you-go instance
-SpotWithPriceLimit: sets the maximum price for preemptible instances.
-SpotAsPriceGo: The system automatically bids, following the actual market price', position='Query'),
  periodUnit?: string(name='PeriodUnit', description='The unit of the subscription billing method. Valid values:

<props="china">
-Week
-Month (default)

</props>

<props = "intl">Month (default)</props>
', position='Query'),
  httpEndpoint?: string(name='HttpEndpoint', description='Specifies whether to enable the access channel for instance metadata. Valid values:
-enabled: enabled
-disabled: disabled

Default value: enabled
> For more information about instance metadata, see [instance metadata Overview](~~ 49122 ~~).', position='Query'),
  launchTemplateId?: string(name='LaunchTemplateId', description='The ID of the launch template. For more information, call [DescribeLaunchTemplates](~~ 73759 ~~).

When creating an instance using a launch template, you must specify "LaunchTemplateId" or "LaunchTemplateName" to confirm the launch template.', position='Query'),
  storageSetPartitionNumber?: int32(name='StorageSetPartitionNumber', description='The maximum number of partitions in a bucket. Valid values: 2 or more.', position='Query'),
  period?: int32(name='Period', description='The duration of the resource to be purchased. Unit: "__Dune. This parameter is required only when the value of "InstanceChargeType" is set to "PrePaid. If "DedicatedHostId" is specified, the value range cannot exceed the subscription duration of the dedicated host. Valid values:

<props="china">
When-PeriodUnit = Week, the value of Period is {"1", "2", "3", and "4"}.
When-PeriodUnit = Month, the value of Period is {"1", "2", "3", "4", "5", "6", "7", "8", "9", "12", "24", "36", "48", "60"}.

</props>

<props = "intl">PeriodUnit = Month, valid values of Period: {"1", "2", "3", "4", "5", "6", "7", "8", "9", "12", "24", "36", "48", "60"}. </props>', position='Query'),
  autoRenewPeriod?: int32(name='AutoRenewPeriod', description='The duration of an automatic renewal. Valid values:

<props="china">
-PeriodUnit = Week: {"1", "2", "3"}.
-PeriodUnit = Month: {"1", "2", "3", "6", "12", "24", "36", "48", "60"}.

</props>

<props = "intl">PeriodUnit = Month: {"1", "2", "3", "6", "12", "24", "36", "48", "60"}. </props>

Default value: 1.', position='Query'),
  instanceChargeType?: string(name='InstanceChargeType', description='The billing method of the instance. Valid values:

-PrePaid: Subscription
-PostPaid (default): Pay-as-you-go

<props = "china"> when you select subscription, make sure that your account supports balance payment or credit payment. Otherwise, the error message "InvalidPayMethod" is returned. </props>

<props = "intl"> when you select subscription, make sure that your account supports credit payment. Otherwise, the error message "InvalidPayMethod" is returned. </props>', position='Query'),
  deletionProtection?: boolean(name='DeletionProtection', description='The release protection property of the instance, which specifies whether to release the instance through the console or API([DeleteInstance](~~ 25507 ~~)). Valid values:

-true: enable instance release protection.
-false (default): disables instance release protection.

> This attribute applies only to pay-as-you-go instances and can only restrict manual release operations. This attribute does not take effect for system release operations.', position='Query'),
  affinity?: string(name='Affinity', description='Indicates whether the DDH instance is associated with the DDH. Valid values:

-default: the instance is not associated with a dedicated host. If you have enabled the shutdown saving mode for an instance and restart the instance after the instance is stopped, if the original DDH has insufficient available resources, the instance is placed on another DDH of the automatic deployment resource pool.

-host: the instance is associated with a dedicated host. Instances that have enabled the shutdown mode are still placed on the original dedicated host when they are restarted after the instance is stopped. If the original dedicated host does not have sufficient resources, the instance fails to be restarted.

default value: default', position='Query'),
  ipv6AddressCount?: int32(name='Ipv6AddressCount', description='Specify the number of randomly generated IPv6 addresses for the primary Eni. Valid values: 1 to 10.

> you cannot specify both the "Ipv6Addresses. **and "Ipv6AddressCount" parameters ".', position='Query'),
  tenancy?: string(name='Tenancy', description='Specifies whether to create an instance on a dedicated host. Valid values:

-default: creates a non-dedicated host instance.

-host: creates a dedicated host instance. If you do not specify "DedicatedHostId", Alibaba Cloud automatically selects a dedicated host to place the instance.

default value: default', position='Query'),
  ipv6Address?: [ string ](name='Ipv6Address', description='Specify one or more IPv6 addresses for the primary Eni. You can set up to 10 IPv6 addresses. Valid values of N: 1 to 10.

Valid values: "Ipv6Address.1=2001:db8:1234:1 a00::* * * ".

> When the "Ipv6Address. **parameter is specified, the value of the "renewt" parameter can only be 1, and the "Ipv6AddressCount" parameter cannot be specified ".', position='Query'),
}

model RunInstancesResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.'),
  orderId?: string(name='OrderId', description='The ID of the order. This parameter is returned only when you create a subscription instance (the request parameter "InstanceChargeType = PrePaid").'),
  tradePrice?: float(name='TradePrice', description='Order selling price.'),
  instanceIdSets?: {
    instanceIdSet?: [ string ](name='InstanceIdSet')
  }(name='InstanceIdSets', description='The list of instance IDs ("InstanceIdSet").'),
}

model RunInstancesResponse = {
  headers: map[string]string(name='headers'),
  body: RunInstancesResponseBody(name='body'),
}

/**
 * ## API description

<props="china">
-**Preparations * *:
-Real-name authentication is passed. For more information, see [account real-name authentication documentation](~~ 48263 ~~).
-Cost estimation: Understand the billing method of ECS. For more information, see [billing Overview](~~ 25398 ~~).
-Product selection: call [DescribeInstanceTypes](~~ 25620 ~~) to view the performance data of the target instance type, or see [selection configuration](~~ 58291 ~~) to learn how to select an instance type.
-Query inventory: call [DescribeAvailableResource](~~ 66186 ~~) to view the resource supply in a specified region or zone.
-Network Planning: make sure that you have an available security group. For more information, see [CreateSecurityGroup](~~ 25553 ~~). Before creating a VPC instance, you must [create a VPC](~~ 65430 ~~) in the corresponding Alibaba Cloud region.

</props>

<props="intl">
-**Preparations * *:
-Cost estimation: Understand the billing method of ECS. For more information, see [billing Overview](~~ 25398 ~~).
-Product selection: call [DescribeInstanceTypes](~~ 25620 ~~) to view the performance data of the target instance type, or see [selection configuration](~~ 58291 ~~) to learn how to select an instance type.
-Query inventory: call [DescribeAvailableResource](~~ 66186 ~~) to view the resource supply in a specified region or zone.
-Network Planning: make sure that you have an available security group. For more information, see [CreateSecurityGroup](~~ 25553 ~~). Before creating a VPC instance, you must [create a VPC](~~ 65430 ~~) in the corresponding Alibaba Cloud region.

</props>

-**Precautions * *:

-You can create up to 100 instances at a time.
-You can specify the "AutoReleaseTime" parameter to set the automatic release time of an instance.
-After the instance is created, the instance ID list is returned. You can use [DescribeInstances](~~ 25506 ~~) to query the status of the new instance.
-When you create an instance, the instance is automatically started until the instance status changes to running ("Running").
-Starting from November 27, 2020, the peak bandwidth of an ECS instance is affected by the account speed limit policy. To increase the peak bandwidth, open a ticket. Specific rate limiting policy: in a single region, the total actual peak bandwidth of all ECS instances billed by traffic is no more than 5 Gbit/s; the total actual peak bandwidth of all pay-by-bandwidth ECS instances cannot exceed 50 Gbit/s.
-Compared with [CreateInstance](~~ 25499 ~~), if the value of "InternetMaxBandwidthOut" is greater than 0 for an instance created by "RunInstances", the public IP address is automatically assigned to the instance.
-If the parameters are invalid or the inventory is insufficient, an error is returned. For more information, see error codes.

> If "QuotaExceed. An ElasticQuota" error indicates that the number of instances to be created for the selected instance type in the current region exceeds the system limit, or the vCPU quota for the full instance type exceeds the system limit, you can go to the [ECS console](https://ecs.console.aliyun.com/? spm = a2c8b.12215451.favorites.decs.5e3a336aMGTtzy#/privileges/quota) or [quota Center](https://quotas.console.aliyun.com/products/ecs/quotas) apply for an increase in the quota.

<props="china">
-**Best practices * *:

-When you create a large number of ECS instances (more than 100 ECS instances) at a time, you may encounter insufficient inventory. You do not have to specify resource configurations such as instance types or zones. You need to pay more attention to scenarios where you can quickly create instances; we recommend that you use auto provisioning groups when you do not specify the number of ECS instances and pay more attention to the total number of VCPUs. You can use [CreateAutoProvisioningGroup](~~ 122738 ~~) to create an auto provisioning group and deploy instance clusters across billing methods, zones, and instance families in one click. For more information, see [create multiple ECS instances by using auto provisioning group APIs](~~ 200772 ~~).

-"RunInstances" can perform batch creation tasks. To facilitate management and retrieval, we recommend that you specify a tag ("Tag.N.Key" and "Tag.N. And add an ordered suffix ("UniqueSuffix") to the hostname ("HostName") and instance name ("InstanceName").

-The instance launch template eliminates the need to enter a large number of configuration parameters each time you create an instance. You can create an instance launch template ([CreateLaunchTemplate](~~ 74686 ~~)), in the "RunInstances" request, specify "LaunchTemplateId" and "LaunchTemplateVersion" to use the launch template.

-You can obtain "RunInstances" best practices when creating an ECS instance in the [ECS console](https://ecs.console.aliyun.com/). When you confirm an order, The **API workflow on the left lists the associated APIs that can be used by "RunInstances" and the values of request parameters. The programming language-oriented SDK example is provided on the right. Currently, the **Java** and **Python** Examples are supported.

</props>

<props="intl">
-**Best practices * *:

-When you create a large number of ECS instances (more than 100 ECS instances) at a time, you may encounter insufficient inventory. You do not have to specify resource configurations such as instance types or zones. You need to pay more attention to scenarios where you can quickly create instances; we recommend that you use auto provisioning groups when you do not specify the number of ECS instances and pay more attention to the total number of VCPUs. You can use [CreateAutoProvisioningGroup](~~ 122738 ~~) to create an auto provisioning group and deploy instance clusters across billing methods, zones, and instance families in one click. For more information, see [create multiple ECS instances by using auto provisioning group APIs](~~ 200772 ~~).

-"RunInstances" can perform batch creation tasks. To facilitate management and retrieval, we recommend that you specify a tag ("Tag.N.Key" and "Tag.N. And add an ordered suffix ("UniqueSuffix") to the hostname ("HostName") and instance name ("InstanceName").

-The instance launch template eliminates the need to enter a large number of configuration parameters each time you create an instance. You can create an instance launch template ([CreateLaunchTemplate](~~ 74686 ~~)), in the "RunInstances" request, specify "LaunchTemplateId" and "LaunchTemplateVersion" to use the launch template.

-You can obtain "RunInstances" best practices when creating an ECS instance in the [ECS console](https://ecs.console.aliyun.com/). When you confirm an order, The **API workflow on the left lists the associated APIs that can be used by "RunInstances" and the values of request parameters. The programming language-oriented SDK example is provided on the right. Currently, the **Java** and **Python** Examples are supported.

</props>

<props="partner">
-**Best practices * *:

-When you create a large number of ECS instances (more than 100 ECS instances) at a time, you may encounter insufficient inventory. You do not have to specify resource configurations such as instance types or zones. You need to pay more attention to scenarios where you can quickly create instances; we recommend that you use auto provisioning groups when you do not specify the number of ECS instances and pay more attention to the total number of VCPUs. You can use [CreateAutoProvisioningGroup](~~ 122738 ~~) to create an auto provisioning group and deploy instance clusters across billing methods, zones, and instance families in one click. For more information, see [create multiple ECS instances by using auto provisioning group APIs](~~ 200772 ~~).

-"RunInstances" can perform batch creation tasks. To facilitate management and retrieval, we recommend that you specify a tag ("Tag.N.Key" and "Tag.N. And add an ordered suffix ("UniqueSuffix") to the hostname ("HostName") and instance name ("InstanceName").

-The instance launch template eliminates the need to enter a large number of configuration parameters each time you create an instance. You can create an instance launch template ([CreateLaunchTemplate](~~ 74686 ~~)), in the "RunInstances" request, specify "LaunchTemplateId" and "LaunchTemplateVersion" to use the launch template.

-You can obtain best practices for "RunInstances" when creating an ECS instance in the [ECS console](https://partners-intl.console.aliyun.com/#/ecs). When you confirm an order, The **API workflow on the left lists the associated APIs that can be used by "RunInstances" and the values of request parameters. The programming language-oriented SDK example is provided on the right. Currently, the **Java** and **Python** Examples are supported.

</props>


 */
async function runInstances(request: RunInstancesRequest): RunInstancesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'RunInstances', 'POST', 'undefined', 'json', false, 'none', request);
}

model DescribeAutoProvisioningGroupHistoryRequest {
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  autoProvisioningGroupId?: string(name='AutoProvisioningGroupId', description='The ID of the auto provisioning group.', position='Query'),
  endTime?: string(name='EndTime', description='The end time of the query scheduling history. The time follows the [ISO8601](~~ 25696 ~~) standard and uses UTC +0. The format is yyyy-MM-ddTHH:mm:ssZ.', position='Query'),
  regionId?: string(name='RegionId', description='The ID of the region where the auto provisioning Group is located.', position='Query'),
  pageNumber?: int32(name='PageNumber', description='The current page number of the paged query. Start value: 1

Default value: 1.', position='Query'),
  startTime?: string(name='StartTime', description='The start time of the query scheduling history. The time follows the [ISO8601](~~ 25696 ~~) standard and uses UTC +0. The format is yyyy-MM-ddTHH:mm:ssZ.', position='Query'),
  pageSize?: int32(name='PageSize', description='The number of entries to return on each page. Maximum Value: 100

Default value: 10', position='Query'),
}

model DescribeAutoProvisioningGroupHistoryResponseBody = {
  pageSize?: int32(name='PageSize', description='The number of rows per page.'),
  requestId?: string(name='RequestId', description='The ID of the request.'),
  pageNumber?: int32(name='PageNumber', description='The page number.'),
  totalCount?: int32(name='TotalCount', description='The total number of queried scheduling tasks.'),
  autoProvisioningGroupHistories?: {
    autoProvisioningGroupHistory?: [ 
    {
      status?: string(name='Status', description='The status of a single scheduling task. Possible values:

-prepare: the scheduling task is running.
-success: the scheduling task is successfully executed.
-failed: the scheduling task failed.'),
      startTime?: string(name='StartTime', description='The time when a single scheduling task starts.'),
      taskId?: string(name='TaskId', description='The ID of a single scheduling task.'),
      lastEventTime?: string(name='LastEventTime', description='The execution time of the last instance creation activity for a single scheduling task.'),
      activityDetails?: {
        activityDetail?: [ 
        {
          status?: string(name='Status', description='The execution status of an instance creation activity for a single scheduling task. Possible values:

-Successful: the instance is created.
-Failed: the instance Failed to be created.
-InProgress: the instance is being created.
-Warning: the instance is created.'),
          detail?: string(name='Detail', description='The execution details of a single scheduling task and an instance creation activity.'),
        }
      ](name='ActivityDetail')
      }(name='ActivityDetails', description='The details of a single scheduling task.'),
    }
  ](name='AutoProvisioningGroupHistory')
  }(name='AutoProvisioningGroupHistories', description='The information of all scheduling tasks.'),
}

model DescribeAutoProvisioningGroupHistoryResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeAutoProvisioningGroupHistoryResponseBody(name='body'),
}

async function describeAutoProvisioningGroupHistory(request: DescribeAutoProvisioningGroupHistoryRequest): DescribeAutoProvisioningGroupHistoryResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeAutoProvisioningGroupHistory', 'POST', 'undefined', 'json', false, 'none', request);
}

model CreateLaunchTemplateVersionRequest {
  systemDisk?: {
    iops?: int32(name='Iops', position=''),
    description?: string(name='Description', description='System disk description. The description must be 2 to 256 characters in length and cannot start with http:// or https.', position=''),
    deleteWithInstance?: boolean(name='DeleteWithInstance', description='Indicates whether the system disk is released with the instance. Valid values:

-true: release with the instance
-false: the instance is not released.

Default value: true', position=''),
    performanceLevel?: string(name='PerformanceLevel', description='When you create an ESSD as a system disk, set the performance level of the disk. Valid values:

-PL0 (default): The maximum random read/write IOPS per disk is 10,000.
-PL1: The maximum random read/write IOPS per disk is 50,000
-PL2: The maximum random read/write IOPS per disk is 100,000
-PL3: The maximum random read/write IOPS per disk is 1 million

For more information about how to select an ESSD performance level, see [ESSD cloud disk](~~ 122389 ~~).', position=''),
    size?: int32(name='Size', description='The size of the system disk. Unit: GiB. Valid values: 20 to 500.

The value of this parameter must be greater than or equal to max{20, ImageSize}.', position=''),
    category?: string(name='Category', description='The type of the system disk. Valid values:

-cloud: basic cloud disk.
-cloud_efficiency: Ultra disk.
-cloud_ssd:SSD cloud disk.
-cloud_essd:ESSD. You can set the performance level of a cloud disk by using the "SystemDisk.PerformanceLevel" parameter.

For phased-out instance types and non-I/O optimized instances, the default value is cloud. Otherwise, the default value is cloud_efficiency.', position=''),
    diskName?: string(name='DiskName', description='System disk name. The description must be 2 to 128 characters in length. It must start with a letter and cannot start with http:// or https. It can contain numbers, colons (:), underscores (_), and hyphens (-).', position=''),
  }(name='SystemDisk'),
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  dataDisk?: [ 
    {
      performanceLevel?: string(name='PerformanceLevel', description='创建ESSD云盘作为数据盘使用时，设置云盘的性能等级。N的取值必须和`DataDisk.N.Category=cloud_essd`中的N保持一致。取值范围：

- PL0：单盘最高随机读写IOPS 1万
- PL1（默认）：单盘最高随机读写IOPS 5万
- PL2：单盘最高随机读写IOPS 10万
- PL3：单盘最高随机读写IOPS 100万

有关如何选择ESSD性能等级，请参见[ESSD云盘](~~122389~~)。'),
      description?: string(name='Description', description='实例描述。长度为2~256个英文或中文字符，不能以http://和https://开头。'),
      snapshotId?: string(name='SnapshotId', description='创建数据盘n使用的快照。n的取值范围为1~16。指定参数`DataDisk.N.SnapshotId`后，参数`DataDisk.N.Size`会被忽略，实际创建的云盘大小为指定的快照的大小。

不能使用早于2013年7月15日（含）创建的快照，请求会报错被拒绝。'),
      size?: int32(name='Size', description='第n个数据盘的容量大小，n的取值范围为1~16，内存单位为GiB。取值范围：

-   cloud：5~2000
-   cloud_efficiency：20~32768
-   cloud_ssd：20~32768
-   cloud_essd：20~32768

该参数的取值必须大于等于参数`SnapshotId`指定的快照的大小。'),
      device?: string(name='Device'),
      diskName?: string(name='DiskName', description='数据盘名称。长度为2~128个英文或中文字符。必须以大小字母或中文开头，不能以http://和https://开头。可以包含数字、半角冒号（:）、下划线（_）或者连字符（-）。'),
      category?: string(name='Category', description='数据盘n的云盘种类。取值范围：

-   cloud：普通云盘
-   cloud_efficiency：高效云盘
-   cloud_ssd：SSD云盘
-   cloud_essd：ESSD云盘

I/O优化实例的默认值为cloud_efficiency，非I/O优化实例的默认值为cloud。'),
      deleteWithInstance?: boolean(name='DeleteWithInstance', description='表示数据盘是否随实例释放。取值范围：

- true：随实例释放
- false：不随实例释放

默认值：true'),
      encrypted?: string(name='Encrypted', description='数据盘是否加密。'),
    }
  ](name='DataDisk', position='Query'),
  networkInterface?: [ 
    {
      vSwitchId?: string(name='VSwitchId', description='辅助弹性网卡所属的虚拟交换机ID。实例与辅助弹性网卡必须在同一VPC的同一可用区中，可以分属于不同交换机。`NetworkInterface.N`的N取值不能大于1。'),
      networkInterfaceName?: string(name='NetworkInterfaceName', description='辅助弹性网卡名称。`NetworkInterface.N`的N取值不能大于1。'),
      description?: string(name='Description', description='辅助弹性网卡描述信息。长度为2~256个英文或中文字符，不能以`http://`和`https://`开头。`NetworkInterface.N`的N取值不能大于1。'),
      securityGroupId?: string(name='SecurityGroupId', description='辅助弹性网卡所属安全组的ID。辅助弹性网卡的安全组和实例的安全组必须在同一个VPC下。`NetworkInterface.N`的N取值不能大于1。

> 不支持同时指定`NetworkInterface.N.SecurityGroupId`和`NetworkInterface.N.SecurityGroupIds.N`。'),
      primaryIpAddress?: string(name='PrimaryIpAddress', description='辅助弹性网卡的主私有IP地址。`NetworkInterface.N`的N取值不能大于1。'),
      securityGroupIds?: [ string ](name='SecurityGroupIds', description='辅助弹性网卡加入的一个或多个安全组。安全组和辅助弹性网卡必须在同一个专有网络VPC中。`SecurityGroupIds.N`的N取值范围与辅助弹性网卡能够加入安全组配额有关。更多信息，请参见[使用限制](~~25412~~)。`NetworkInterface.N`的N取值不能大于1。

> 不支持同时指定`NetworkInterface.N.SecurityGroupId`和`NetworkInterface.N.SecurityGroupIds.N`。'),
    }
  ](name='NetworkInterface', position='Query'),
  tag?: [ 
    {
      key?: string(name='Key', description='实例、块存储和主网卡的标签键。N的取值范围：1~5。一旦传入该值，则不允许为空字符串。最多支持64个字符，不能以aliyun和acs:开头，不能包含http://或者https://。'),
      value?: string(name='Value', description='实例、块存储和主网卡的标签值。N的取值范围：1~5。一旦传入该值，可以为空字符串。最多支持128个字符，不能以aliyun和acs:开头，不能包含http://或者https://。'),
    }
  ](name='Tag', position='Query'),
  passwordInherit?: boolean(name='PasswordInherit', position='Query'),
  ownerId?: long(name='OwnerId', description='The ID of the RAM user.', position='Query'),
  deploymentSetId?: string(name='DeploymentSetId', description='The ID of the deployment set.', position='Query'),
  description?: string(name='Description', description='The description of the instance. The description must be 2 to 256 characters in length and cannot start with http:// or https.', position='Query'),
  versionDescription?: string(name='VersionDescription', description='The description of the instance launch template version. The description must be 2 to 256 characters in length and cannot start with http:// or https.', position='Query'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group.', position='Query'),
  zoneId?: string(name='ZoneId', description='The ID of the zone to which the instance belongs.', position='Query'),
  spotDuration?: int32(name='SpotDuration', description='The retention period of a preemptible instance. Unit: hours. Valid values: 0 to 6.

-The retention period is 2 to 6 and is being invited for testing. If you want to activate the service, submit a ticket.
-If the value is 0, the mode is not protected.

Default value: 1.', position='Query'),
  ioOptimized?: string(name='IoOptimized', description='Indicates whether the instance is I/O optimized. Valid values:

-none: Non-I/O optimized
-optimized:I/O optimized', position='Query'),
  instanceName?: string(name='InstanceName', description='The name of the instance. The description must be 2 to 128 characters in length. It must start with a letter and cannot start with http:// or https. It can contain numbers, colons (:), underscores (_), and hyphens (-).', position='Query'),
  internetChargeType?: string(name='InternetChargeType', description='The billing method of Outbound Internet bandwidth. Valid values:

-PayByBandwidth: pay-by-bandwidth
-PayByTraffic: pay by traffic

> **pay-by-traffic** mode: The peak inbound and outbound bandwidth is the upper limit of the bandwidth and is not used as a service commitment indicator. When a resource scramble occurs, the peak bandwidth may be limited. If your business needs to be guaranteed by bandwidth, use the **pay-by-bandwidth** mode.

', position='Query'),
  ramRoleName?: string(name='RamRoleName', description='The name of the instance RAM role. You can use the RAM API [ListRoles](~~ 28713 ~~) to query the created instance RAM role.', position='Query'),
  internetMaxBandwidthIn?: int32(name='InternetMaxBandwidthIn', description='The maximum inbound public bandwidth. Unit: Mbit/s. Valid values:

-When the purchased internet outbound bandwidth is less than or equal to 10Mbit/s: 1 to 10, the default value is 10.
-When the purchased internet outbound bandwidth is greater than 10Mbit/s: 1 to "InternetMaxBandwidthOut". The default value is "InternetMaxBandwidthOut.', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='The account name of the resource master account.', position='Query'),
  securityGroupIds?: [ string ](name='SecurityGroupIds', description='One or more security groups to which the instance belongs. The value range of N depends on the number of security groups that the instance can join. For more information, see [limits](~~ 25412 ~~).

> you cannot specify both "SecurityGroupId" and "SecurityGroupIds ".', position='Query'),
  launchTemplateName?: string(name='LaunchTemplateName', description='The name of the instance launch template. The description must be 2 to 128 characters in length. It must start with a letter and cannot start with http:// or https. It can contain numbers, colons (:), underscores (_), and hyphens (-).', position='Query'),
  networkType?: string(name='NetworkType', description='The network type of the instance. Valid values:

-classic
-vpc', position='Query'),
  regionId?: string(name='RegionId', description='The ID of the region. You can call [DescribeRegions](~~ 25609 ~~) to view the latest region list.', position='Query'),
  period?: int32(name='Period', description='The duration of the resource. Unit: month. This parameter is required only when the value of "InstanceChargeType" is set to "PrePaid. Once the DedicatedHostId is specified, the value range cannot exceed the subscription duration of the DDH. Valid values:

-"PeriodUnit = Week", valid values of Period: {"1", "2", "3", and "4"}
-"PeriodUnit = Month", valid values of Period: {"1", "2", "3", "4", "5", "6", "7", "8", "9", "12", "24", "36", "48", "60"}', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', description='The ID of the resource master account, that is, the UID.', position='Query'),
  hostName?: string(name='HostName', description='The hostname of the ECS instance.

-Periods (.) and hyphens (-) cannot be used as start and end characters, and cannot be used consecutively.
-Windows instance: the name must be 2 to 15 characters in length and cannot contain periods (.). It can contain uppercase and lowercase letters, digits, and hyphens (-).
-Other types of instances (such as Linux): The name must be 2 to 64 characters in length and can contain multiple periods (.), A segment can contain uppercase and lowercase letters, digits, and hyphens (-).', position='Query'),
  spotStrategy?: string(name='SpotStrategy', description='Quantity instance preemption strategy. This parameter takes effect only when the value of "InstanceChargeType" is "PostPaid. Valid values:

-NoSpot: a pay-as-you-go instance.
-SpotWithPriceLimit: sets the maximum price for preemptible instances.
-SpotAsPriceGo: The system automatically bids based on the actual market price.', position='Query'),
  autoReleaseTime?: string(name='AutoReleaseTime', description='The automatic release time. The time follows the [ISO8601](~~ 25696 ~~) standard and uses UTC time. The format is yyyy-MM-ddTHH:mm:ssZ.

-If the value of seconds is not "00", it is automatically set to the beginning of the current minute ("mm").

-The minimum release time is half an hour later than the current time.

-The maximum release time cannot exceed three years.', position='Query'),
  spotPriceLimit?: float(name='SpotPriceLimit', description='Set the maximum hourly price for an instance. A maximum of three decimal places are supported.', position='Query'),
  securityGroupId?: string(name='SecurityGroupId', description='The ID of the security group to which the new instance belongs. Instances in the same security group can access each other.

> you cannot specify both "SecurityGroupId" and "SecurityGroupIds ".', position='Query'),
  vSwitchId?: string(name='VSwitchId', description='You must specify the vSwitch ID when creating a VPC-type instance.', position='Query'),
  securityEnhancementStrategy?: string(name='SecurityEnhancementStrategy', description='Specifies whether to enable security hardening for the operating system. Valid values:

-Active: enables security hardening, which takes effect only for public images.
-Deactive: does not enable security hardening and takes effect for all image types.', position='Query'),
  enableVmOsConfig?: boolean(name='EnableVmOsConfig', description='Specifies whether to enable instance operating system configuration.', position='Query'),
  vpcId?: string(name='VpcId', description='VPC VPC ID.', position='Query'),
  launchTemplateId?: string(name='LaunchTemplateId', description='The ID of the launch template. For more information, call [DescribeLaunchTemplates](~~ 73759 ~~). You must specify "LaunchTemplateId" or "LaunchTemplateName" to determine the launch template.', position='Query'),
  imageOwnerAlias?: string(name='ImageOwnerAlias', description='The source of the image.
> This parameter will be deprecated soon. To improve compatibility, try to use other parameters.', position='Query'),
  privateIpAddress?: string(name='PrivateIpAddress', description='The private IP address of the instance.

When you configure a private IP address for a VPC-type ECS instance, you must select an idle CIDR block from the vSwitch ("VSwitchId").', position='Query'),
  instanceType?: string(name='InstanceType', description='The type of the instance. For more information, see [instance type family](~~ 25378 ~~), or call [DescribeInstanceTypes](~~ 25620 ~~) to obtain the latest specification.', position='Query'),
  internetMaxBandwidthOut?: int32(name='InternetMaxBandwidthOut', description='The maximum outbound public bandwidth. Unit: Mbit/s. Valid values: 0 to 100.', position='Query'),
  keyPairName?: string(name='KeyPairName', description='The name of the key pair.

-Windows the instance. Ignore this parameter. Even if this parameter is specified, only the "Password" content is executed.
-The password logon method for Linux instances is initialized to disable.', position='Query'),
  imageId?: string(name='ImageId', description='The ID of the image. You can use [DescribeImages](~~ 25534 ~~) to query the available image resources.', position='Query'),
  userData?: string(name='UserData', description='The user data of the instance must be encoded in Base64. the maximum size of the raw data is 16kB.', position='Query'),
  instanceChargeType?: string(name='InstanceChargeType', description='The billing method of the instance. Valid values:

-<props = "china">PrePaid: subscription. When you select this billing method, make sure that your account supports balance payment and credit payment. Otherwise, an error message "InvalidPayMethod" is returned. </props>
-<props = "intl">PrePaid: subscription. When you select this billing method, you must ensure that your account supports credit payment. Otherwise, the error message "InvalidPayMethod" is returned. </props>
-<props = "partner">PrePaid: subscription. When you select this billing method, you must ensure that your account supports credit payment. Otherwise, the error message "InvalidPayMethod" is returned. </props>
-PostPaid: pay-as-you-go.', position='Query'),
}

model CreateLaunchTemplateVersionResponseBody = {
  launchTemplateVersionNumber?: long(name='LaunchTemplateVersionNumber', description='The version number of the instance launch template.'),
  requestId?: string(name='RequestId', description='The ID of the request.'),
}

model CreateLaunchTemplateVersionResponse = {
  headers: map[string]string(name='headers'),
  body: CreateLaunchTemplateVersionResponseBody(name='body'),
}

/**
 * ## API description

To modify the parameters of a version, you can create a template version. A maximum of 30 versions can be created for each instance launch template.
 */
async function createLaunchTemplateVersion(request: CreateLaunchTemplateVersionRequest): CreateLaunchTemplateVersionResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateLaunchTemplateVersion', 'POST', 'undefined', 'json', false, 'none', request);
}

model DescribeCapacityReservationsRequest {
  privatePoolOptions?: {
    ids?: string(name='Ids', description='The ID of the subscription service. The value can be a JSON Array consisting of multiple ids. A maximum of 100 IDs can be entered. Separate IDs with commas (,).', position=''),
  }(name='PrivatePoolOptions'),
  tag?: [ 
    {
      key?: string(name='Key', description='标签键。N表示可以设置多个标签键进行过滤，N的取值范围：1~20。

使用一个标签过滤资源，查询到该标签下的资源数量不能超过1000个；使用多个标签过滤资源，查询到同时绑定了多个标签的资源数量不能超过1000个。如果资源数量超过1000个，请使用[ListTagResources](~~110425~~)接口进行查询。'),
      value?: string(name='Value', description='标签键。N表示可以设置多个标签键进行过滤，N的取值范围：1~20。'),
    }
  ](name='Tag', position='Query'),
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  packageType?: string(name='PackageType', position='Query'),
  regionId?: string(name='RegionId', description='The ID of the region to which the capacity reservation service belongs. You can call [DescribeRegions](~~ 25609 ~~) to view the latest region list.', position='Query'),
  nextToken?: string(name='NextToken', description='The start flag of the capacity reservation service query. This parameter is obtained from the last request.', position='Query'),
  maxResults?: int32(name='MaxResults', description='The number of entries to return on each page.

Maximum Value: 100

Default value: 10', position='Query'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group.', position='Query'),
  instanceType?: string(name='InstanceType', description='The instance type.', position='Query'),
  zoneId?: string(name='ZoneId', description='The ID of the zone to which the capacity reservation service belongs.', position='Query'),
  status?: string(name='Status', description='The status of the subscription service. Valid values:

-Preparing: Preparing.
-Active: takes effect.
-Released: Released, including manual release and automatic release upon expiration.

Default value: Active', position='Query'),
  instanceChargeType?: string(name='InstanceChargeType', description='The billing method of the instance. Set the value to PostPaid. Currently, only pay-as-you-go is supported.

Default value: PostPaid', position='Query'),
  platform?: string(name='Platform', description='The operating system of the instance. Valid values:

-windows: queries only the capacity reservation service of the Windows system.
-linux: only check the capacity reservation service of the Linux system.
-all: queries all capacity reservation services.

Default value: all', position='Query'),
}

model DescribeCapacityReservationsResponseBody = {
  nextToken?: string(name='NextToken', description='The start flag of the next query in the capacity reservation service.'),
  requestId?: string(name='RequestId', description='The ID of the request.'),
  totalCount?: int32(name='TotalCount', description='The number of records that meet the query criteria.'),
  maxResults?: int32(name='MaxResults', description='The number of rows displayed on each page of the capacity reservation service.'),
  capacityReservationSet?: {
    capacityReservationItem?: [ 
    {
      status?: string(name='Status', description='The status of the subscription service. Possible values:

-Preparing: Preparing.
-Active: takes effect.
-Released: Released, including manual release and automatic release upon expiration.'),
      timeSlot?: string(name='TimeSlot', description='> This parameter is being invited for testing and is not currently available.'),
      privatePoolOptionsMatchCriteria?: string(name='PrivatePoolOptionsMatchCriteria', description='The type of the private resource pool generated after the capacity reservation service takes effect. Possible values:

-Open: Open mode.
-Target: The dedicated mode.
'),
      privatePoolOptionsId?: string(name='PrivatePoolOptionsId', description='The ID of the subscription service.'),
      privatePoolOptionsName?: string(name='PrivatePoolOptionsName', description='The name of the subscription service.'),
      regionId?: string(name='RegionId', description='The ID of the region to which the capacity reservation service belongs.'),
      instanceChargeType?: string(name='InstanceChargeType', description='The billing method of the instance in the capacity reservation service.'),
      endTime?: string(name='EndTime', description='The expiration time of the subscription service.'),
      startTime?: string(name='StartTime', description='The time when the scheduled service takes effect.'),
      description?: string(name='Description', description='The description of the capacity reservation service.'),
      endTimeType?: string(name='EndTimeType', description='The expiration method of the capacity reservation service. Possible values:

-Limited: release at the specified time.
-Unlimited: manually released. No time limit.'),
      resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group to which the capacity reservation service belongs.'),
      platform?: string(name='Platform', description='The operating system of the matched instance. Possible values:

-windows
-linux'),
      allocatedResources?: {
        allocatedResource?: [ 
        {
          usedAmount?: int32(name='UsedAmount', description='The number of used instances.'),
          totalAmount?: int32(name='TotalAmount', description='The total number of instances to be reserved within an instance type.'),
          zoneId?: string(name='zoneId', description='The ID of the zone.'),
          instanceType?: string(name='InstanceType', description='The instance type.'),
        }
      ](name='AllocatedResource')
      }(name='AllocatedResources', description='The resource allocation details.'),
      tags?: {
        tag?: [ 
        {
          tagKey?: string(name='TagKey', description='The key of the tag.'),
          tagValue?: string(name='TagValue', description='The value of the tag.'),
        }
      ](name='Tag')
      }(name='Tags', description='The tag key-value pair associated with the capacity reservation service.'),
    }
  ](name='CapacityReservationItem')
  }(name='CapacityReservationSet', description='A collection of capacity reservation service details.'),
}

model DescribeCapacityReservationsResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeCapacityReservationsResponseBody(name='body'),
}

async function describeCapacityReservations(request: DescribeCapacityReservationsRequest): DescribeCapacityReservationsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeCapacityReservations', 'POST', 'undefined', 'json', false, 'none', request);
}

model StopInvocationRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  instanceId?: [ string ](name='InstanceId', description='The list of instances to stop running the command. You can specify a maximum of 50 instance IDs. Valid values of N: 1 to 50.', position='Query'),
  ownerId?: long(name='OwnerId', description='The ID of the RAM user.', position='Query'),
  regionId?: string(name='RegionId', description='The ID of the region. You can call [DescribeRegions](~~ 25609 ~~) to view the latest region list.', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', description='The ID of the resource master account, that is, the UID.', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='The account name of the resource master account.', position='Query'),
  invokeId?: string(name='InvokeId', description='The ID of the command process. You can call the [DescribeInvocations](~~ 64840 ~~) operation to query all InvokeId.', position='Query'),
}

model StopInvocationResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.'),
}

model StopInvocationResponse = {
  headers: map[string]string(name='headers'),
  body: StopInvocationResponseBody(name='body'),
}

/**
 * ## API description

-After a single command process is stopped, instances that have already started to run will continue to run, and instances that have not started to run will no longer run.

-After the periodic command process is stopped, the command that has already started to be executed will continue, but will not be executed next time.
 */
async function stopInvocation(request: StopInvocationRequest): StopInvocationResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'StopInvocation', 'POST', 'undefined', 'json', false, 'none', request);
}

model ModifyDiskAttributeRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  regionId?: string(name='RegionId', description='The ID of the region. You can call [DescribeRegions](~~ 25609 ~~) to view the latest region list.', position='Query'),
  description?: string(name='Description', description='The description of the disk. The description must be 2 to 256 characters in length and cannot start with "http:// "or "https.
', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='The account name of the resource master account.', position='Query'),
  deleteAutoSnapshot?: boolean(name='DeleteAutoSnapshot', description='Specifies whether to delete automatic snapshots of disks at the same time. Default value: none, no said don"t change the current value.', position='Query'),
  diskIds?: [ string ](name='DiskIds', description='The IDs of multiple disks to be modified. Valid values of N: 0 to 100.
> "DiskId" and "DiskIds.... parameters cannot be called at the same time. Select either of them as needed.', position='Query'),
  diskName?: string(name='DiskName', description='The name of the disk. The description must be 2 to 128 characters in length. It must start with a letter and cannot start with "http:// "or "https. It can contain numbers, colons (:), underscores (_), and hyphens (-).
', position='Query'),
  ownerId?: long(name='OwnerId', description='The ID of the RAM user.', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', description='The ID of the resource master account, that is, the UID.', position='Query'),
  deleteWithInstance?: boolean(name='DeleteWithInstance', description='Indicates whether the disk is released with the instance. Default value: none, no said don"t change the current value.

<props = "china"> this parameter is not supported for disks with multiple mount features enabled. </props>

If you set the "DeleteWithInstance" parameter to "false", an error is returned.

-When the category of the disk is ephemeral.
-If the category of a disk is standard cloud and cannot be detached (Portable = false).
', position='Query'),
  diskId?: string(name='DiskId', description='The ID of the disk to be modified.
> "DiskId" and "DiskIds.... parameters cannot be called at the same time. Select either of them as needed.', position='Query'),
  enableAutoSnapshot?: boolean(name='EnableAutoSnapshot', description='Specifies whether to enable automatic snapshot policies for disks.

-ture: enabled
-false: Disabled

Default value: none, said don"t change the current value.

> by default, the automatic snapshot policy is enabled for the created cloud disk. You only need to bind an automatic snapshot policy to the disk.', position='Query'),
}

model ModifyDiskAttributeResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.'),
}

model ModifyDiskAttributeResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyDiskAttributeResponseBody(name='body'),
}

/**
 * ## API description

-When you call this operation, you set the do not release with the instance (DeleteWithInstance = false) attribute. Once the ECS instance attached to the disk is locked safely and the OperationLocks is marked with "LockReason" : "security" is locked. When you release an instance, the disk DeleteWithInstance are ignored and released at the same time.

-You can call the "DiskIds. **parameter to modify the names, descriptions, and release properties of multiple block stores with the instance.
 */
async function modifyDiskAttribute(request: ModifyDiskAttributeRequest): ModifyDiskAttributeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyDiskAttribute', 'POST', 'undefined', 'json', false, 'none', request);
}

model DescribeFleetsRequest {
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  pageNumber?: int32(name='PageNumber', position='Query'),
  pageSize?: int32(name='PageSize', position='Query'),
  fleetName?: string(name='FleetName', position='Query'),
  fleetId?: [ string ](name='FleetId', position='Query'),
  fleetStatus?: [ string ](name='FleetStatus', position='Query'),
}

model DescribeFleetsResponseBody = {
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  pageNumber?: int32(name='PageNumber'),
  totalCount?: int32(name='TotalCount'),
  fleets?: {
    fleet?: [ 
    {
      creationTime?: string(name='CreationTime'),
      status?: string(name='Status'),
      terminateInstances?: boolean(name='TerminateInstances'),
      maxSpotPrice?: float(name='MaxSpotPrice'),
      fleetId?: string(name='FleetId'),
      state?: string(name='State'),
      launchTemplateId?: string(name='LaunchTemplateId'),
      validFrom?: string(name='ValidFrom'),
      fleetName?: string(name='FleetName'),
      launchTemplateVersion?: string(name='LaunchTemplateVersion'),
      terminateInstancesWithExpiration?: boolean(name='TerminateInstancesWithExpiration'),
      regionId?: string(name='RegionId'),
      validUntil?: string(name='ValidUntil'),
      fleetType?: string(name='FleetType'),
      excessCapacityTerminationPolicy?: string(name='ExcessCapacityTerminationPolicy'),
      launchTemplateConfigs?: {
        launchTemplateConfig?: [ 
        {
          VSWitchId?: string(name='VSWitchId'),
          maxPrice?: float(name='MaxPrice'),
          priority?: float(name='Priority'),
          weightedCapacity?: float(name='WeightedCapacity'),
          instanceType?: string(name='InstanceType'),
        }
      ](name='LaunchTemplateConfig')
      }(name='launchTemplateConfigs'),
      spotOptions?: {
        instancePoolsToUseCount?: int32(name='InstancePoolsToUseCount'),
        allocationStrategy?: string(name='AllocationStrategy'),
        instanceInterruptionBehavior?: string(name='InstanceInterruptionBehavior'),
      }(name='SpotOptions'),
      onDemandOptions?: {
        allocationStrategy?: string(name='AllocationStrategy'),
      }(name='OnDemandOptions'),
      targetCapacitySpecification?: {
        spotTargetCapacity?: float(name='SpotTargetCapacity'),
        onDemandTargetCapacity?: float(name='OnDemandTargetCapacity'),
        fillGapWithOnDemand?: boolean(name='FillGapWithOnDemand'),
        defaultTargetCapacityType?: string(name='DefaultTargetCapacityType'),
        totalTargetCapacity?: float(name='TotalTargetCapacity'),
      }(name='TargetCapacitySpecification'),
    }
  ](name='Fleet')
  }(name='Fleets'),
}

model DescribeFleetsResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeFleetsResponseBody(name='body'),
}

async function describeFleets(request: DescribeFleetsRequest): DescribeFleetsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeFleets', 'POST', 'undefined', 'json', false, 'none', request);
}

model DescribeBandwidthLimitationRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  regionId?: string(name='RegionId', description='The ID of the destination region. You can call [DescribeRegions](~~ 25609 ~~) to view the latest region list.', position='Query'),
  operationType?: string(name='OperationType', description='You can call this operation to query the limits of public network bandwidth. Valid values:

-Upgrade: upgrades the Internet bandwidth.
-Downgrade: Downgrade the Internet bandwidth.
-Create: Create an ECS instance.

Default value: Create', position='Query'),
  ownerId?: long(name='OwnerId', description='The ID of the RAM user.', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', description='The ID of the resource master account, that is, the UID.', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='The account name of the resource master account.', position='Query'),
  instanceType?: string(name='InstanceType', description='The instance type. For more information, see [instance type family](~~ 25378 ~~).

> This parameter is required.', position='Query'),
  resourceId?: string(name='ResourceId', description='The ID of the resource.

> If you set the parameter OperationType to Upgrade or Downgrade, the parameter ResourceId is required.', position='Query'),
  instanceChargeType?: string(name='InstanceChargeType', description='The billing method of the instance. For more information, see [billing Overview](~~ 25398 ~~). Valid values:

-PrePaid: Subscription
-PostPaid: pay-as-you-go

Default value: PostPaid', position='Query'),
  spotStrategy?: string(name='SpotStrategy', description='The preemptible policy of the pay-as-you-go instance. Valid values:

-NoSpot: a pay-as-you-go instance.
-SpotWithPriceLimit: sets the maximum price for preemptible instances.
-SpotAsPriceGo: The system automatically bids at the highest pay-as-you-go price.

Default value: NoSpot

> The parameter InstanceChargeType is valid only when the parameter PostPaid is set to SpotStrategy.', position='Query'),
}

model DescribeBandwidthLimitationResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.'),
  bandwidths?: {
    bandwidth?: [ 
    {
      internetChargeType?: string(name='InternetChargeType', description='The billing method of the Internet bandwidth. Valid values:

-PayByBandwidth: pay-by-bandwidth.
-PayByTraffic: pay by traffic.'),
      max?: int32(name='Max', description='The maximum public bandwidth.'),
      min?: int32(name='Min', description='The minimum public bandwidth.'),
      unit?: string(name='Unit', description='The unit of Internet bandwidth.'),
    }
  ](name='Bandwidth')
  }(name='Bandwidths', description='A collection of Internet bandwidth limits.'),
}

model DescribeBandwidthLimitationResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeBandwidthLimitationResponseBody(name='body'),
}

async function describeBandwidthLimitation(request: DescribeBandwidthLimitationRequest): DescribeBandwidthLimitationResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeBandwidthLimitation', 'POST', 'undefined', 'json', false, 'none', request);
}

model ModifyEipAddressAttributeRequest {
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  allocationId?: string(name='AllocationId', position='Query'),
  bandwidth?: string(name='Bandwidth', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
}

model ModifyEipAddressAttributeResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyEipAddressAttributeResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyEipAddressAttributeResponseBody(name='body'),
}

async function modifyEipAddressAttribute(request: ModifyEipAddressAttributeRequest): ModifyEipAddressAttributeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyEipAddressAttribute', 'POST', 'undefined', 'json', false, 'none', request);
}

model ModifySecurityGroupAttributeRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='The account name of the resource master account.', position='Query'),
  ownerId?: long(name='OwnerId', description='The ID of the RAM user.', position='Query'),
  regionId?: string(name='RegionId', description='The ID of the region. You can call [DescribeRegions](~~ 25609 ~~) to view the latest region list.', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', description='The ID of the resource master account, that is, the UID.', position='Query'),
  securityGroupId?: string(name='SecurityGroupId', description='The ID of the security group.', position='Query'),
  securityGroupName?: string(name='SecurityGroupName', description='The name of the security group. The description must be 2 to 128 characters in length. It must start with a letter and cannot start with "http:// "or "https. It can contain numbers, colons (:), underscores (_), and hyphens (-).

Default value: Null.', position='Query'),
  description?: string(name='Description', description='The description of the security group. The description must be 2 to 256 characters in length and cannot start with "http:// "or "https.

Default value: Null.', position='Query'),
}

model ModifySecurityGroupAttributeResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.'),
}

model ModifySecurityGroupAttributeResponse = {
  headers: map[string]string(name='headers'),
  body: ModifySecurityGroupAttributeResponseBody(name='body'),
}

async function modifySecurityGroupAttribute(request: ModifySecurityGroupAttributeRequest): ModifySecurityGroupAttributeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifySecurityGroupAttribute', 'POST', 'undefined', 'json', false, 'none', request);
}

model ModifyInstanceAutoReleaseTimeRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='The account name of the resource master account.', position='Query'),
  ownerId?: long(name='OwnerId', description='The ID of the RAM user.', position='Query'),
  instanceId?: string(name='InstanceId', description='The ID of the ECS instance to be automatically released.', position='Query'),
  regionId?: string(name='RegionId', description='The ID of the region to which the instance belongs. You can call [DescribeRegions](~~ 25609 ~~) to view the latest region list.', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', description='The ID of the resource master account, that is, the UID.', position='Query'),
  autoReleaseTime?: string(name='AutoReleaseTime', description='The automatic release time. The time follows the [ISO8601](~~ 25696 ~~) standard and uses UTC +0. The format is yyyy-MM-ddTHH:mm:ssZ.

-If the value of seconds is not "00", it is automatically set to the beginning of the current minute ("mm").

-The minimum release time is half an hour later than the current time.

-The maximum release time cannot exceed three years.

If you do not specify the "AutoReleaseTime" parameter, the auto release feature is disabled and the ECS instance is no longer released.', position='Query'),
}

model ModifyInstanceAutoReleaseTimeResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.'),
}

model ModifyInstanceAutoReleaseTimeResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyInstanceAutoReleaseTimeResponseBody(name='body'),
}

async function modifyInstanceAutoReleaseTime(request: ModifyInstanceAutoReleaseTimeRequest): ModifyInstanceAutoReleaseTimeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyInstanceAutoReleaseTime', 'POST', 'undefined', 'json', false, 'none', request);
}

model DeleteNatGatewayRequest {
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  natGatewayId?: string(name='NatGatewayId', position='Query'),
}

model DeleteNatGatewayResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteNatGatewayResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteNatGatewayResponseBody(name='body'),
}

async function deleteNatGateway(request: DeleteNatGatewayRequest): DeleteNatGatewayResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteNatGateway', 'POST', 'undefined', 'json', false, 'none', request);
}

model DescribeZonesRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  verbose?: boolean(name='Verbose', position='Query'),
  regionId?: string(name='RegionId', description='The region ID of the zone. You can call [DescribeRegions](~~ 25609 ~~) to view the latest region list.', position='Query'),
  instanceChargeType?: string(name='InstanceChargeType', description='The billing method of resources in the zone. For more information, see [billing Overview](~~ 25398 ~~). Valid values:

-PrePaid: Subscription
-PostPaid (default): Pay-as-you-go', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='The account name of the resource master account.', position='Query'),
  spotStrategy?: string(name='SpotStrategy', description='The bidding policy of the pay-as-you-go instance. You can specify this parameter when the InstanceChargeType is PostPaid. For more information, see [preemptible instances](~~ 52088 ~~). Valid values:

-NoSpot (default): a pay-as-you-go instance.
-SpotWithPriceLimit: sets the maximum price for preemptible instances.
-SpotAsPriceGo: The system automatically bids at the highest pay-as-you-go price.
', position='Query'),
  ownerId?: long(name='OwnerId', description='The ID of the RAM user.', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', description='The ID of the resource master account, that is, the UID.', position='Query'),
  acceptLanguage?: string(name='AcceptLanguage', description='The returned results are filtered based on Chinese, English, and Japanese. For more information, see [RFC7231](https://tools.ietf.org/html/rfc7231). Valid values:

-zh-CN
-en-US
-ja

Default value: zh-CN', position='Query'),
}

model DescribeZonesResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.'),
  zones?: {
    zone?: [ 
    {
      zoneId?: string(name='ZoneId', description='The ID of the zone.'),
      localName?: string(name='LocalName', description='The local language name of the zone.'),
      availableResources?: {
        resourcesInfo?: [ 
        {
          ioOptimized?: boolean(name='IoOptimized', description='Indicates whether the instance is I/O optimized.'),
          systemDiskCategories?: {
            supportedSystemDiskCategory?: [ string ](name='supportedSystemDiskCategory')
          }(name='SystemDiskCategories'),
          instanceGenerations?: {
            supportedInstanceGeneration?: [ string ](name='supportedInstanceGeneration')
          }(name='InstanceGenerations'),
          dataDiskCategories?: {
            supportedDataDiskCategory?: [ string ](name='supportedDataDiskCategory')
          }(name='DataDiskCategories'),
          instanceTypes?: {
            supportedInstanceType?: [ string ](name='supportedInstanceType')
          }(name='InstanceTypes'),
          instanceTypeFamilies?: {
            supportedInstanceTypeFamily?: [ string ](name='supportedInstanceTypeFamily')
          }(name='InstanceTypeFamilies'),
          networkTypes?: {
            supportedNetworkCategory?: [ string ](name='supportedNetworkCategory')
          }(name='NetworkTypes'),
        }
      ](name='ResourcesInfo')
      }(name='AvailableResources', description='The specific resources that can be created, ResourcesInfo array.'),
      availableResourceCreation?: {
        resourceTypes?: [ string ](name='ResourceTypes')
      }(name='AvailableResourceCreation'),
      dedicatedHostGenerations?: {
        dedicatedHostGeneration?: [ string ](name='DedicatedHostGeneration')
      }(name='DedicatedHostGenerations'),
      availableInstanceTypes?: {
        instanceTypes?: [ string ](name='InstanceTypes')
      }(name='AvailableInstanceTypes'),
      availableDiskCategories?: {
        diskCategories?: [ string ](name='DiskCategories')
      }(name='AvailableDiskCategories'),
      availableDedicatedHostTypes?: {
        dedicatedHostType?: [ string ](name='DedicatedHostType')
      }(name='AvailableDedicatedHostTypes'),
      availableVolumeCategories?: {
        volumeCategories?: [ string ](name='VolumeCategories')
      }(name='AvailableVolumeCategories'),
    }
  ](name='Zone')
  }(name='Zones', description='A collection of data center information zones.'),
}

model DescribeZonesResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeZonesResponseBody(name='body'),
}

/**
 * ## API description

DescribeZones query only the list of zones provided by Alibaba Cloud and return a small amount of inventory information. We recommend that you use [DescribeAvailableResource](~~ 66186 ~~) to query the instance types and disk types that can be purchased in a specific zone.
 */
async function describeZones(request: DescribeZonesRequest): DescribeZonesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeZones', 'POST', 'undefined', 'json', false, 'none', request);
}

model DeactivateRouterInterfaceRequest {
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  routerInterfaceId?: string(name='RouterInterfaceId', position='Query'),
}

model DeactivateRouterInterfaceResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeactivateRouterInterfaceResponse = {
  headers: map[string]string(name='headers'),
  body: DeactivateRouterInterfaceResponseBody(name='body'),
}

async function deactivateRouterInterface(request: DeactivateRouterInterfaceRequest): DeactivateRouterInterfaceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeactivateRouterInterface', 'POST', 'undefined', 'json', false, 'none', request);
}

model DescribeAccessPointsRequest {
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  type?: string(name='Type', position='Query'),
  pageNumber?: int32(name='PageNumber', position='Query'),
  pageSize?: int32(name='PageSize', position='Query'),
  filter?: [ 
    {
      key?: string(name='Key'),
      value?: [ string ](name='Value'),
    }
  ](name='Filter', position='Query'),
}

model DescribeAccessPointsResponseBody = {
  requestId?: string(name='RequestId'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  totalCount?: int32(name='TotalCount'),
  accessPointSet?: {
    accessPointType?: [ 
    {
      status?: string(name='Status'),
      type?: string(name='Type'),
      hostOperator?: string(name='HostOperator'),
      description?: string(name='Description'),
      attachedRegionNo?: string(name='AttachedRegionNo'),
      name?: string(name='Name'),
      accessPointId?: string(name='AccessPointId'),
      location?: string(name='Location'),
    }
  ](name='AccessPointType')
  }(name='AccessPointSet'),
}

model DescribeAccessPointsResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeAccessPointsResponseBody(name='body'),
}

async function describeAccessPoints(request: DescribeAccessPointsRequest): DescribeAccessPointsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeAccessPoints', 'POST', 'undefined', 'json', false, 'none', request);
}

model CreateCommandRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  regionId?: string(name='RegionId', description='The ID of the region. You can call [DescribeRegions](~~ 25609 ~~) to view the latest region list.', position='Query'),
  workingDir?: string(name='WorkingDir', description='The directory where the command you created runs in the ECS instance.

Default value:
-Linux instance: the root user of the administrator is in the home directory, specifically the/root" directory.
-Windows instance: The Directory of the cloud assistant client process, for example, "C:WindowsSystem32 ".', position='Query'),
  commandContent?: string(name='CommandContent', description='The base64-encoded content of the command.

-The value of this parameter must be base64-encoded before transmission. The size of the script cannot exceed 16kB after base64-encoded.
-You can use custom parameters to specify the parameter "EnableParameter = true:
-Custom parameters are defined in the format of "} ". Spaces and line breaks before and after parameter names in "}" are ignored.
-The number of custom parameters cannot exceed 20.
-Custom parameter names can be combined a-zA-Z0-9-_. Other characters are not supported. Parameter names are case insensitive.
-A single parameter name cannot exceed 64 bytes.', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='The account name of the resource master account.', position='Query'),
  ownerId?: long(name='OwnerId', description='The ID of the RAM user.', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', description='The ID of the resource master account, that is, the UID.', position='Query'),
  description?: string(name='Description', description='The description of the command. The full character set is supported. A maximum of 512 characters are allowed.', position='Query'),
  enableParameter?: boolean(name='EnableParameter', description='Indicates whether the created Command uses custom parameters.

Default value: false', position='Query'),
  type?: string(name='Type', description='The type of the command. Valid values:

-RunBatScript: Creates a Bat script that runs in the Windows instance.
-RunPowerShellScript: Creates a Windows script that runs in the PowerShell instance.
-RunShellScript: Creates a Shell script that runs on a Linux instance.
', position='Query'),
  timeout?: long(name='Timeout', description='The maximum timeout period for a command to be executed on an ECS instance. Unit: seconds. A timeout occurs when the command you created cannot be run for some reason. After a timeout, the command process is forcibly terminated, that is, the PID of the command is canceled.

Default value: 60', position='Query'),
  name?: string(name='Name', description='The name of the command. The full character set is supported. A maximum of 128 characters are allowed.', position='Query'),
}

model CreateCommandResponseBody = {
  commandId?: string(name='CommandId', description='The ID of the command.'),
  requestId?: string(name='RequestId', description='The ID of the request.'),
}

model CreateCommandResponse = {
  headers: map[string]string(name='headers'),
  body: CreateCommandResponseBody(name='body'),
}

/**
 * ## API description

-You can create the following types of commands:

-Windows the Bat script (RunBatScript) applicable to the instance.

-Windows the PowerShell script for the instance (RunPowerShellScript).

-The Shell script (RunShellScript) applicable to Linux instances.

-You can specify the parameter TimeOut to set the maximum TimeOut period when a command is executed in an ECS instance. After the command execution times out, the [cloud assistant client](~~ 64921 ~~) the command process is forcibly terminated, that is, the PID of the command is canceled.

-For a single execution, the execution status ([InvokeRecordStatus](~~ 64845 ~~)) of the specified ECS instance changes to Failed after the execution times out.

-For periodic execution:

-The timeout period for periodic execution is valid for each execution record.

-After an execution times out, the status of the execution record ([InvokeRecordStatus](~~ 64845 ~~)) changes to Failed.

-Whether the last execution times out does not affect the next execution.

-<props = "china"> You can keep up to 100 cloud assistant commands in a region. You can also [submit a ticket](https://selfservice.console.aliyun.com/ticket/createIndex.htm) to adjust the retention quota. </props>

-<props = "intl"> You can keep up to 100 cloud assistant commands in a region. You can also [submit a ticket](https://workorder-intl.console.aliyun.com/#/ticket/createIndex) to adjust the retention quota. </props>

-<props = "partner"> You can keep up to 100 cloud assistant commands in a region. You can also open a ticket to adjust the quota. </props>

-You can specify the execution path for the command by specifying the parameter WorkingDir. For Linux instances, the root user of the administrator is in the home directory by default, which is the/root" directory. For Windows instances, the default directory of the cloud assistant client process is C:WindowsSystem32.

-You can enable custom parameters by specifying EnableParameter = true. When setting CommandContent, you can use {{parameter}} to represent custom parameters. When running the command ([InvokeCommand](~~ 64841 ~~)), the key-value pair of the custom parameter. For example, when you create a command, you create the "echo {{name}}"command. When you InvokeCommand the command, you pass in the key-value pair"<name, Jack>"through the Parameters parameter". The custom parameters are automatically replaced by the command. You can obtain a new command and run the "echo Jack" command in the instance ".
 */
async function createCommand(request: CreateCommandRequest): CreateCommandResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateCommand', 'POST', 'undefined', 'json', false, 'none', request);
}

model DescribeInstancesFullStatusRequest {
  eventPublishTime?: {
    start?: string(name='Start', description='Query the start time of the event release time. The time follows the [ISO8601](~~ 25696 ~~) standard and uses UTC time. The format is yyyy-MM-ddTHH:mm:ssZ.', position=''),
    end?: string(name='End', description='Query the end time of the event release time. The time follows the [ISO8601](~~ 25696 ~~) standard and uses UTC time. The format is yyyy-MM-ddTHH:mm:ssZ.', position=''),
  }(name='EventPublishTime'),
  notBefore?: {
    start?: string(name='Start', description='Query the start time of the scheduled event execution time. The time follows the [ISO8601](~~ 25696 ~~) standard and uses UTC time. The format is yyyy-MM-ddTHH:mm:ssZ.', position=''),
    end?: string(name='End', description='Query the end time of the scheduled event execution time. The time follows the [ISO8601](~~ 25696 ~~) standard and uses UTC time. The format is yyyy-MM-ddTHH:mm:ssZ.', position=''),
  }(name='NotBefore'),
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  regionId?: string(name='RegionId', description='The region ID of the instance. You can call [DescribeRegions](~~ 25609 ~~) to view the latest region list.', position='Query'),
  ownerId?: long(name='OwnerId', description='The ID of the RAM user.', position='Query'),
  eventId?: [ string ](name='EventId', description='One or more event IDs. Valid values of N: 1 to 100. Multiple values are in the form of duplicate lists.', position='Query'),
  status?: string(name='Status', description='The lifecycle status of the instance. Valid values:
-Starting: Starting
-Running: Running
-Stopped: Stopped
', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', description='The ID of the resource master account, that is, the UID.', position='Query'),
  eventType?: string(name='EventType', description='The type of an event. EventType parameter is valid only when the InstanceEventType.N parameter is not specified. Valid values:

-SystemMaintenance.Reboot: The instance is restarted due to system maintenance.
-SystemFailure.Reboot: The instance is restarted due to a system error.
-InstanceFailure.Reboot: The instance is restarted due to an instance error.
-InstanceExpiration.Stop: the instance is stopped because the subscription period expires.
-InstanceExpiration.Delete: the instance is released because the subscription period expires.
-AccountUnbalanced.Stop: the pay-as-you-go instance is stopped due to an overdue payment.
-AccountUnbalanced.Delete: the pay-as-you-go instance is released due to an overdue payment.
', position='Query'),
  pageNumber?: int32(name='PageNumber', description='The page number of the query result. Value range: positive integer

Default value: 1.', position='Query'),
  healthStatus?: string(name='HealthStatus', description='The health status of the instance. Valid values:

-Impaired: Service corruption
-Warning: service degradation
-Maintaining: System Maintenance
-Initializing: Initializing
-InsufficientData: insufficient data
-NotApplicable: not applicable

The preceding parameter values are case sensitive.', position='Query'),
  instanceId?: [ string ](name='InstanceId', description='The ID of one or more instances. Valid values of N: 1 to 100. Multiple values are in the form of duplicate lists.', position='Query'),
  pageSize?: int32(name='PageSize', description='The number of entries to return on each page. Valid values: 1 to 100.

Default value: 10.', position='Query'),
  instanceEventType?: [ string ](name='InstanceEventType', description='The type of one or more events. Valid values of N: 1 to 30. Multiple values are in the form of duplicate lists. Valid values:
-SystemMaintenance.Reboot: The instance is restarted due to system maintenance.
-SystemFailure.Reboot: The instance is restarted due to a system error.
-InstanceFailure.Reboot: The instance is restarted due to an instance error.
-InstanceExpiration.Stop: the instance is stopped because the subscription period expires.
-InstanceExpiration.Delete: the instance is released because the subscription period expires.
-AccountUnbalanced.Stop: the pay-as-you-go instance is stopped due to an overdue payment.
-AccountUnbalanced.Delete: the pay-as-you-go instance is released due to an overdue payment.', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='The account name of the resource master account.', position='Query'),
}

model DescribeInstancesFullStatusResponseBody = {
  pageSize?: int32(name='PageSize', description='The size of each page.'),
  requestId?: string(name='RequestId', description='The ID of the request.'),
  pageNumber?: int32(name='PageNumber', description='The page number.'),
  totalCount?: int32(name='TotalCount', description='The total number of entries.'),
  instanceFullStatusSet?: {
    instanceFullStatusType?: [ 
    {
      instanceId?: string(name='InstanceId', description='The ID of the instance.'),
      scheduledSystemEventSet?: {
        scheduledSystemEventType?: [ 
        {
          eventPublishTime?: string(name='EventPublishTime', description='The time when the event was published. Use UTC +0.'),
          eventId?: string(name='EventId', description='The ID of the instance event.'),
          notBefore?: string(name='NotBefore', description='The scheduled execution time of the event, in UTC +0.'),
          impactLevel?: string(name='ImpactLevel', description='The impact level.'),
          reason?: string(name='Reason', description='The cause of the system event.'),
          eventCycleStatus?: {
            name?: string(name='Name', description='The name of the event status.'),
            code?: int32(name='Code', description='The event status code.'),
          }(name='EventCycleStatus', description='The status of the event.'),
          eventType?: {
            name?: string(name='Name', description='The name of the event type.'),
            code?: int32(name='Code', description='The code of the event type.'),
          }(name='EventType', description='The type of the event.'),
          extendedAttribute?: {
            device?: string(name='Device', description='The name of the local disk device.'),
            diskId?: string(name='DiskId', description='The ID of the local disk.'),
            inactiveDisks?: {
              inactiveDisk?: [ 
              {
                creationTime?: string(name='CreationTime', description='The time when the disk or local disk was created. The time follows the [ISO8601](~~ 25696 ~~) standard in UTC. The format is yyyy-MM-ddTHH:mm:ssZ.'),
                deviceSize?: string(name='DeviceSize', description='The size of the cloud disk or local disk. Unit: GiB.'),
                deviceCategory?: string(name='DeviceCategory', description='The type of the cloud disk or local disk. Possible values:
-cloud: basic cloud disk
-cloud_efficiency: Ultra disk
-cloud_ssd:SSD
-cloud_essd:ESSD
-local_ssd_pro:I/O-intensive local disks
-local_hdd_pro: Throughput-intensive local disks
-ephemeral:(discontinued) local disk
-ephemeral_ssd:(phased out) local SSD'),
                deviceType?: string(name='DeviceType', description='The type of the cloud disk or local disk. Possible values:
-system: system disk
-data: data disk'),
                releaseTime?: string(name='ReleaseTime', description='The release time of the cloud disk or local disk. The time follows the [ISO8601](~~ 25696 ~~) standard in UTC. The format is yyyy-MM-ddTHH:mm:ssZ.'),
              }
            ](name='InactiveDisk')
            }(name='InactiveDisks', description='The information about the inactive or local disks that have been released but need to be cleaned.'),
          }(name='ExtendedAttribute', description='Extended properties of local disk instance system events.'),
        }
      ](name='ScheduledSystemEventType')
      }(name='ScheduledSystemEventSet', description='The array of system events in the system plan.'),
      status?: {
        name?: string(name='Name', description='The name of the instance lifecycle status.'),
        code?: int32(name='Code', description='The lifecycle status code of the instance.'),
      }(name='Status', description='The lifecycle status of the instance.'),
      healthStatus?: {
        name?: string(name='Name', description='The name of the health status.'),
        code?: int32(name='Code', description='The health status code.'),
      }(name='HealthStatus', description='The health status of the instance.'),
    }
  ](name='InstanceFullStatusType')
  }(name='InstanceFullStatusSet', description='The full-state array of the instance.'),
}

model DescribeInstancesFullStatusResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeInstancesFullStatusResponseBody(name='body'),
}

/**
 * ## API description

The returned results include instance system events in the instance status and to be executed (Scheduled) status.

If you specify a time period, events are filtered based on the time period.
 */
async function describeInstancesFullStatus(request: DescribeInstancesFullStatusRequest): DescribeInstancesFullStatusResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeInstancesFullStatus', 'POST', 'undefined', 'json', false, 'none', request);
}

model ReleaseEipAddressRequest {
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  allocationId?: string(name='AllocationId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
}

model ReleaseEipAddressResponseBody = {
  requestId?: string(name='RequestId'),
}

model ReleaseEipAddressResponse = {
  headers: map[string]string(name='headers'),
  body: ReleaseEipAddressResponseBody(name='body'),
}

async function releaseEipAddress(request: ReleaseEipAddressRequest): ReleaseEipAddressResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ReleaseEipAddress', 'POST', 'undefined', 'json', false, 'none', request);
}

model DescribeVSwitchesRequest {
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  vpcId?: string(name='VpcId', position='Query'),
  vSwitchId?: string(name='VSwitchId', position='Query'),
  zoneId?: string(name='ZoneId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  isDefault?: boolean(name='IsDefault', position='Query'),
  pageNumber?: int32(name='PageNumber', position='Query'),
  pageSize?: int32(name='PageSize', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
}

model DescribeVSwitchesResponseBody = {
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  pageNumber?: int32(name='PageNumber'),
  totalCount?: int32(name='TotalCount'),
  vSwitches?: {
    vSwitch?: [ 
    {
      creationTime?: string(name='CreationTime'),
      status?: string(name='Status'),
      vpcId?: string(name='VpcId'),
      isDefault?: boolean(name='IsDefault'),
      vSwitchId?: string(name='VSwitchId'),
      cidrBlock?: string(name='CidrBlock'),
      description?: string(name='Description'),
      availableIpAddressCount?: long(name='AvailableIpAddressCount'),
      resourceGroupId?: string(name='ResourceGroupId'),
      zoneId?: string(name='ZoneId'),
      vSwitchName?: string(name='VSwitchName'),
    }
  ](name='VSwitch')
  }(name='VSwitches'),
}

model DescribeVSwitchesResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeVSwitchesResponseBody(name='body'),
}

async function describeVSwitches(request: DescribeVSwitchesRequest): DescribeVSwitchesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeVSwitches', 'POST', 'undefined', 'json', false, 'none', request);
}

model DescribeVpcsRequest {
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  vpcId?: string(name='VpcId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  isDefault?: boolean(name='IsDefault', position='Query'),
  pageNumber?: int32(name='PageNumber', position='Query'),
  pageSize?: int32(name='PageSize', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
}

model DescribeVpcsResponseBody = {
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  pageNumber?: int32(name='PageNumber'),
  totalCount?: int32(name='TotalCount'),
  vpcs?: {
    vpc?: [ 
    {
      creationTime?: string(name='CreationTime'),
      vpcName?: string(name='VpcName'),
      status?: string(name='Status'),
      vpcId?: string(name='VpcId'),
      VRouterId?: string(name='VRouterId'),
      isDefault?: boolean(name='IsDefault'),
      cidrBlock?: string(name='CidrBlock'),
      description?: string(name='Description'),
      regionId?: string(name='RegionId'),
      vSwitchIds?: {
        vSwitchId?: [ string ](name='VSwitchId')
      }(name='VSwitchIds'),
      userCidrs?: {
        userCidr?: [ string ](name='UserCidr')
      }(name='UserCidrs'),
    }
  ](name='Vpc')
  }(name='Vpcs'),
}

model DescribeVpcsResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeVpcsResponseBody(name='body'),
}

async function describeVpcs(request: DescribeVpcsRequest): DescribeVpcsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeVpcs', 'POST', 'undefined', 'json', false, 'none', request);
}

model ExportImageRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='The account name of the resource master account.', position='Query'),
  imageId?: string(name='ImageId', description='The ID of the custom image.', position='Query'),
  regionId?: string(name='RegionId', description='The region ID of the custom image. You can call [DescribeRegions](~~ 25609 ~~) to view the latest region list.', position='Query'),
  imageFormat?: string(name='ImageFormat', description='The export format of the image file. Valid values:
-raw
-vhd
-qcow2
-vmdk
-VDI

Default value: raw', position='Query'),
  ownerId?: long(name='OwnerId', description='The ID of the RAM user.', position='Query'),
  roleName?: string(name='RoleName', description='The name of the RAM role used to export the image.', position='Query'),
  OSSPrefix?: string(name='OSSPrefix', description='The prefix of your OSS Object. It can be 1 to 30 characters in length and can contain digits or letters.', position='Query'),
  OSSBucket?: string(name='OSSBucket', description='Save the OSS bucket of the exported image.', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', description='The ID of the resource master account, that is, the UID.', position='Query'),
}

model ExportImageResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.'),
  taskId?: string(name='TaskId', description='The ID of the image export task.'),
  regionId?: string(name='RegionId', description='The ID of the region.'),
}

model ExportImageResponse = {
  headers: map[string]string(name='headers'),
  body: ExportImageResponseBody(name='body'),
}

/**
 * ## API description

Before exporting an image:

-You must first understand the prerequisites and precautions. For more information, see [export images](~~ 58181 ~~).

-You must authorize the ECS instance to write data to OSS through RAM. The operation instructions are as follows:

1. Create a role: "AliyunECSImageExportDefaultRole" (any other role name is invalid). Set the following role policy for this role:

"""
{
"Statement ": [
{
"Action": "sts:AssumeRole ",
"Effect": "Allow ",
"Principal ": {
"Service ": [
"ecs.aliyuncs.com"
]
}
}
],
"Version": "1"
}
"""

2. Under the role "AliyunECSImageExportDefaultRole", add the default system permission policy: "AliyunECSImageExportRolePolicy", which is the default policy provided by ECS to export images. For more information, see [cloud resource access authorization](https://ram.console.aliyun.com/? spm=5176.2020520101.0.0.64c64df5dfpmdY#/role/authorize? request =%7B% 22requests% 22:%20% 7B%22 request1%22:%20% 7B% 22rolename% 22:%20% 22aliyunecsimageimportdefaultrole% 22,%20% 22templateid% 22:%20% 22ecsimportrole% 22% 7D,%20% 22 request2%22:%20% 7B% 22rolename% 22:%20% 22aliyunecsimageexportdefaultrole% 22,%20% 22templateid% 22:%20% 22ecsexportrole% 22% 7D%7D,%20% 22returnurl% 22:%20% 22https:%2F%2Fecs.console.aliyun.com%2F%22,%20% 22service% 22:%20% 22ECS%22% 7D). You can also create custom policies. The permissions must include:

"""
{
"Version": "1 ",
"Statement ": [
{
"Action ": [
"oss:GetObject ",
"oss:PutObject ",
"oss:DeleteObject ",
"oss:GetBucketLocation ",
"oss:GetBucketInfo ",
"oss:AbortMultipartUpload ",
"oss:ListMultipartUploads ",
"oss:ListParts"
],
"Resource ": "*",
"Effect": "Allow"
}
]
}
"""

After the image is exported:

The custom image is saved in the specified OSS bucket. You can download the custom image. For more information, see [download a custom image file](~~ 31912 ~~).
 */
async function exportImage(request: ExportImageRequest): ExportImageResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ExportImage', 'POST', 'undefined', 'json', false, 'none', request);
}

model DescribeMaintenancePropertyRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  pageNumber?: long(name='PageNumber', position='Query'),
  pageSize?: long(name='PageSize', position='Query'),
  instanceId?: [ string ](name='InstanceId', position='Query'),
}

model DescribeMaintenancePropertyResponseBody = {
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  pageNumber?: int32(name='PageNumber'),
  totalCount?: int32(name='TotalCount'),
  maintenancePropertySet?: {
    maintenanceProperty?: [ 
    {
      endTime?: string(name='EndTime'),
      startTime?: string(name='StartTime'),
      instanceId?: string(name='InstanceId'),
      actionOnMaintenance?: string(name='ActionOnMaintenance'),
    }
  ](name='MaintenanceProperty')
  }(name='MaintenancePropertySet'),
}

model DescribeMaintenancePropertyResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeMaintenancePropertyResponseBody(name='body'),
}

async function describeMaintenanceProperty(request: DescribeMaintenancePropertyRequest): DescribeMaintenancePropertyResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeMaintenanceProperty', 'POST', 'undefined', 'json', false, 'none', request);
}

model ModifyInstanceMaintenanceAttributesRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  maintenanceWindow?: [ 
    {
      endTime?: string(name='EndTime', description='维护时间窗口结束时间。必须为整小时，不允许设置分、秒。开始时间和结束时间必须同时设置，并且结束时间与开始时间需要间隔1~23个整小时。采用UTC +8时区，格式为`HH:mm:ss`。N的取值为1，只支持设置1个时间窗口。'),
      startTime?: string(name='StartTime', description='维护时间窗口开始时间。必须为整小时，不允许设置分、秒。开始时间和结束时间必须同时设置，并且结束时间与开始时间需要间隔1~23个整小时。采用UTC +8时区，格式为`HH:mm:ss`。N的取值为1，只支持设置1个时间窗口。'),
    }
  ](name='MaintenanceWindow', position='Query'),
  regionId?: string(name='RegionId', description='The ID of the region to which the instance belongs. You can call [DescribeRegions](~~ 25609 ~~) to view the latest region list.', position='Query'),
  actionOnMaintenance?: string(name='ActionOnMaintenance', description='The maintenance action. Valid values:

-Stop: the stopped state (that is, the downtime).
-AutoRecover: automatic recovery.
-AutoRedeploy: data disks are damaged due to downtime migration.', position='Query'),
  instanceId?: [ string ](name='InstanceId', description='The ID of the instance. Valid values of N: 1 to 100', position='Query'),
  notifyOnMaintenance?: boolean(name='NotifyOnMaintenance', description='Specifies whether to send event notifications before instance downtime. Valid values:

-true: Sends an event notification.
-false: no event notification is sent.

Default value: false', position='Query'),
}

model ModifyInstanceMaintenanceAttributesResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.'),
}

model ModifyInstanceMaintenanceAttributesResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyInstanceMaintenanceAttributesResponseBody(name='body'),
}

/**
 * ## API description

Modify the maintenance policy of an instance. The policy contains two maintenance attributes.

-Maintenance time window: the specified period of time during which O & M is performed.

-Maintenance action: the action that you specify to handle instance downtime.
 */
async function modifyInstanceMaintenanceAttributes(request: ModifyInstanceMaintenanceAttributesRequest): ModifyInstanceMaintenanceAttributesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyInstanceMaintenanceAttributes', 'POST', 'undefined', 'json', false, 'none', request);
}

model ModifyRouterInterfaceAttributeRequest {
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  routerInterfaceId?: string(name='RouterInterfaceId', position='Query'),
  name?: string(name='Name', position='Query'),
  description?: string(name='Description', position='Query'),
  oppositeInterfaceId?: string(name='OppositeInterfaceId', position='Query'),
  oppositeRouterId?: string(name='OppositeRouterId', position='Query'),
  oppositeRouterType?: string(name='OppositeRouterType', position='Query'),
  oppositeInterfaceOwnerId?: long(name='OppositeInterfaceOwnerId', position='Query'),
  healthCheckSourceIp?: string(name='HealthCheckSourceIp', position='Query'),
  healthCheckTargetIp?: string(name='HealthCheckTargetIp', position='Query'),
}

model ModifyRouterInterfaceAttributeResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyRouterInterfaceAttributeResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyRouterInterfaceAttributeResponseBody(name='body'),
}

async function modifyRouterInterfaceAttribute(request: ModifyRouterInterfaceAttributeRequest): ModifyRouterInterfaceAttributeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyRouterInterfaceAttribute', 'POST', 'undefined', 'json', false, 'none', request);
}

model DescribeVirtualBorderRoutersForPhysicalConnectionRequest {
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  physicalConnectionId?: string(name='PhysicalConnectionId', position='Query'),
  pageNumber?: int32(name='PageNumber', position='Query'),
  pageSize?: int32(name='PageSize', position='Query'),
  filter?: [ 
    {
      key?: string(name='Key'),
      value?: [ string ](name='Value'),
    }
  ](name='Filter', position='Query'),
}

model DescribeVirtualBorderRoutersForPhysicalConnectionResponseBody = {
  requestId?: string(name='RequestId'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  totalCount?: int32(name='TotalCount'),
  virtualBorderRouterForPhysicalConnectionSet?: {
    virtualBorderRouterForPhysicalConnectionType?: [ 
    {
      creationTime?: string(name='CreationTime'),
      circuitCode?: string(name='CircuitCode'),
      recoveryTime?: string(name='RecoveryTime'),
      terminationTime?: string(name='TerminationTime'),
      activationTime?: string(name='ActivationTime'),
      vbrOwnerUid?: long(name='VbrOwnerUid'),
      vbrId?: string(name='VbrId'),
      vlanId?: int32(name='VlanId'),
    }
  ](name='VirtualBorderRouterForPhysicalConnectionType')
  }(name='VirtualBorderRouterForPhysicalConnectionSet'),
}

model DescribeVirtualBorderRoutersForPhysicalConnectionResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeVirtualBorderRoutersForPhysicalConnectionResponseBody(name='body'),
}

async function describeVirtualBorderRoutersForPhysicalConnection(request: DescribeVirtualBorderRoutersForPhysicalConnectionRequest): DescribeVirtualBorderRoutersForPhysicalConnectionResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeVirtualBorderRoutersForPhysicalConnection', 'POST', 'undefined', 'json', false, 'none', request);
}

model CreateDiskRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  advancedFeatures?: string(name='AdvancedFeatures', position='Query'),
  encryptAlgorithm?: string(name='EncryptAlgorithm', position='Query'),
  tag?: [ 
    {
      key?: string(name='key'),
      value?: string(name='Value', description='云盘的标签值。N的取值范围：1~20。一旦传入该值，可以为空字符串。最多支持128个字符，不能以`acs:`开头，不能包含`http://`或者`https://`。'),
    }
  ](name='Tag', position='Query'),
  arn?: [ 
    {
      roleType?: string(name='RoleType'),
      rolearn?: string(name='Rolearn'),
      assumeRoleFor?: long(name='AssumeRoleFor'),
    }
  ](name='Arn', position='Query'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group to which the cloud disk belongs.', position='Query'),
  KMSKeyId?: string(name='KMSKeyId', description='The ID of the KMS key used by the cloud disk.', position='Query'),
  diskName?: string(name='DiskName', description='The name of the disk. The description must be 2 to 128 characters in length. It must start with a letter and cannot start with "http:// "or "https. It can contain numbers, colons (:), underscores (_), and hyphens (-).

Default value: Null.', position='Query'),
  instanceId?: string(name='InstanceId', description='Create a subscription cloud disk and attach it to the specified subscription instance (InstanceId).

-After you set the instance ID, the ResourceGroupId, Tag.N.Key, Tag.N.Value, ClientToken, and KMSKeyId parameters are ignored.
-You cannot specify both ZoneId and InstanceId.

Default value: NULL. A pay-as-you-go cloud disk is created. The location of the cloud disk is determined by the RegionId and ZoneId.', position='Query'),
  storageSetPartitionNumber?: int32(name='StorageSetPartitionNumber', description='The number of partitions in the storage set.', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='The account name of the resource master account.', position='Query'),
  storageSetId?: string(name='StorageSetId', description='The ID of the storage set.

> You can select only one of the parameters for the storage set ("StorageSetId", "StorageSetPartitionNumber") and the parameters for the exclusive block storage cluster ("StorageClusterId"). If you set this parameter at the same time, the operation fails.', position='Query'),
  ownerId?: long(name='OwnerId', description='The ID of the RAM user.', position='Query'),
  diskCategory?: string(name='DiskCategory', description='The type of the data disk. Valid values:
-cloud: basic cloud disk
-cloud_efficiency: Ultra disk
-cloud_ssd:SSD cloud disk
-cloud_essd:ESSD

Default value: cloud', position='Query'),
  regionId?: string(name='RegionId', description='Belongs geo ID. You can call [DescribeRegions](~~ 25609 ~~) to view the latest region list.', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', description='The ID of the resource master account, that is, the UID.', position='Query'),
  zoneId?: string(name='ZoneId', description='Create a pay-as-you-go cloud disk in the specified zone.

-If you do not set InstanceId, ZoneId is required.
-You cannot specify both ZoneId and InstanceId.', position='Query'),
  encrypted?: boolean(name='Encrypted', description='Specifies whether to encrypt the disk. Default value: false', position='Query'),
  description?: string(name='Description', description='The description of the disk. The description must be 2 to 256 characters in length and cannot start with "http:// "or "https.

Default value: Null.', position='Query'),
  clientToken?: string(name='ClientToken', description='Ensure the idempotence of the request. Generate a parameter value from your client. Make sure that the value is unique among different requests. **ClientToken** supports only ASCII characters and cannot exceed 64 characters. For more information, see [how to ensure idempotence](~~ 25693 ~~).', position='Query'),
  snapshotId?: string(name='SnapshotId', description='The snapshot used to create a cloud disk. Snapshots created on or before July 15, 2013 cannot be used to create cloud disks.

The "SnapshotId" parameter and the "Size" parameter have the following limits:

-If the snapshot capacity of the "SnapshotId" parameter is greater than the value of the "Size" parameter, the size of the disk is the size of the specified snapshot.
-If the snapshot size of the "SnapshotId" parameter is smaller than the value of the "Size" parameter, the size of the created disk is the value of the specified "Size" parameter.', position='Query'),
  storageClusterId?: string(name='StorageClusterId', description='The ID of the dedicated block storage cluster. If you want to create a cloud disk in a specified exclusive block storage cluster, specify this parameter. For more information about dedicated block storage clusters, see [what is dedicated block storage cluster](~~ 208883 ~~).

> You can select only one of the parameters for the storage set ("StorageSetId", "StorageSetPartitionNumber") and the parameters for the exclusive block storage cluster ("StorageClusterId"). If you set this parameter at the same time, the operation fails.', position='Query'),
  size?: int32(name='Size', description='The capacity. Unit: GiB. You must specify the parameter value for this parameter. Valid values:

-cloud:5~2,000
-cloud_efficiency:20~32,768
-cloud_ssd:20~32,768
-cloud_essd:
-PL0:40~32,768
-PL1:20~32,768
-PL2:461~32,768
-PL3:1,261~32,768

If you specify the "SnapshotId" parameter, the "SnapshotId" parameter and the "Size" parameter have the following limits:

-If the snapshot capacity of the "SnapshotId" parameter is greater than the value of the "Size" parameter, the size of the disk is the size of the specified snapshot.
-If the snapshot size of the "SnapshotId" parameter is smaller than the value of the "Size" parameter, the size of the created disk is the value of the specified "Size" parameter.', position='Query'),
  performanceLevel?: string(name='PerformanceLevel', description='When creating an ESSD, set the performance level of the disk. Valid values:

-PL0: The maximum random read/write IOPS per disk is 10,000
-PL1: The maximum random read/write IOPS per disk is 50,000
-PL2: The maximum random read/write IOPS per disk is 100,000
-PL3: The maximum random read/write IOPS per disk is 1 million

Default value: PL1

For more information about how to select an ESSD performance level, see [ESSD cloud disk](~~ 122389 ~~).', position='Query'),
  multiAttach?: string(name='MultiAttach', description='Specifies whether to enable the multi-Mount feature. Valid values:

-Disabled: Disabled.
-Enabled: Enabled. Currently, only ESSDS can be set to enabled ".

Default value: Disabled

> disks with multiple mount features only support the pay-as-you-go billing method. Therefore, when "MultiAttach = Enabled ", you cannot set the "InstanceId" parameter at the same time. You can call [AttachDisk](~~ 25515 ~~) to mount a cloud disk after it is created. However, you must note that a cloud disk with multiple Mount functions can only be mounted as a data disk.

<props = "china"> the multi-Mount feature is being invited for testing. To use this feature, [submit a ticket](https://selfservice.console.aliyun.com/ticket/createIndex). </props>

<props = "intl"> the multi-Mount feature is being invited for testing. To use this feature, [submit a ticket](https://workorder-intl.console.aliyun.com/console.htm#/ticket/list). </props>

<props = "partner"> the multi-Mount feature is being invited for testing. If you need to use this feature, submit a ticket. </props>
', position='Query'),
}

model CreateDiskResponseBody = {
  diskId?: string(name='DiskId', description='The ID of the disk.'),
  requestId?: string(name='RequestId', description='The ID of the request.'),
  orderId?: string(name='OrderId', description='The ID of the generated order.

> The Order ID is returned only when a subscription disk is created.'),
}

model CreateDiskResponse = {
  headers: map[string]string(name='headers'),
  body: CreateDiskResponseBody(name='body'),
}

/**
 * ## API description

<props="china">
-Real-name authentication is required to create a cloud disk. Please go to the member information [real-name authentication](https://account.console.aliyun.com/#/auth/home).
-Creating a cloud disk involves resource billing. We recommend that you know the billing method of ECS in advance. For more information, see [billing Overview](~~ 25398 ~~).
-When you create a cloud disk, the automatic snapshot is deleted when the disk is deleted. The value of "DeleteAutoSnapshot" is "true ". You can use [ModifyDiskAttribute](~~ 25517 ~~) to modify this parameter.
-If you do not set the performance level when creating an ESSD, the default value is pl1. You can use [ModifyDiskSpec](~~ 123780 ~~) to modify the performance level of a cloud disk.
-The default billing method for a cloud disk is pay-as-you-go, that is, the default "Portable" attribute is "true ".
-You can enable the multi-Mount feature ("MultiAttach") when creating a cloud disk. We recommend that you understand this feature and its limits. For more information, see [NVMe support for ESSDS](~~ 256487 ~~) and [use multiple Mount functions](~~ 262105 ~~).

</props>

<props="intl">
-Creating a cloud disk involves resource billing. We recommend that you know the billing method of ECS in advance. For more information, see [billing Overview](~~ 25398 ~~).
-When you create a cloud disk, the automatic snapshot is deleted when the disk is deleted. The value of "DeleteAutoSnapshot" is "true ". You can use [ModifyDiskAttribute](~~ 25517 ~~) to modify this parameter.
-If you do not set the performance level when creating an ESSD, the default value is pl1. You can use [ModifyDiskSpec](~~ 123780 ~~) to modify the performance level of a cloud disk.
-The default billing method for a cloud disk is pay-as-you-go, that is, the default "Portable" attribute is "true ".

</props>

<props="partner">
-Creating a cloud disk involves resource billing. We recommend that you know the billing method of ECS in advance. For more information, see [billing Overview](~~ 25398 ~~).
-When you create a cloud disk, the automatic snapshot is deleted when the disk is deleted. The value of "DeleteAutoSnapshot" is "true ". You can use [ModifyDiskAttribute](~~ 25517 ~~) to modify this parameter.
-If you do not set the performance level when creating an ESSD, the default value is pl1. You can use [ModifyDiskSpec](~~ 123780 ~~) to modify the performance level of a cloud disk.
-The default billing method for a cloud disk is pay-as-you-go, that is, the default "Portable" attribute is "true ".

</props>

 */
async function createDisk(request: CreateDiskRequest): CreateDiskResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateDisk', 'POST', 'undefined', 'json', false, 'none', request);
}

model DescribeInstanceTypesRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  instanceTypeFamily?: string(name='InstanceTypeFamily', description='The instance type family to which the instance type belongs. For more information, see [DescribeInstanceTypeFamilies](~~ 25621 ~~).

For more information about instance type families, see [instance type families](~~ 25378 ~~).', position='Query'),
  instanceTypes?: [ string ](name='InstanceTypes', description='The type of the instance. Valid values of N: 1 to 10. If this parameter is not specified, all instance types are queried by default.', position='Query'),
  nextToken?: string(name='NextToken', description='Query the credential (Token). The value of this parameter is the NextToken value returned by the last call to the API. You do not need to set this parameter when you call the API for the first time.', position='Query'),
  maxResults?: long(name='MaxResults', description='The maximum number of entries to return on each page. Maximum Value: 1600

Default value: 1600', position='Query'),
}

model DescribeInstanceTypesResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.'),
  instanceTypes?: {
    instanceType?: [ 
    {
      eniTotalQuantity?: int32(name='EniTotalQuantity', description='> This parameter is being invited for testing and is not currently available.'),
      localStorageCategory?: string(name='LocalStorageCategory', description='The type of the local disk. For more information, see [local disk](~~ 63138 ~~). Possible values:

-local_hdd_pro: SATA HDD local disks for d1ne and d1 instance families.
-local_ssd_pro: local NVMe SSD disks of instance family i2, i2g, i1, ga1, and gn5.'),
      primaryEniQueueNumber?: int32(name='PrimaryEniQueueNumber', description='The default number of queues for the primary Eni.'),
      memorySize?: float(name='MemorySize', description='The memory size. Unit: GiB'),
      localStorageCapacity?: long(name='LocalStorageCapacity', description='The capacity of a local disk attached to the instance. Unit: GiB'),
      instanceFamilyLevel?: string(name='InstanceFamilyLevel', description='The instance type family. Possible values:

-EntryLevel: entry-level (shared type).
-EnterpriseLevel: enterprise-level.
-CreditEntryLevel: the entry level of points. For more information, see [burstable instances](~~ 59977 ~~).'),
      instancePpsRx?: long(name='InstancePpsRx', description='The inbound packet forwarding rate of the intranet. Unit: Pps'),
      eniIpv6AddressQuantity?: int32(name='EniIpv6AddressQuantity', description='The maximum IPv6 address of a single Eni.'),
      maximumQueueNumberPerEni?: int32(name='MaximumQueueNumberPerEni', description='The maximum number of queues for an Eni.'),
      instanceTypeId?: string(name='InstanceTypeId', description='The ID of the instance type.'),
      instanceBandwidthRx?: int32(name='InstanceBandwidthRx', description='The inbound bandwidth limit of the internal network. Unit: kbit/s'),
      secondaryEniQueueNumber?: int32(name='SecondaryEniQueueNumber', description='The default number of queues for secondary Enis.'),
      GPUSpec?: string(name='GPUSpec', description='The type of the GPU.'),
      instanceBandwidthTx?: int32(name='InstanceBandwidthTx', description='The outbound bandwidth limit of the internal network. Unit: kbit/s'),
      queuePairNumber?: int32(name='QueuePairNumber', description='> This parameter is being invited for testing and is not currently available.'),
      eriQuantity?: int32(name='EriQuantity', description='> This parameter is being invited for testing and is not currently available.'),
      GPUAmount?: int32(name='GPUAmount', description='The number of GPUs.'),
      totalEniQueueQuantity?: int32(name='TotalEniQueueQuantity', description='The total number of Eni queues that can be modified for the instance type.'),
      nvmeSupport?: string(name='NvmeSupport', description='Indicates whether the cloud disk attached to the instance type supports NVMe. Possible values:
-required: supported. Indicates that the cloud disk is mounted as NVMe.
-unsupported: not supported. Indicates that the cloud disk is not mounted as NVMe.'),
      diskQuantity?: int32(name='DiskQuantity', description='The maximum number of disks that can be mounted.'),
      initialCredit?: int32(name='InitialCredit', description='The initial vCPU credits of the t5 and t6 burstable instances.'),
      localStorageAmount?: int32(name='LocalStorageAmount', description='The number of local disks attached to the instance.'),
      baselineCredit?: int32(name='BaselineCredit', description='The baseline vCPU computing performance (the sum of all VCPUs) of the t5 and t6 burstable instances.'),
      instancePpsTx?: long(name='InstancePpsTx', description='The outbound packet forwarding rate of the internal network. Unit: Pps'),
      eniPrivateIpAddressQuantity?: int32(name='EniPrivateIpAddressQuantity', description='The maximum number of private IP addresses for a single Eni.'),
      cpuCoreCount?: int32(name='CpuCoreCount', description='The number of vCPU cores.'),
      instanceTypeFamily?: string(name='InstanceTypeFamily', description='The instance type family.'),
      eniQuantity?: int32(name='EniQuantity', description='The maximum number of Enis that can be mounted.'),
      eniTrunkSupported?: boolean(name='EniTrunkSupported', description='> This parameter is being invited for testing and is not currently available.'),
    }
  ](name='InstanceType')
  }(name='InstanceTypes', description='The set of instance types.'),
  nextToken?: string(name='NextToken', description='The Token returned by this call.'),
}

model DescribeInstanceTypesResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeInstanceTypesResponseBody(name='body'),
}

/**
 * ## API description

Before calling an API, note the following:

<props="china">
-We recommend that you set MaxResults and NextToken parameters for paging query. Note: When you call this operation for the first time, you set the MaxResults parameter to limit the number of instance types in the return value, if only the number of queried instance types is returned in one call, NextToken parameter values are returned synchronously. You can call this operation again to set the NextToken parameter value and MaxResults parameter returned by the last call to query instance types by page.

-DescribeInstanceTypes only queries the configuration and performance information of the instance type. To query the instance types that can be purchased in a specific region, use [DescribeAvailableResource](~~ 66186 ~~).

-If you want to use non-visible instance types or special instance types, submit a ticket (https://selfservice.console.aliyun.com/ticket/createIndex.htm) to contact Alibaba Cloud.

</props>

<props="intl">
-We recommend that you set MaxResults and NextToken parameters for paging query. Note: When you call this operation for the first time, you set the MaxResults parameter to limit the number of instance types in the return value, if only the number of queried instance types is returned in one call, NextToken parameter values are returned synchronously. You can call this operation again to set the NextToken parameter value and MaxResults parameter returned by the last call to query instance types by page.

-DescribeInstanceTypes only queries the configuration and performance information of the instance type. To query the instance types that can be purchased in a specific region, use [DescribeAvailableResource](~~ 66186 ~~).

-If you want to use non-visible instance types or special instance types, submit a ticket (https://workorder-intl.console.aliyun.com/#/ticket/createIndex) to contact Alibaba Cloud.

</props>

<props="partner">
-We recommend that you set MaxResults and NextToken parameters for paging query. Note: When you call this operation for the first time, you set the MaxResults parameter to limit the number of instance types in the return value, if only the number of queried instance types is returned in one call, NextToken parameter values are returned synchronously. You can call this operation again to set the NextToken parameter value and MaxResults parameter returned by the last call to query instance types by page.

-DescribeInstanceTypes only queries the configuration and performance information of the instance type. To query the instance types that can be purchased in a specific region, use [DescribeAvailableResource](~~ 66186 ~~).

</props>
 */
async function describeInstanceTypes(request: DescribeInstanceTypesRequest): DescribeInstanceTypesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeInstanceTypes', 'POST', 'undefined', 'json', false, 'none', request);
}

model StartInstancesRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  regionId?: string(name='RegionId', description='The region of the instance. You can call [DescribeRegions](~~ 25609 ~~) to view the latest region list.', position='Query'),
  instanceId?: [ string ](name='InstanceId', description='The ID of the instance. Valid values of N: 1 to 100.', position='Query'),
  dryRun?: boolean(name='DryRun', description='Specifies whether to PreCheck only this request. Valid values:

-true: sends a check request and does not start the instance. Check items include required parameters, request format, and instance status. If the check fails, the corresponding error is returned. If the check succeeds, "DRYRUN.SUCCESS" is returned ".
> If the "BatchOptimization" parameter is set to "SuccessFirst", only "DryRun. SUCCESS" is returned for the PreCheck result of "DRYRUN = true ".

-false: Sends a normal request and starts the instance after the check.

Default value: false', position='Query'),
  batchOptimization?: string(name='BatchOptimization', description='Set the batch operation mode. Valid values:

-AllTogether: In this mode, if all instances are started successfully, a success message is returned. If any instance fails the verification, all instances fail to be started and a failure message is returned.

-SuccessFirst: In this mode, each instance is started separately, and the returned results include the operation results of each instance.

Default value: AllTogether', position='Query'),
}

model StartInstancesResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.'),
  instanceResponses?: {
    instanceResponse?: [ 
    {
      code?: string(name='Code', description='The error code of the instance operation result. The return value 200 is successful. For more information, see the following error codes.'),
      message?: string(name='Message', description='The error message returned for the instance operation. The Success returned value is successful. For more information, see the following error codes.'),
      instanceId?: string(name='InstanceId', description='The ID of the instance.'),
      currentStatus?: string(name='CurrentStatus', description='The current status of the instance.'),
      previousStatus?: string(name='PreviousStatus', description='The status of the instance before the operation.'),
    }
  ](name='InstanceResponse')
  }(name='InstanceResponses', description='An array consisting of InstanceResposne, which returns the status and result of each instance operation.'),
}

model StartInstancesResponse = {
  headers: map[string]string(name='headers'),
  body: StartInstancesResponseBody(name='body'),
}

/**
 * ## API description

When you call this operation, note that:

-The status of the ECS instance must be **stopped**("Stopped").

-When querying ECS instance information, if the returned data contains "{"OperationLocks": {"LockReason" : "security"}}", all operations are prohibited.

-Batch operations are supported. You can set the batch operation mode by using the "BatchOptimization" parameter.
 */
async function startInstances(request: StartInstancesRequest): StartInstancesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'StartInstances', 'POST', 'undefined', 'json', false, 'none', request);
}

model RebootInstanceRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='The account name of the resource master account.', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', description='The ID of the resource master account, that is, the UID.', position='Query'),
  forceStop?: boolean(name='ForceStop', description='Specifies whether to forcibly shut down the instance before restarting it. Valid values:

-true: forced shutdown. This is equivalent to a typical power-off operation. All cached data that is not written to the storage device will be lost.

-false (default): the instance is powered off.', position='Query'),
  ownerId?: long(name='OwnerId', description='The ID of the RAM user.', position='Query'),
  instanceId?: string(name='InstanceId', description='The ID of the instance.', position='Query'),
  dryRun?: boolean(name='DryRun', description='Specifies whether to PreCheck only this request. Valid values:

-true: sends a check request and does not restart the instance. Check items include required parameters, request format, business restrictions, and ECS inventory. If the check fails, the corresponding error is returned. If the check succeeds, the error code "DryRunOperation" is returned ".
-false: Sends a normal request and restarts the instance after passing the check.

Default value: false', position='Query'),
}

model RebootInstanceResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.'),
}

model RebootInstanceResponse = {
  headers: map[string]string(name='headers'),
  body: RebootInstanceResponseBody(name='body'),
}

/**
 * ## API description

-You can restart only ECS instances in the **running**("Running") status.

-Restart the ECS instance and enter the **starting**("Starting") status.

-Force restart ("ForceStop") is supported. Force restart is equivalent to a power-off restart on a traditional server. Data that is not written to disks in the operating system of an instance may be lost.

-When the "OperationLocks" parameter of a locked ECS instance contains "LockReason": "security", the instance cannot be restarted. For more information, see [API actions for security lock](~~ 25695 ~~).
 */
async function rebootInstance(request: RebootInstanceRequest): RebootInstanceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'RebootInstance', 'POST', 'undefined', 'json', false, 'none', request);
}

model InvokeCommandRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='The account name of the resource master account.', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', description='The ID of the resource master account, that is, the UID.', position='Query'),
  username?: string(name='Username', description='The name of the user who runs the command on the ECS instance.

-Linux ECS instances run commands as root users by default.
-Windows the ECS instance of the System. By default, the System user runs the command.

You can also specify other users that already exist in the instance to run commands. It is more secure for ordinary users to run cloud assistant commands. For more information, see [set common users to run cloud assistant commands](~~ 203771 ~~).', position='Query'),
  regionId?: string(name='RegionId', description='The ID of the region. You can call [DescribeRegions](~~ 25609 ~~) to view the latest region list.', position='Query'),
  ownerId?: long(name='OwnerId', description='The ID of the RAM user.', position='Query'),
  commandId?: string(name='CommandId', description='The ID of the command. You can call the [DescribeCommands](~~ 64843 ~~) operation to query all available CommandId.', position='Query'),
  instanceId?: [ string ](name='InstanceId', description='The list of instances to run the command. You can specify a maximum of 50 instance IDs. Valid values of N: 1 to 50.', position='Query'),
  frequency?: string(name='Frequency', description='The execution cycle of a periodic command. The interval between two periodic commands cannot be less than 10 seconds. When the value of "Timed" is "true", "ence" is required.

The value of this parameter follows the Cron expression. For more information, see [set scheduled execution commands](~~ 64769 ~~).', position='Query'),
  timed?: boolean(name='Timed', description='Indicates whether the command is executed periodically.

Default value: false', position='Query'),
  windowsPasswordName?: string(name='WindowsPasswordName', description='The password of the user who runs the command in the Windows instance.

If you want to run a command in a Windows instance as a non-default user (System), you must specify "Username" and this parameter at the same time. To reduce the risk of password leakage, you must host the password in plaintext in the parameter repository of O & M orchestration service. Only the password name is specified here. For more information, see [encryption parameters](~~ 186828 ~~) and [set common users to run cloud assistant commands](~~ 203771 ~~).

> This parameter is not required when you use the root user of a Linux instance or the System user of a Windows instance to run commands.', position='Query'),
  parameters?: map[string]any(name='Parameters', description='The key-value pair of the custom parameter that is passed in when the custom parameter function is enabled. The number of custom parameters ranges from 0 to 10.

The key of-Map cannot be an empty string. It can be up to 64 characters in length.
The value of-Map can be an empty string.
-After the custom parameters and the original command content are encoded in Base64, the total length cannot exceed 16kB.
-The set of custom parameter names must be a subset of the parameter set defined when the command is created. For parameters that are not specified, you can use an empty string instead.

You can disable custom parameters by canceling this parameter.', position='Query'),
  repeatMode?: string(name='RepeatMode', description='Set the command execution method. Valid values:

-Once: run the command immediately.
-Period: run the command regularly. When this parameter is set to **, you must specify both the "** = true" parameter and the "ence" parameter.
-NextRebootOnly: When the instance starts next time, the command is automatically executed.
-EveryReboot: The command is automatically executed each time the instance is started.

Default value:

-If you do not specify the value of the "1" = true" parameter and the "ence" parameter, the default value is "Once ".
-If you specify the "1" = true" parameter value and the "ence" parameter, the parameter is processed as "1" regardless of whether the parameter value has been set.

Note:

-When this parameter is set to "1", "n"bootonly", or "EveryReboot", you can call [StopInvocation](~~ 64838 ~~) to stop the pending or periodic commands.
-If this parameter is set to "1" or "EveryReboot", you can call [DescribeInvocationResults](~~ 64845 ~~) and specify IncludeHistory = true to view the execution history of the command cycle.', position='Query'),
}

model InvokeCommandResponseBody = {
  invokeId?: string(name='InvokeId', description='The ID of the command execution.'),
  requestId?: string(name='RequestId', description='The ID of the request.'),
}

model InvokeCommandResponse = {
  headers: map[string]string(name='headers'),
  body: InvokeCommandResponseBody(name='body'),
}

/**
 * ## API description

-<props = "china"> In an Alibaba Cloud region, you can call InvokeCommand API 5000 times a day. [Submit a ticket](https://selfservice.console.aliyun.com/ticket/createIndex.htm) you can apply to adjust the number of calls quota. </props>

-<props = "intl"> In an Alibaba Cloud region, you can call InvokeCommand API 5000 times a day. [Submit a ticket](https://workorder-intl.console.aliyun.com/#/ticket/createIndex) you can apply to adjust the number of calls quota. </props>

-The following limits apply to the target ECS instance. After multiple ECS instances are selected, if one of the instances does not meet the execution conditions, you need to call the interface again.

-The network type is [VPC](~~ 34217 ~~).

-The status must be running ("Running").

-[Cloud assistant client](~~ 64921 ~~) is installed in advance.

-When you run a command of the PowerShell type, the PowerShell module must be configured for the instance.

-Run the command once ("1" = false").

-Periodic execution ("**= true"):

-The execution is scheduled based on the time frequency specified by the "renewence" parameter. The last execution result does not affect the next execution.

-Set the time base to UTC +0, and the time is based on the system time of the instance. Make sure that the time or time zone of the ECS instance is the same as expected. For more information about time zones, see [set the time zone and NTP service for Linux instances](~~ 92803 ~~), for more information about how to Windows an instance, see [configure Windows instance NTP service](~~ 51890 ~~).

-Command execution may fail due to abnormal status of the target instance, network exception, or cloud assistant client exception. If the command fails to be executed, no execution information is generated.

-When the custom parameter function is enabled when you create a command, you must pass in the custom parameter ("Parameters") when you execute the command.
 */
async function invokeCommand(request: InvokeCommandRequest): InvokeCommandResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'InvokeCommand', 'POST', 'undefined', 'json', false, 'none', request);
}

model DescribeHpcClustersRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', description='The ID of the RAM user.', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', description='The ID of the resource master account, that is, the UID.', position='Query'),
  hpcClusterIds?: string(name='HpcClusterIds', description='The ID of the HPC cluster.
The value can be a JSON Array consisting of multiple HPC cluster IDs. A maximum of 100 IDs can be entered. Separate IDs with commas (,).', position='Query'),
  pageNumber?: int32(name='PageNumber', description='The page number of the HPC cluster list.

Start value: 1

Default value: 1.', position='Query'),
  pageSize?: int32(name='PageSize', description='The number of entries to return on each page.

Maximum Value: 100

Default value: 10', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='The account name of the resource master account.', position='Query'),
  regionId?: string(name='RegionId', description='The ID of the region. You can call [DescribeRegions](~~ 25609 ~~) to view the latest region list.', position='Query'),
  clientToken?: string(name='ClientToken', description='Ensure the idempotence of the request. Generate a parameter value from your client. Make sure that the value is unique among different requests. **ClientToken** supports only ASCII characters and cannot exceed 64 characters. For more information, see [how to ensure idempotence](~~ 25693 ~~).', position='Query'),
}

model DescribeHpcClustersResponseBody = {
  pageSize?: int32(name='PageSize', description='The number of entries to return on each page.'),
  requestId?: string(name='RequestId', description='The ID of the request.'),
  pageNumber?: int32(name='PageNumber', description='The page number of the HPC cluster list.'),
  totalCount?: int32(name='TotalCount', description='The total number of HPC clusters.'),
  hpcClusters?: {
    hpcCluster?: [ 
    {
      hpcClusterId?: string(name='HpcClusterId', description='The ID of the HPC cluster.'),
      name?: string(name='Name', description='The name of the HPC cluster.'),
      description?: string(name='Description', description='The description of the HPC cluster.'),
    }
  ](name='HpcCluster')
  }(name='HpcClusters', description='Returns the HPC cluster information in an array of HpcCluster.'),
}

model DescribeHpcClustersResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeHpcClustersResponseBody(name='body'),
}

async function describeHpcClusters(request: DescribeHpcClustersRequest): DescribeHpcClustersResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeHpcClusters', 'POST', 'undefined', 'json', false, 'none', request);
}

model AcceptInquiredSystemEventRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  regionId?: string(name='RegionId', description='The region ID of the system event. You can call [DescribeRegions](~~ 25609 ~~) to view the latest region list.', position='Query'),
  eventId?: string(name='EventId', description='The ID of the system event.', position='Query'),
}

model AcceptInquiredSystemEventResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.'),
}

model AcceptInquiredSystemEventResponse = {
  headers: map[string]string(name='headers'),
  body: AcceptInquiredSystemEventResponseBody(name='body'),
}

async function acceptInquiredSystemEvent(request: AcceptInquiredSystemEventRequest): AcceptInquiredSystemEventResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'AcceptInquiredSystemEvent', 'POST', 'undefined', 'json', false, 'none', request);
}

model DescribeDedicatedBlockStorageClustersRequest {
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  dedicatedBlockStorageClusterId?: [ string ](name='DedicatedBlockStorageClusterId', position='Query'),
  status?: [ string ](name='Status', position='Query'),
  regionId?: string(name='RegionId', description='The ID of the region. You can call [DescribeRegions](~~ 25609 ~~) to view the latest region list.', position='Query'),
  category?: string(name='Category', description='The type of cloud disk that can be created in the exclusive block storage cluster.

The value can only be cloud_essd, that is, ESSD.', position='Query'),
  zoneId?: string(name='ZoneId', description='The ID of the zone. You can call [DescribeZones](~~ 25610 ~~) to obtain the list of zones.', position='Query'),
  maxResults?: int32(name='MaxResults', description='The maximum number of entries to return on each page. Maximum Value: 500

Default value: 10', position='Query'),
  nextToken?: string(name='NextToken', description='Query the credential (Token). The value of this parameter is the NextToken value returned by the last call to the API. You do not need to set this parameter when you call the API for the first time.', position='Query'),
}

model DescribeDedicatedBlockStorageClustersResponseBody = {
  nextToken?: string(name='NextToken', description='The query credential value returned by this call.'),
  requestId?: string(name='RequestId', description='The ID of the request.'),
  dedicatedBlockStorageClusters?: {
    dedicatedBlockStorageCluster?: [ 
    {
      status?: string(name='Status', description='The status of the dedicated block storage cluster. Possible values:

-Preparing: to be delivered

-Running: Running

-Expired: the cluster expires.

-Offline: unpublish'),
      type?: string(name='Type', description='The performance type of the dedicated block storage cluster. Possible values:

-Standard: Basic. ESSD PL0 disks can be created in exclusive block storage clusters of this type.
-Premium: performance type. ESSD PL1 cloud disks can be created in exclusive block storage clusters of this type.'),
      description?: string(name='Description', description='The description of the dedicated block storage cluster.'),
      expiredTime?: string(name='ExpiredTime', description='The expiration time of the dedicated block storage cluster.'),
      createTime?: string(name='CreateTime', description='The time when the dedicated block storage cluster was created.'),
      zoneId?: string(name='ZoneId', description='The ID of the zone to which the cluster belongs.'),
      category?: string(name='Category', description='The type of cloud disk that can be created in the exclusive block storage cluster.'),
      dedicatedBlockStorageClusterName?: string(name='DedicatedBlockStorageClusterName', description='The name of the dedicated block storage cluster.'),
      dedicatedBlockStorageClusterId?: string(name='DedicatedBlockStorageClusterId', description='The ID of the dedicated block storage cluster.'),
      dedicatedBlockStorageClusterCapacity?: {
        totalCapacity?: long(name='TotalCapacity', description='The total capacity of the current cluster. Unit: GiB.'),
        availableCapacity?: long(name='AvailableCapacity', description='The available capacity of the current cluster. Unit: GiB.'),
      }(name='DedicatedBlockStorageClusterCapacity', description='The storage capacity of the exclusive block storage cluster.'),
    }
  ](name='DedicatedBlockStorageCluster')
  }(name='DedicatedBlockStorageClusters', description='An array consisting of one or more exclusive block storage clusters.'),
}

model DescribeDedicatedBlockStorageClustersResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeDedicatedBlockStorageClustersResponseBody(name='body'),
}

/**
 * ## API description

> The exclusive block storage cluster feature currently supports the China South 2 (Heyuan), Indonesia (Jakarta), and China South 1 (Shenzhen) regions of the financial cloud.

-Request parameters are similar to a filter. The filter is a logical AND (AND) relationship. If a parameter is empty, the filter does not work.

-We recommend that you use the MaxResults and NextToken parameters to query data by page. Note: When querying the homepage by page, you only need to set the MaxResults to limit the number of entries returned. The NextToken in the returned results are used as the credentials for querying subsequent pages. When querying subsequent pages, set the NextToken parameter to the NextToken obtained from the last returned result as the query credential, and set the MaxResults to limit the number of returned entries.

 */
async function describeDedicatedBlockStorageClusters(request: DescribeDedicatedBlockStorageClustersRequest): DescribeDedicatedBlockStorageClustersResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeDedicatedBlockStorageClusters', 'POST', 'undefined', 'json', false, 'none', request);
}

model ModifyInstanceAutoRenewAttributeRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='The account name of the resource master account.', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', description='The ID of the resource master account, that is, the UID.', position='Query'),
  ownerId?: long(name='OwnerId', description='The ID of the RAM user.', position='Query'),
  periodUnit?: string(name='PeriodUnit', description='The unit of the renewal period. Valid values:

-<props="china">Week</props>
-Month (default)
-Year', position='Query'),
  regionId?: string(name='RegionId', description='The ID of the region to which the instance belongs. You can call [DescribeRegions](~~ 25609 ~~) to view the latest region list.', position='Query'),
  instanceId?: string(name='InstanceId', description='The ID of the instance. You can specify a maximum of 100 subscription instances. Separate multiple instance IDs with commas (,).', position='Query'),
  autoRenew?: boolean(name='AutoRenew', description='Indicates whether the instance is automatically renewed before it expires.

Default value: false', position='Query'),
  duration?: int32(name='Duration', description='Set the automatic renewal period of the instance.

-When "Dune" is "Year" (year), the value range of "Duration" is:{"1", "2", "3"}
-When "Dune" is "Month" (month), the value range of "Duration" is:{"1", "2", "3", "6", "12"}
-<props = "china"> when "Dune" is "Week", the value range of "Duration" is:{"1", "2", "3", "4"}</props>', position='Query'),
  renewalStatus?: string(name='RenewalStatus', description='The automatic renewal status of the instance. Valid values:

-AutoRenewal: set to automatic renewal.

-Normal: Cancels automatic renewal.

-NotRenewal: no longer renew. After you specify this value, the system no longer sends expiration reminders, but only sends non-renewal reminders on the third day before expiration. If you no longer renew an ECS instance, you can change it to "Normal" before you renew it or set it to automatic.

> The "RenewalStatus" parameter takes precedence over the "AutoRenew" parameter ". If you do not specify the "RenewalStatus" parameter, the default value is "AutoRenew.', position='Query'),
}

model ModifyInstanceAutoRenewAttributeResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.'),
}

model ModifyInstanceAutoRenewAttributeResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyInstanceAutoRenewAttributeResponseBody(name='body'),
}

/**
 * ## API description

<props = "china"> make sure that you have fully understood the billing method and product pricing of [ECS](https://www.aliyun.com/price/product#/ecs/detail) before using this interface. </props>

<props = "intl"> make sure that you have fully understood the billing method and product pricing of [ECS](https://www.alibabacloud.com/product/ecs#pricing) before using this interface. </props>

-The auto-renewal deduction date is the 9th day before the instance expires. The deduction starts at 08:00:00 UTC +8.

-<props = "china"> If the subscription period of the new instance is one week, the renewal fee will be automatically deducted on the first day of successful creation. </props>

-If the automatic deduction fails on the previous day, the automatic deduction will continue on the next day until the deduction succeeds or the instance expires and is locked nine days later. You only need to ensure that your account balance or credit line is sufficient.

 */
async function modifyInstanceAutoRenewAttribute(request: ModifyInstanceAutoRenewAttributeRequest): ModifyInstanceAutoRenewAttributeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyInstanceAutoRenewAttribute', 'POST', 'undefined', 'json', false, 'none', request);
}

model DescribeVirtualBorderRoutersRequest {
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  pageNumber?: int32(name='PageNumber', position='Query'),
  pageSize?: int32(name='PageSize', position='Query'),
  filter?: [ 
    {
      key?: string(name='Key'),
      value?: [ string ](name='Value'),
    }
  ](name='Filter', position='Query'),
}

model DescribeVirtualBorderRoutersResponseBody = {
  requestId?: string(name='RequestId'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  totalCount?: int32(name='TotalCount'),
  virtualBorderRouterSet?: {
    virtualBorderRouterType?: [ 
    {
      vlanInterfaceId?: string(name='VlanInterfaceId'),
      status?: string(name='Status'),
      creationTime?: string(name='CreationTime'),
      circuitCode?: string(name='CircuitCode'),
      physicalConnectionOwnerUid?: string(name='PhysicalConnectionOwnerUid'),
      localGatewayIp?: string(name='LocalGatewayIp'),
      activationTime?: string(name='ActivationTime'),
      physicalConnectionBusinessStatus?: string(name='PhysicalConnectionBusinessStatus'),
      peeringSubnetMask?: string(name='PeeringSubnetMask'),
      routeTableId?: string(name='RouteTableId'),
      description?: string(name='Description'),
      physicalConnectionStatus?: string(name='PhysicalConnectionStatus'),
      recoveryTime?: string(name='RecoveryTime'),
      terminationTime?: string(name='TerminationTime'),
      peerGatewayIp?: string(name='PeerGatewayIp'),
      name?: string(name='Name'),
      accessPointId?: string(name='AccessPointId'),
      vbrId?: string(name='VbrId'),
      physicalConnectionId?: string(name='PhysicalConnectionId'),
      vlanId?: int32(name='VlanId'),
    }
  ](name='VirtualBorderRouterType')
  }(name='VirtualBorderRouterSet'),
}

model DescribeVirtualBorderRoutersResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeVirtualBorderRoutersResponseBody(name='body'),
}

async function describeVirtualBorderRouters(request: DescribeVirtualBorderRoutersRequest): DescribeVirtualBorderRoutersResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeVirtualBorderRouters', 'POST', 'undefined', 'json', false, 'none', request);
}

model ModifyHpcClusterAttributeRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='The account name of the resource master account.', position='Query'),
  regionId?: string(name='RegionId', description='The ID of the region. You can call [DescribeRegions](~~ 25609 ~~) to view the latest region list.', position='Query'),
  description?: string(name='Description', description='The description of the HPC cluster. The description must be 2 to 256 characters in length and cannot start with http:// or https.

Default value: Null.', position='Query'),
  name?: string(name='Name', description='The name of the HPC cluster. The description must be 2 to 128 characters in length. It must start with a letter and cannot start with http:// or https. It can contain letters, digits, underscores (_), and hyphens (-).

Default value: Null.', position='Query'),
  ownerId?: long(name='OwnerId', description='The ID of the RAM user.', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', description='The ID of the resource master account, that is, the UID.', position='Query'),
  hpcClusterId?: string(name='HpcClusterId', description='The ID of the HPC cluster.', position='Query'),
  clientToken?: string(name='ClientToken', description='Ensure the idempotence of the request. Generate a parameter value from your client. Make sure that the value is unique among different requests. **ClientToken** supports only ASCII characters and cannot exceed 64 characters. For more information, see [how to ensure idempotence](~~ 25693 ~~).', position='Query'),
}

model ModifyHpcClusterAttributeResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.'),
}

model ModifyHpcClusterAttributeResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyHpcClusterAttributeResponseBody(name='body'),
}

async function modifyHpcClusterAttribute(request: ModifyHpcClusterAttributeRequest): ModifyHpcClusterAttributeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyHpcClusterAttribute', 'POST', 'undefined', 'json', false, 'none', request);
}

model DescribeLimitationRequest {
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  limitation?: string(name='Limitation', position='Query'),
}

model DescribeLimitationResponseBody = {
  limitation?: string(name='Limitation'),
  value?: string(name='Value'),
  requestId?: string(name='RequestId'),
}

model DescribeLimitationResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeLimitationResponseBody(name='body'),
}

async function describeLimitation(request: DescribeLimitationRequest): DescribeLimitationResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeLimitation', 'POST', 'undefined', 'json', false, 'none', request);
}

model DescribePriceRequest {
  dataDisk?: [
    {
      size?: int32(name='Size', description='The capacity of the first data disk. Unit: GiB. Valid values:

-cloud:5~2000
-cloud_efficiency:20 to 32768
-cloud_ssd:20 to 32768
-cloud_essd:20 to 32768
-ephemeral_ssd:5 to 800', position=''),
      performanceLevel?: string(name='PerformanceLevel', description='When the first data disk type is ESSD, the performance level is distinguished. This parameter is valid only when "DataDisk.1.Category = cloud_essd. Valid values:

-PL0
-PL1 (default)
-PL2
-PL3', position=''),
      category?: string(name='Category', description='The category of the first data disk. Valid values:

-cloud: basic cloud disk
-cloud_efficiency: Ultra disk
-cloud_ssd:SSD cloud disk
-ephemeral_ssd: local SSD
-cloud_essd:ESSD', position=''),
    }
  ](name='DataDisk'),
  systemDisk?: {
    performanceLevel?: string(name='PerformanceLevel', description='When the system disk type is ESSD, the performance level is distinguished. This parameter is valid only when "SystemDiskCategory = cloud_essd. Valid values:

-PL0
-PL1 (default)
-PL2
-PL3', position=''),
    category?: string(name='Category', description='The type of the system disk. Valid values:

-cloud: basic cloud disk
-cloud_efficiency: Ultra disk
-cloud_ssd:SSD cloud disk
-ephemeral_ssd: local SSD
-cloud_essd:ESSD

Parameter defaults:

-If the InstanceType is a phased-out instance type and the value of "IoOptimized" is "none", the default value of this parameter is "cloud ".
-In other cases, the default value of this parameter is cloud_efficiency ".', position=''),
    size?: int32(name='Size', description='The size of the system disk. Unit: GiB. Valid values: 20 to 500.

Default value: max{40. The size of the image corresponding to the parameter ImageId}.

> the value of this parameter must be greater than or equal to max{20, ImageSize}.', position=''),
  }(name='SystemDisk'),
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  offeringType?: string(name='OfferingType', position='Query'),
  instanceAmount?: int32(name='InstanceAmount', position='Query'),
  scope?: string(name='Scope', position='Query'),
  platform?: string(name='Platform', position='Query'),
  capacity?: int32(name='Capacity', position='Query'),
  instanceCpuCoreCount?: int32(name='InstanceCpuCoreCount', position='Query'),
  isp?: string(name='Isp', position='Query'),
  ownerId?: long(name='OwnerId', description='The ID of the RAM user.', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='The account name of the resource master account.', position='Query'),
  imageId?: string(name='ImageId', description='The ID of the image that you want to load when you start the instance. You can call [DescribeImages](~~ 25534 ~~) to query the available image resources. If this parameter is not specified, the price of the Linux image is queried by default.', position='Query'),
  ioOptimized?: string(name='IoOptimized', description='Indicates whether the instance is I/O optimized. Valid values:

-none: Non-I/O optimized
-optimized:I/O optimized

If the InstanceType is set to [series I](~~ 55263 ~~), the default value is none.

If the InstanceType is not a [series I](~~ 55263 ~~) specification, the default value is optimized.', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', description='The ID of the resource master account, that is, the UID.', position='Query'),
  dedicatedHostType?: string(name='DedicatedHostType', description='The specification of the dedicated host. You can call the [DescribeDedicatedHostTypes](~~ 134240 ~~) API to obtain the latest DDH specifications.', position='Query'),
  regionId?: string(name='RegionId', description='The ID of the region. You can call [DescribeRegions](~~ 25609 ~~) to view the latest region list.', position='Query'),
  resourceType?: string(name='ResourceType', description='The type of the target resource. Valid values:
-instance: queries the latest prices of ECS instances. When the value is "instance", you must specify the "InstanceType" parameter at the same time ".
-disk: queries the latest price list of disks. When the value is "disk", you must specify both the "DataDisk.1. Categore" and "DataDisk.1.Size" parameters ".
-bandwidth: queries the latest bandwidth price list.
-ddh: queries the latest prices of dedicated hosts.
-ElasticityAssurance: queries the price information of the elastic protection service. When the value is "elasticitylifecance", you must specify the "InstanceType" parameter at the same time ".
-CapacityReservation: queries the price of the capacity reservation service. When the value is "CapacityReservation", you must specify the "InstanceType" parameter at the same time ".

Default value: instance
', position='Query'),
  internetChargeType?: string(name='InternetChargeType', description='The billing method of the network bandwidth. Valid values:

-PayByBandwidth: pay-by-bandwidth.
-PayByTraffic: pay by bandwidth traffic.

Default value: PayByTraffic
', position='Query'),
  instanceType?: string(name='InstanceType', description='The type of the instance. When the value of "ResourceType" is "instance", you must specify this parameter at the same time. For more information, see [instance type family](~~ 25378 ~~), or call [DescribeInstanceTypes](~~ 25620 ~~) to obtain the latest specification.
', position='Query'),
  zoneId?: string(name='ZoneId', description='The ID of the zone.', position='Query'),
  internetMaxBandwidthOut?: int32(name='InternetMaxBandwidthOut', description='The maximum outbound Internet bandwidth. Unit: Mbit/s(Megabit per second). Valid values: 0 to 100.

Default value: 0.', position='Query'),
  instanceNetworkType?: string(name='InstanceNetworkType', description='The network type of the instance. Valid values:

-classic: the network type of the instance is Classic network (classic).
-vpc: The network type of the instance is VPC.

Default value: vpc', position='Query'),
  amount?: int32(name='Amount', description='You can call this operation to query the prices of ECS instances with a specific configuration. Valid values: 1 to 1000.

Default value: 1.', position='Query'),
  spotDuration?: int32(name='SpotDuration', description='The retention period of a preemptible instance. Unit: hours. Valid values: 0 to 6.

-The retention period is 2 to 6 and is being invited for testing. If you want to activate the service, submit a ticket.
-If the value is 0, the mode is not protected.

Default value: 1.', position='Query'),
  assuranceTimes?: string(name='AssuranceTimes', description='The total number of elastic guarantees. Set the value to Unlimited. Currently, the Unlimited mode is supported only when the service takes effect.

Default value: Unlimited', position='Query'),
  instanceTypeList?: [ string ](name='InstanceTypeList', description='The instance type. Currently, you can only set a single instance type for unlimited guarantee services.', position='Query'),
  spotStrategy?: string(name='SpotStrategy', description='The preemptible policy of the pay-as-you-go instance. Valid values:
-NoSpot: a pay-as-you-go instance.
-SpotWithPriceLimit: sets the maximum price for preemptible instances.
-SpotAsPriceGo: The system automatically bids at the highest pay-as-you-go price.

Default value: NoSpot

> This parameter is valid only when "PriceUnit = Hour" and "Period =. Because the default value of "PriceUnit" is "Hour", and the default value of "1" is "1", you do not need to set the "PriceUnit" and "1" parameter values when Setting this parameter value.', position='Query'),
  priceUnit?: string(name='PriceUnit', description='Queries the prices of ECS instances in different billing cycles. Valid values:

<props="china">
-Month: the unit of the Month.
-Year: the unit of the price that is billed on a yearly basis.
-Hour (default): The unit of the price that is billed on an hourly basis.
-Week: the unit of the price that is billed on a weekly basis.

</props>

<props="intl">
-Month: the unit of the Month.
-Year: the unit of the price that is billed on a yearly basis.
-Hour (default): The unit of the price that is billed on an hourly basis.

</props>
', position='Query'),
  period?: int32(name='Period', description='The billing duration of the ECS instance. Valid values:

<props="china">
-Valid values: 1 to 9 when the PriceUnit parameter is set to Month.
-Valid values: 1 to 5 when the PriceUnit parameter is set to Year.
-1 when the PriceUnit parameter is set to Hour
-If the PriceUnit parameter is set to Week, valid values: 1 to 4.

</props>

<props="intl">
-Valid values: 1 to 9 when the PriceUnit parameter is set to Month.
-Valid values: 1 to 5 when the PriceUnit parameter is set to Year.
-1 when the PriceUnit parameter is set to Hour

</props>

Default value: 1.


', position='Query'),
}

model DescribePriceResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.'),
  priceInfo?: {
    rules?: {
      rule?: [ 
      {
        description?: string(name='Description', description='The description of the activity rule.'),
        ruleId?: long(name='RuleId', description='The ID of the activity.'),
      }
    ](name='Rule')
    }(name='Rules', description='The activity rule.'),
    price?: {
      originalPrice?: float(name='OriginalPrice', description='Original price.'),
      reservedInstanceHourPrice?: float(name='ReservedInstanceHourPrice', description='The hourly price of Reserved instances that are 0 or partially prepaid.'),
      discountPrice?: float(name='DiscountPrice', description='Discount.'),
      currency?: string(name='Currency', description='The unit of currency.'),
      tradePrice?: float(name='TradePrice', description='The final price, which is the original price minus the discount.'),
      detailInfos?: {
        resourcePriceModel?: [ 
        {
          resource?: string(name='Resource', description='The name of the resource.'),
          originalPrice?: float(name='OriginalPrice', description='Original price.'),
          discountPrice?: float(name='DiscountPrice', description='Discount price.'),
          tradePrice?: float(name='TradePrice', description='The transaction price.'),
        }
      ](name='ResourcePriceModel')
      }(name='DetailInfos', description='The price details.

> the returned value is being invited for testing and is not currently available.'),
    }(name='Price', description='The price.'),
  }(name='PriceInfo', description='The type of Price information, including Price and discount rules.'),
}

model DescribePriceResponse = {
  headers: map[string]string(name='headers'),
  body: DescribePriceResponseBody(name='body'),
}

/**
 * ## API description

-When you query the prices of different types of resources, the required parameters vary as follows:

-When "ResourceType = instance", you must specify the "InstanceType" parameter ".

-When "ResourceType = disk", you must specify both "DataDisk.1. Categore" and "DataDisk.1.Size ". When you query the price of the "disk" resource, only the pay-as-you-go price of the cloud disk is returned. The value of the "PriceUnit" parameter can only be "Hour ".

-When "ResourceType = ddh" is queried, you must specify the "DedicatedHostType" parameter at the same time ".

-When "ResourceType = elasticitylifecance" is queried, you must specify the "InstanceType" parameter at the same time ".

-When "ResourceType = CapacityReservation" is queried, you must specify the "InstanceType" parameter at the same time ".


-When "ResourceType = bandwidth" is queried, only the paybytraffic" price is returned.
-When "ResourceType = instance", you can query the prices of data disks that are less than four.
-The default billing method ("ChargeType") is pay-as-you-go ("PostPaid"). You can specify the "PriceUnit" parameter to query the prices of ECS instances in different billing cycles.




 */
async function describePrice(request: DescribePriceRequest): DescribePriceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribePrice', 'POST', 'undefined', 'json', false, 'none', request);
}

model DeleteDeploymentSetRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='The account name of the resource master account.', position='Query'),
  ownerId?: long(name='OwnerId', description='The ID of the RAM user.', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', description='The ID of the resource master account, that is, the UID.', position='Query'),
  deploymentSetId?: string(name='DeploymentSetId', description='The ID of the deployment set. If an instance still exists in the deployment set, it cannot be deleted.', position='Query'),
  regionId?: string(name='RegionId', description='The ID of the region to which the deployment set belongs. You can call [DescribeRegions](~~ 25609 ~~) to view the latest region list.', position='Query'),
}

model DeleteDeploymentSetResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.'),
}

model DeleteDeploymentSetResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteDeploymentSetResponseBody(name='body'),
}

async function deleteDeploymentSet(request: DeleteDeploymentSetRequest): DeleteDeploymentSetResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteDeploymentSet', 'POST', 'undefined', 'json', false, 'none', request);
}

model DescribeDeploymentSetTopologyRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  networkType?: string(name='NetworkType', position='Query'),
  strategy?: string(name='Strategy', position='Query'),
  deploymentSetName?: string(name='DeploymentSetName', position='Query'),
  granularity?: string(name='Granularity', position='Query'),
  domain?: string(name='Domain', position='Query'),
  deploymentSetId?: string(name='DeploymentSetId', description='The ID of the deployment set.', position='Query'),
  regionId?: string(name='RegionId', description='The ID of the region to which the deployment set belongs. You can call [DescribeRegions](~~ 25609 ~~) to view the latest region list.', position='Query'),
}

model DescribeDeploymentSetTopologyResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.'),
  switchs?: {
    switch?: [ 
    {
      switchId?: string(name='SwitchId', description='The ID of the vSwitch.'),
      hosts?: {
        host?: [ 
        {
          hostId?: string(name='HostId', description='The value of HostId.'),
          instanceIds?: {
            instanceId?: [ string ](name='InstanceId')
          }(name='InstanceIds'),
        }
      ](name='Host')
      }(name='Hosts', description='An array consisting of hosts. HostId and instance ID are returned.'),
    }
  ](name='Switch')
  }(name='Switchs', description='Returns the information about the instance.'),
  racks?: {
    rack?: [ 
    {
      rackId?: string(name='RackId', description='The ID of the rack.'),
    }
  ](name='Rack')
  }(name='Racks', description='Returns the information about the instance.'),
}

model DescribeDeploymentSetTopologyResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeDeploymentSetTopologyResponseBody(name='body'),
}

async function describeDeploymentSetTopology(request: DescribeDeploymentSetTopologyRequest): DescribeDeploymentSetTopologyResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeDeploymentSetTopology', 'POST', 'undefined', 'json', false, 'none', request);
}

model ModifyInstanceVpcAttributeRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='The account name of the resource master account.', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', description='The ID of the resource master account, that is, the UID.', position='Query'),
  instanceId?: string(name='InstanceId', description='The ID of the instance.', position='Query'),
  privateIpAddress?: string(name='PrivateIpAddress', description='The new private IP address.

> "PrivateIpAddress" depends on "VSwitchId". The specified IP address must be in the subnet CIDR block of the vSwitch.

Default value: if this value is not specified, the vSwitch subnet CIDR block is randomly allocated.', position='Query'),
  vSwitchId?: string(name='VSwitchId', description='The ID of the vSwitch.

-If the input ID is the current vSwitch of the instance, the instance does not change the vSwitch.
-If the input ID is a new vSwitch and the parameter "VpcId" is empty, the new and old vswitches must belong to the same zone and VPC.
-If the "VpcId" parameter is not empty, the vSwitch ID specified by this parameter must belong to VpcId and belong to the same zone as the original vSwitch.', position='Query'),
  ownerId?: long(name='OwnerId', description='The ID of the RAM user.', position='Query'),
  securityGroupId?: [ string ](name='SecurityGroupId', description='The ID of the security group to which the instance belongs after the VPC is modified. This parameter must be specified only when the "VpcId" parameter is specified.
-The security group type must be the same.
-The list of security groups to which the instance is modified. It can be one or more. The value range of N in the parameter depends on the limit that the instance can join the security group. For more information, see [limits](~~ 25412 ~~).
-The security group of the VPC ECS instance must belong to the VPC where the "VpcId" belongs.', position='Query'),
  vpcId?: string(name='VpcId', description='The target VPC ID.', position='Query'),
}

model ModifyInstanceVpcAttributeResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.'),
}

model ModifyInstanceVpcAttributeResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyInstanceVpcAttributeResponseBody(name='body'),
}

/**
 * ## API description

When you call an API, the status of the ECS instance must be **stopped**("Stopped").

-When you use this operation to modify the private IP address or vSwitch of an instance, note that:

-The New ECS instance must be restarted to call this operation.
-After a successful modification, the ECS instance must be restarted to call this operation.

-When you use this operation to modify the VPC of an instance, note that:

-**Instance: * *
-ECS instances associated with SLB instances are not supported.
-The status of the instance cannot be locked, pending release, expired, expired, or overdue. For more information, see [instance lifecycle](~~ 25380 ~~).
-The instance cannot be used in other cloud services. For example, an instance cannot be migrated, a VPC cannot be replaced, or a database deployed in the instance cannot be managed by DTS.

-**Network: * *
-Instances with the EIP Eni visible mode or multi-EIP Eni visible mode are not supported.
-You cannot associate an instance with a high-availability virtual IP address (HaVip).
-Instances with custom route tables attached to a vSwitch are not supported.
-Instances with GA enabled are not supported.
-Instances with secondary Enis cannot be bound.
-Instances with IPv6 addresses are not supported.
-Instances with multiple IP addresses in the primary Eni are not supported.
-The vSwitch must belong to the target VPC.
-The vSwitch zones must be the same before and after modification.
-If the private IP address of the primary Eni is specified, the IP address must be within the CIDR block of the vSwitch and available. If this parameter is not specified, the vSwitch is randomly allocated and the number of available IP addresses of the target vSwitch is sufficient.
-If the advanced network feature is enabled for the target VPC, note that some instance families do not support this feature. For more information, see [instance families that do not support high-order VPC features](~~ 163466 ~~).
-The owner account (resource owner) of the target VPC. The target VPC cannot be shared with other accounts (resource users).

-**Security Group (SecurityGroupId.N):* *
-The security group list must belong to the same type.
-The quota of a security group depends on the limits that instances can join the security group. For more information, see [limits](~~ 25412 ~~).
-The VPC to which the security group belongs must be the same as the target VPC.
-You can change the security group type.
When an ECS instance switches between different types of security groups, you must fully understand the differences between the two security group rules to avoid affecting the network of the instance. For more information, see [Security Group Overview](~~ 25387 ~~).
 */
async function modifyInstanceVpcAttribute(request: ModifyInstanceVpcAttributeRequest): ModifyInstanceVpcAttributeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyInstanceVpcAttribute', 'POST', 'undefined', 'json', false, 'none', request);
}

model ModifyDedicatedHostClusterAttributeRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  regionId?: string(name='RegionId', description='The region ID of the DDH cluster. You can call [DescribeRegions](~~ 25609 ~~) to view the latest region list.', position='Query'),
  dedicatedHostClusterId?: string(name='DedicatedHostClusterId', description='The ID of the DDH cluster.', position='Query'),
  dedicatedHostClusterName?: string(name='DedicatedHostClusterName', description='The name of the DDH cluster. The name must be 2 to 128 characters in length and can contain letters, digits, periods (.), underscores (_), and hyphens (-). It must start with a letter. It cannot contain "http:// "or "https://".', position='Query'),
  description?: string(name='Description', description='The description of the DDH cluster. The description must be 2 to 256 characters in length. It cannot start with "http:// "or "https.', position='Query'),
}

model ModifyDedicatedHostClusterAttributeResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.'),
}

model ModifyDedicatedHostClusterAttributeResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyDedicatedHostClusterAttributeResponseBody(name='body'),
}

async function modifyDedicatedHostClusterAttribute(request: ModifyDedicatedHostClusterAttributeRequest): ModifyDedicatedHostClusterAttributeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyDedicatedHostClusterAttribute', 'POST', 'undefined', 'json', false, 'none', request);
}

model DescribeCommandsRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', description='The ID of the RAM user.', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='The account name of the resource master account.', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', description='The ID of the resource master account, that is, the UID.', position='Query'),
  regionId?: string(name='RegionId', description='The ID of the region. You can call [DescribeRegions](~~ 25609 ~~) to view the latest region list.', position='Query'),
  name?: string(name='Name', description='The name of the command. Fuzzy query is not supported.', position='Query'),
  pageSize?: long(name='PageSize', description='The number of entries to return on each page. Maximum Value: 50

Default value: 10', position='Query'),
  commandId?: string(name='CommandId', description='The ID of the command.', position='Query'),
  description?: string(name='Description', description='The description of the command.', position='Query'),
  pageNumber?: long(name='PageNumber', description='The current page number. Start value: 1

Default value: 1.', position='Query'),
  type?: string(name='Type', description='The type of the command. Valid values:

-RunBatScript: The Bat script that runs in the Windows instance.
-RunPowerShellScript: The command is the Windows script that runs in the PowerShell instance.
-RunShellScript: The command is a Shell script that runs on a Linux instance.
', position='Query'),
  contentEncoding?: string(name='ContentEncoding', description='Specifies the encoding method of the "CommandContent" and "Output" fields in the returned data. Valid values:
-PlainText: returns the original script content and output information.
-Base64: returns the base64-encoded script content and output information.

Default value: Base64', position='Query'),
  provider?: string(name='Provider', description='The provider of public commands. The parameter values are described as follows:

-If this parameter is not set, all manually created cloud assistant commands are queried by default.
-If this parameter is set to "AlibabaCloud", all public commands provided by Alibaba Cloud are queried.
-If the value of this parameter is a specific public Command provider, query all public commands provided by the provider. Example:
-When "Provider = AlibabaCloud.ECS.GuestOS", query the public commands provided by "AlibabaCloud.ECS.GuestOS.
-When "Provider = AlibabaCloud.ECS.GuestOSDiagnose", query the public commands provided by "AlibabaCloud.ECS.GuestOSDiagnose.

Default value: Null.', position='Query'),
}

model DescribeCommandsResponseBody = {
  pageSize?: long(name='PageSize', description='The number of rows per page.'),
  requestId?: string(name='RequestId', description='The ID of the request.'),
  pageNumber?: long(name='PageNumber', description='The page number of the command list.'),
  totalCount?: long(name='TotalCount', description='The total number of commands.'),
  commands?: {
    command?: [ 
    {
      creationTime?: string(name='CreationTime', description='The time when the command was created.'),
      type?: string(name='Type', description='The type of the command.'),
      timeout?: long(name='Timeout', description='The timeout period.'),
      invokeTimes?: int32(name='InvokeTimes', description='The number of tasks created by using this command.'),
      commandId?: string(name='CommandId', description='The ID of the command.'),
      workingDir?: string(name='WorkingDir', description='The execution path.'),
      description?: string(name='Description', description='The description of the command.'),
      version?: int32(name='Version', description='The version of the common command. If multiple commands belong to the same "Provider" and have the same name and category, these commands belong to different versions of the same command. This value is not returned for manually created cloud assistant commands.'),
      provider?: string(name='Provider', description='The provider of public commands.'),
      commandContent?: string(name='CommandContent', description='The command content, which is Base64-encoded and then transmitted.'),
      category?: string(name='Category', description='The category of the common command.'),
      latest?: boolean(name='Latest', description='Indicates whether the public Command is the latest version. If multiple commands belong to the same "Provider" and have the same name and category, these commands belong to different versions of the same command. This value is not returned for manually created cloud assistant commands.'),
      name?: string(name='Name', description='The name of the command.'),
      enableParameter?: boolean(name='EnableParameter', description='Specifies whether to enable custom parameters.
'),
      parameterNames?: {
        parameterName?: [ string ](name='ParameterName')
      }(name='ParameterNames'),
    }
  ](name='Command')
  }(name='Commands', description='The type of the command dataset.'),
}

model DescribeCommandsResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeCommandsResponseBody(name='body'),
}

/**
 * ## API description

If you only enter the "Action" and "RegionId" parameters and do not enter any other request parameters, all available commands ("CommandId") that you manually create are queried by default.
 */
async function describeCommands(request: DescribeCommandsRequest): DescribeCommandsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeCommands', 'POST', 'undefined', 'json', false, 'none', request);
}

model DeleteImageRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', description='The ID of the RAM user.', position='Query'),
  regionId?: string(name='RegionId', description='The region ID of the custom image. You can call [DescribeRegions](~~ 25609 ~~) to view the latest region list.', position='Query'),
  force?: boolean(name='Force', description='Indicates whether to force delete. Valid values:

-true: forcibly deletes the custom image, ignoring whether the current image is used by other instances.
-false: The custom image is deleted. Check whether the current image is used by other instances before deletion.

Default value: false', position='Query'),
  imageId?: string(name='ImageId', description='The ID of the image. If the specified custom image does not exist, the request is ignored.', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='The account name of the resource master account.', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', description='The ID of the resource master account, that is, the UID.', position='Query'),
}

model DeleteImageResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.'),
}

model DeleteImageResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteImageResponseBody(name='body'),
}

async function deleteImage(request: DeleteImageRequest): DeleteImageResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteImage', 'POST', 'undefined', 'json', false, 'none', request);
}

model CreateFleetRequest {
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  fleetName?: string(name='FleetName', position='Query'),
  fleetType?: string(name='FleetType', position='Query'),
  spotAllocationStrategy?: string(name='SpotAllocationStrategy', position='Query'),
  spotInstanceInterruptionBehavior?: string(name='SpotInstanceInterruptionBehavior', position='Query'),
  spotInstancePoolsToUseCount?: int32(name='SpotInstancePoolsToUseCount', position='Query'),
  onDemandAllocationStrategy?: string(name='OnDemandAllocationStrategy', position='Query'),
  excessCapacityTerminationPolicy?: string(name='ExcessCapacityTerminationPolicy', position='Query'),
  validFrom?: string(name='ValidFrom', position='Query'),
  validUntil?: string(name='ValidUntil', position='Query'),
  terminateInstancesWithExpiration?: boolean(name='TerminateInstancesWithExpiration', position='Query'),
  terminateInstances?: boolean(name='TerminateInstances', position='Query'),
  maxSpotPrice?: float(name='MaxSpotPrice', position='Query'),
  totalTargetCapacity?: string(name='TotalTargetCapacity', position='Query'),
  onDemandTargetCapacity?: string(name='OnDemandTargetCapacity', position='Query'),
  spotTargetCapacity?: string(name='SpotTargetCapacity', position='Query'),
  defaultTargetCapacityType?: string(name='DefaultTargetCapacityType', position='Query'),
  fillGapWithOnDemand?: string(name='FillGapWithOnDemand', position='Query'),
  launchTemplateId?: string(name='LaunchTemplateId', position='Query'),
  launchTemplateVersion?: string(name='LaunchTemplateVersion', position='Query'),
  description?: string(name='Description', position='Query'),
  launchTemplateConfig?: [ 
    {
      vSwitchId?: string(name='VSwitchId'),
      maxPrice?: double(name='MaxPrice'),
      priority?: int32(name='Priority'),
      instanceType?: string(name='InstanceType'),
      weightedCapacity?: double(name='WeightedCapacity'),
    }
  ](name='LaunchTemplateConfig', position='Query'),
}

model CreateFleetResponseBody = {
  fleetId?: string(name='FleetId'),
  requestId?: string(name='RequestId'),
}

model CreateFleetResponse = {
  headers: map[string]string(name='headers'),
  body: CreateFleetResponseBody(name='body'),
}

async function createFleet(request: CreateFleetRequest): CreateFleetResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateFleet', 'POST', 'undefined', 'json', false, 'none', request);
}

model DescribeImagePipelinesRequest {
  tag?: [ 
    {
      key?: string(name='Key', description='标签键。N的取值范围：1~20'),
      value?: string(name='Value', description='标签值。N的取值范围：1~20'),
    }
  ](name='Tag', position='Query'),
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the enterprise resource group.', position='Query'),
  imagePipelineId?: [ string ](name='ImagePipelineId', description='The ID of the image template. Valid values of N: 1 to 20.', position='Query'),
  regionId?: string(name='RegionId', description='Belongs geo ID. You can call [DescribeRegions](~~ 25609 ~~) to view the latest region list.', position='Query'),
  maxResults?: int32(name='MaxResults', description='The number of entries to return on each page. Valid values: 1 to 500.

Default value: 50.', position='Query'),
  nextToken?: string(name='NextToken', description='Query the credential (Token). The value is the value of the "NextToken" parameter returned by the last call to the API. You do not need to set this parameter when you call the API for the first time.', position='Query'),
  name?: string(name='Name', description='The name of the template.', position='Query'),
}

model DescribeImagePipelinesResponseBody = {
  nextToken?: string(name='NextToken', description='The Token returned by this call. For more information, see API description.'),
  requestId?: string(name='RequestId', description='The ID of the request.'),
  totalCount?: int32(name='TotalCount', description='The number of returned image templates.'),
  maxResults?: int32(name='MaxResults', description='The number of entries to return on each page.'),
  imagePipeline?: {
    imagePipelineSet?: [ 
    {
      creationTime?: string(name='CreationTime', description='The time when the template was created.'),
      deleteInstanceOnFailure?: boolean(name='DeleteInstanceOnFailure', description='Specifies whether to release the intermediate instance after the image fails to be built.'),
      instanceType?: string(name='InstanceType', description='The instance type.'),
      internetMaxBandwidthOut?: int32(name='InternetMaxBandwidthOut', description='The Internet outbound bandwidth of the intermediate instance. Unit: Mbit/s'),
      imagePipelineId?: string(name='ImagePipelineId', description='The ID of the image template.'),
      vSwitchId?: string(name='VSwitchId', description='The vSwitch ID of the VPC.'),
      systemDiskSize?: int32(name='SystemDiskSize', description='The system disk size of the intermediate instance. Unit: GiB'),
      description?: string(name='Description', description='The description.'),
      baseImage?: string(name='BaseImage', description='The source image.
-When "BaseImageType = IMAGE", the value of this parameter is the ID of the custom image.
-When "BaseImageType = IMAGE_FAMILY ", the value of this parameter is the name of the Image family.'),
      resourceGroupId?: string(name='ResourceGroupId', description='The ID of the enterprise resource group.'),
      imageName?: string(name='ImageName', description='The prefix of the target image name.'),
      baseImageType?: string(name='BaseImageType', description='The type of the source image. Possible values:

-IMAGE: custom IMAGE.
-IMAGE_FAMILY: The Image family is.'),
      name?: string(name='Name', description='The name of the template.'),
      buildContent?: string(name='BuildContent', description='The content of the image template.'),
      tags?: {
        tag?: [ 
        {
          tagKey?: string(name='TagKey', description='The key of the tag.'),
          tagValue?: string(name='TagValue', description='The value of the tag.'),
        }
      ](name='Tag')
      }(name='Tags', description='The list of key-value pairs.'),
      addAccounts?: {
        addAccount?: [ string ](name='AddAccount')
      }(name='AddAccounts'),
      toRegionIds?: {
        toRegionId?: [ string ](name='ToRegionId')
      }(name='ToRegionIds'),
    }
  ](name='ImagePipelineSet')
  }(name='ImagePipeline', description='The list of image template details.'),
}

model DescribeImagePipelinesResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeImagePipelinesResponseBody(name='body'),
}

/**
 * ## API description

You can set the "NextToken" Token to the value of the "NextToken" parameter returned by the last call to "DescribeImagePipelines", and then set the maximum number of entries for a single-page query through "maxresule.
 */
async function describeImagePipelines(request: DescribeImagePipelinesRequest): DescribeImagePipelinesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeImagePipelines', 'POST', 'undefined', 'json', false, 'none', request);
}

model DeleteVpcRequest {
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  vpcId?: string(name='VpcId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
}

model DeleteVpcResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteVpcResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteVpcResponseBody(name='body'),
}

async function deleteVpc(request: DeleteVpcRequest): DeleteVpcResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteVpc', 'POST', 'undefined', 'json', false, 'none', request);
}

model StopInstancesRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  instanceId?: [ string ](name='InstanceId', position='Query'),
  regionId?: string(name='RegionId', description='The region of the instance. You can call [DescribeRegions](~~ 25609 ~~) to view the latest region list.', position='Query'),
  stoppedMode?: string(name='StoppedMode', description='The stop mode that you set when you stop a pay-as-you-go ECS instance. Valid values:

-StopCharging: reduces downtime. For more information about the conditions for "StopCharging" to take effect, see The enable conditions section of [pay-as-you-go instance shutdown mode](~~ 63353 ~~).
-KeepCharging: normal shutdown mode. The instance continues to be billed after it is stopped.

default value: if you enable the VPC instance shutdown mode in the ECS console (For more information, see [enable default shutdown mode](~~ 63353#default ~~)), the default value is stopcharging ". Otherwise, the default value is keepcharging ".', position='Query'),
  forceStop?: boolean(name='ForceStop', description='Indicates whether to force shutdown. Valid values:

-true: forced shutdown. This is equivalent to a typical power-off operation. All cached data that is not written to the storage device will be lost.

-false: the instance is powered off.

Default value: false', position='Query'),
  batchOptimization?: string(name='BatchOptimization', description='Set the batch operation mode. Valid values:

-AllTogether: In this mode, if all instances are stopped successfully, a success message is returned. If any instance fails the verification, all instances fail to be stopped and a failure message is returned.

-SuccessFirst: In this mode, each instance is stopped. The returned results include the operation results of each instance.

Default value: AllTogether', position='Query'),
  dryRun?: boolean(name='DryRun', description='Specifies whether to PreCheck only this request. Valid values:

-true: sends a check request and does not stop the instance. Check items include required parameters, request format, and instance status. If the check fails, the corresponding error is returned. If the check succeeds, "DRYRUN.SUCCESS" is returned ".
> If the "BatchOptimization" parameter is set to "SuccessFirst", only "DryRun. SUCCESS" is returned for the PreCheck result of "DRYRUN = true ".

-false: Sends a normal request and stops the instance after passing the check.

Default value: false', position='Query'),
}

model StopInstancesResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.'),
  instanceResponses?: {
    instanceResponse?: [ 
    {
      code?: string(name='Code', description='The error code of the instance operation result. The return value 200 is successful. For more information, see the following error codes.'),
      message?: string(name='Message', description='The error message returned for the instance operation. The Success returned value is successful. For more information, see the following error codes.'),
      instanceId?: string(name='InstanceId', description='The ID of the instance.'),
      currentStatus?: string(name='CurrentStatus', description='The current status of the instance.'),
      previousStatus?: string(name='PreviousStatus', description='The status of the instance before the operation.'),
    }
  ](name='InstanceResponse')
  }(name='InstanceResponses', description='An array consisting of InstanceResposne, which returns the status and result of each instance operation.'),
}

model StopInstancesResponse = {
  headers: map[string]string(name='headers'),
  body: StopInstancesResponseBody(name='body'),
}

/**
 * ## API description

-When querying ECS instance information, if the returned data contains "{"OperationLocks": {"LockReason" : "security"}}", all operations are prohibited.

-After the pay-as-you-go instance is enabled, you can set "StoppedMode = KeepCharging" to enable the normal shutdown mode. After the instance is stopped, the billing continues, the ECS instance type inventory and public IP address are retained.

-Batch operations are supported. You can set the batch operation mode by using the "BatchOptimization" parameter.
 */
async function stopInstances(request: StopInstancesRequest): StopInstancesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'StopInstances', 'POST', 'undefined', 'json', false, 'none', request);
}

model DescribeImageSupportInstanceTypesRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  filter?: [ 
    {
      key?: string(name='Key', description='指定过滤条件Key，当前只支持过滤镜像ID。取值范围：
-  imageId：过滤条件为镜像ID。
-  filter：过滤条件为镜像ID。'),
      value?: string(name='Value', description='指定过滤条件Value。'),
    }
  ](name='Filter', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='The account name of the resource master account.', position='Query'),
  ownerId?: long(name='OwnerId', description='The ID of the RAM user.', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', description='The ID of the resource master account, that is, the UID.', position='Query'),
  imageId?: string(name='ImageId', description='The ID of the image.', position='Query'),
  regionId?: string(name='RegionId', description='The ID of the region to which the image belongs. You can call [DescribeRegions](~~ 25609 ~~) to view the latest region list.', position='Query'),
  actionType?: string(name='ActionType', description='The scenario of the instance type. Valid values:

-CreateEcs (default): creates an instance.
-Upgrade: Upgrade the instance type.
-Downgrade: Downgrade the instance type.
-RenewDowngrade: renewal and downgrade.', position='Query'),
}

model DescribeImageSupportInstanceTypesResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.'),
  imageId?: string(name='ImageId', description='The ID of the queried image.'),
  regionId?: string(name='RegionId', description='Mirror respective geographical ID.'),
  instanceTypes?: {
    instanceType?: [ 
    {
      instanceTypeId?: string(name='InstanceTypeId', description='The ID of the instance type supported by the image.'),
      instanceTypeFamily?: string(name='InstanceTypeFamily', description='The instance type family.'),
      cpuCoreCount?: int32(name='CpuCoreCount', description='The number of vCPU cores of the instance type.'),
      memorySize?: float(name='MemorySize', description='The memory size of the instance type. Unit: GiB.'),
    }
  ](name='InstanceType')
  }(name='InstanceTypes', description='A collection of instance types consisting of InstanceTypeItemType.'),
}

model DescribeImageSupportInstanceTypesResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeImageSupportInstanceTypesResponseBody(name='body'),
}

async function describeImageSupportInstanceTypes(request: DescribeImageSupportInstanceTypesRequest): DescribeImageSupportInstanceTypesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeImageSupportInstanceTypes', 'POST', 'undefined', 'json', false, 'none', request);
}

model ReplaceSystemDiskRequest {
  systemDisk?: {
    size?: int32(name='Size', description='The capacity of the new system disk. Unit: GiB. Valid values: Max{20. The size of the image corresponding to the parameter ImageId} to 500.

Default value: Max{40. The size of the image corresponding to the parameter ImageId}.

> additional fees will be charged if the disk capacity exceeds the value of max {20, system disk capacity before replacement}.', position=''),
  }(name='SystemDisk'),
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  diskId?: string(name='DiskId', position='Query'),
  useAdditionalService?: boolean(name='UseAdditionalService', description='Specifies whether to use the virtual machine system configurations provided by Alibaba Cloud (Windows:NTP and KMS;Linux:NTP and YUM).

> This parameter is valid when the system disk is mounted (the device name is/dev/xvda).', position='Query'),
  platform?: string(name='Platform', description='The operating system release. Valid values:

-CentOS

-Ubuntu', position='Query'),
  clientToken?: string(name='ClientToken', description='Ensure the idempotence of the request. Generate a parameter value from your client. Make sure that the value is unique among different requests. **ClientToken** supports only ASCII characters and cannot exceed 64 characters. For more information, see [how to ensure idempotence](~~ 25693 ~~).', position='Query'),
  instanceId?: string(name='InstanceId', description='The ID of the instance.', position='Query'),
  securityEnhancementStrategy?: string(name='SecurityEnhancementStrategy', description='Indicates whether to use security center for free after the system disk is replaced. Valid values:

-Active: used. This value only supports public images.

-Deactive: not used. This value supports all images.

Default value: Deactive', position='Query'),
  architecture?: string(name='Architecture', description='The system architecture. Valid values:

-i386
-x86_64', position='Query'),
  imageId?: string(name='ImageId', description='The ID of the image used to reset the system.', position='Query'),
  keyPairName?: string(name='KeyPairName', description='The name of the key pair.

> This parameter takes effect only for Linux ECS instances. You can bind an SSH key pair to an ECS instance as a logon credential. After an SSH key pair is used, the logon credential for the username and password is disabled.', position='Query'),
  passwordInherit?: boolean(name='PasswordInherit', description='Specifies whether to use the default password of the image.

Default value: false

> If this parameter is used, the Password parameter must be empty. Make sure that the password is set for the image you are using.

', position='Query'),
  password?: string(name='Password', description='Specifies whether to reset the username and password of the ECS instance. The description must be 8 to 30 characters in length and must contain letters, digits, and special characters. Special symbols can be:

"""
()"~! @%& *-_+ =} [],.?/
"""

The Windows instance cannot start with a slash (/).

Default value: the value remains unchanged.

> If the "Password" parameter is specified, we recommend that you send requests over HTTPS to avoid password leakage.', position='Query'),
}

model ReplaceSystemDiskResponseBody = {
  diskId?: string(name='DiskId', description='The ID of the new system disk.'),
  requestId?: string(name='RequestId', description='The ID of the request.'),
}

model ReplaceSystemDiskResponse = {
  headers: map[string]string(name='headers'),
  body: ReplaceSystemDiskResponseBody(name='body'),
}

/**
 * 
## API description

When you change a system disk, note the following:

-You cannot change the disk type of the system disk.

-You cannot change the billing method of the system disk.

-The instance must be in the Stopped (Stopped) state.

> applies only to VPC instances. If the ECS instance is billed on a pay-as-you-go basis and the VPC mode is enabled by default, the instance cannot be restarted after the system disk is replaced due to insufficient ECS instances in the region. You must set this parameter to normal shutdown mode when you stop the instance. For more information, see [StopInstance](~~ 25501 ~~).

-The ECS instance cannot be locked. The "OperationLocks" parameter value of the instance contains ""LockReason": "security"". For more information, see [API actions for security lock](~~ 25695 ~~).

-The ECS instance attached to the system disk cannot have an unpaid order.

-You can use the "SystemDisk.Size" parameter to specify the size of the system disk.

After the system disk is replaced, we recommend that you use any of the following methods to verify that the system disk is replaced:

-Call the [DescribeDisks](~~ 25514 ~~) operation to query the status of the new system disk. If an instance is attached, the system disk is replaced.

-You can call the [DescribeInstances](~~ 25506 ~~) operation to query the status of the instance to which the system disk is replaced. If "OperationLocks" is null, the system disk replacement operation is completed.

 */
async function replaceSystemDisk(request: ReplaceSystemDiskRequest): ReplaceSystemDiskResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ReplaceSystemDisk', 'POST', 'undefined', 'json', false, 'none', request);
}

model ModifyImageShareGroupPermissionRequest {
  addGroup?: [ string ](name='AddGroup'),
  removeGroup?: [ string ](name='RemoveGroup'),
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  imageId?: string(name='ImageId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
}

model ModifyImageShareGroupPermissionResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyImageShareGroupPermissionResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyImageShareGroupPermissionResponseBody(name='body'),
}

async function modifyImageShareGroupPermission(request: ModifyImageShareGroupPermissionRequest): ModifyImageShareGroupPermissionResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyImageShareGroupPermission', 'POST', 'undefined', 'json', false, 'none', request);
}

model DescribeInstanceVncUrlRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  regionId?: string(name='RegionId', description='The ID of the region to which the instance belongs. You can call [DescribeRegions](~~ 25609 ~~) to view the latest region list.', position='Query'),
  instanceId?: string(name='InstanceId', description='The ID of the instance.', position='Query'),
  ownerId?: long(name='OwnerId', description='The ID of the RAM user.', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', description='The ID of the resource master account, that is, the UID.', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='The account name of the resource master account.', position='Query'),
}

model DescribeInstanceVncUrlResponseBody = {
  vncUrl?: string(name='VncUrl', description='Manage the terminal Url.'),
  requestId?: string(name='RequestId', description='The ID of the request.'),
}

model DescribeInstanceVncUrlResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeInstanceVncUrlResponseBody(name='body'),
}

/**
 * ## API description

When you call this operation, note that:

-The validity period of the management Terminal address is 15 seconds. If the URL is not used within 15 seconds after the API is called, the URL will become invalid. You need to query it again.

-The **persistent link**(KeepAlive) duration of a single management Terminal Link is 60 seconds. If there is no interaction in the management terminal window within 60 seconds, the connection is automatically disconnected.

-If the connection is interrupted, the number of reconnections per minute cannot exceed 30.

-Do you need to https://g.alicdn.com/aliyun/ecs-console-vnc2/0.0.8/index.html in the link? Add "vncUrl =*** ", "instanceId =***", and "isWindows = True" at the end ", "isWindows = False" and "password =****" are used to connect parameters by using. Where:

-Parameter "vncUrl": the value of "VncUrl" returned after the API is called.

-Parameter "instanceId": the ID of your instance.

-Parameter "isWindows": indicates whether the operating system of the instance is Windows. A value of "true" indicates that the system is Windows. A value of "false" indicates that the system is not Windows.

-(Optional) "password": specifies the password of the instance. The password can contain six digits or uppercase and lowercase letters. When you use this parameter, you do not need to enter a password at the connection management terminal.

Sample requests:

"""
https://g.alicdn.com/aliyun/ecs-console-vnc2/0.0.8/index.html? vncUrl=ws%3A%2F%****&instanceId=i-wz9hhwq5a6tm****&isWindows=true
"""

Or:

"""
https://g.alicdn.com/aliyun/ecs-console-vnc2/0.0.8/index.html? vncUrl=ws%3A%2F%****&instanceId=i-wz9hhwq5a6tm****&isWindows=true&password= ****
"""
 */
async function describeInstanceVncUrl(request: DescribeInstanceVncUrlRequest): DescribeInstanceVncUrlResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeInstanceVncUrl', 'POST', 'undefined', 'json', false, 'none', request);
}

model DescribeDemandsRequest {
  tag?: [ 
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='Tag', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  instanceTypeFamily?: string(name='InstanceTypeFamily', description='The instance type family.', position='Query'),
  regionId?: string(name='RegionId', description='The ID of the destination region. You can call [DescribeRegions](~~ 25609 ~~) to view the latest region list.', position='Query'),
  instanceType?: string(name='InstanceType', description='The instance type.', position='Query'),
  pageSize?: int32(name='PageSize', description='The number of entries to return on each page. Maximum Value: 100

Default value: 10', position='Query'),
  demandId?: string(name='DemandId', description='The ID of the report. If this parameter is specified, other non-required request parameters are ignored.', position='Query'),
  dryRun?: boolean(name='DryRun', description='Specifies whether to PreCheck only this request. Valid values:

-true: a check request is sent without querying the status of the report. Check whether the AccessKey is valid, whether the RAM user is authorized, and whether required parameters are specified. If the check fails, the corresponding error is returned. If the check succeeds, an error code DryRunOperation is returned.
-false (default): a normal request is sent. After the request passes the check, the status code 2XX is returned and the status of the report is directly queried.', position='Query'),
  zoneId?: string(name='ZoneId', description='The ID of the zone. For more information, see [DescribeZones](~~ 25610 ~~) for a list of zones.', position='Query'),
  pageNumber?: int32(name='PageNumber', description='The page number of the report list. Start value: 1

Default value: 1.', position='Query'),
  demandStatus?: [ string ](name='DemandStatus', description='The status of the report or resource usage. Valid values:

-Creating: a report is being created.
-Active: resources are being supplied.
-Expired: The report has Expired.
-Finished: consumed.
-Refused: The report is rejected. For more information, see the response parameter "Comment ".
-Cancelled: The filing is canceled.', position='Query'),
  instanceChargeType?: string(name='InstanceChargeType', description='The billing method of the instance. Valid values:

-PostPaid: pay-as-you-go
-PrePaid: Subscription', position='Query'),
  demandType?: string(name='DemandType', description='The source of the reported instance. Valid values:

* Custom: self-report.
* System (default): Alibaba Cloud assists in reporting.', position='Query'),
}

model DescribeDemandsResponseBody = {
  pageSize?: int32(name='PageSize', description='The number of entries to return on each page.'),
  pageNumber?: int32(name='PageNumber', description='The page number of the report list.'),
  requestId?: string(name='RequestId', description='The ID of the request.'),
  totalCount?: int32(name='TotalCount', description='The number of records queried.'),
  regionId?: string(name='RegionId', description='The region of the query.'),
  demands?: {
    demand?: [ 
    {
      comment?: string(name='Comment', description='The feedback suggestion that the resource report is rejected.'),
      demandDescription?: string(name='DemandDescription', description='The description of the report.'),
      demandId?: string(name='DemandId', description='The ID of the report.'),
      demandTime?: string(name='DemandTime', description='The time when the report was created. The time follows the [ISO8601](~~ 25696 ~~) standard and uses UTC +0. The format is yyyy-MM-ddTHH:mm:ssZ.'),
      instanceType?: string(name='InstanceType', description='The type of the reported instance.'),
      demandName?: string(name='DemandName', description='The name of the report.'),
      period?: int32(name='Period', description='The duration of the reported resource.'),
      instanceChargeType?: string(name='InstanceChargeType', description='The billing method of the reported resource. Possible values:

-Prepaid: Subscription
-Postpaid: pay-as-you-go'),
      availableAmount?: int32(name='AvailableAmount', description='The number of instances that can be used to report Resources.'),
      endTime?: string(name='EndTime', description='The expected deadline for purchasing the reported resources. The time follows the [ISO8601](~~ 25696 ~~) standard and uses UTC +0. The format is yyyy-MM-ddTHH:mm:ssZ.'),
      startTime?: string(name='StartTime', description='The expected purchase time of the reported resource. The time follows the [ISO8601](~~ 25696 ~~) standard and uses UTC +0. The format is yyyy-MM-ddTHH:mm:ssZ.'),
      periodUnit?: string(name='PeriodUnit', description='The unit of the usage period of the reported resource. Possible values:

-Hour
-Day
-<props="china">Week</props>
-Month
'),
      zoneId?: string(name='ZoneId', description='The zone of the reported resource.'),
      usedAmount?: int32(name='UsedAmount', description='The number of consumed instances.'),
      totalAmount?: int32(name='TotalAmount', description='The number of reported instances.'),
      deliveringAmount?: int32(name='DeliveringAmount', description='The number of instances to be delivered in the reported resources.'),
      instanceTypeFamily?: string(name='InstanceTypeFamily', description='The type family of the reported instance.'),
      demandStatus?: string(name='DemandStatus', description='The status of the report or resource usage. Possible values:

-Creating: a report is being created.
-Active: resources are being supplied.
-Expired: The report has Expired.
-Finished: consumed.
-Refused: The report is rejected. For more information, see The "comment" parameter ".
-Cancelled: The filing is canceled. The filing resource has been canceled. After the report is canceled, the resource delivery status is invalid.'),
      supplyInfos?: {
        supplyInfo?: [ 
        {
          amount?: int32(name='Amount', description='The number of instances delivered.'),
          supplyStatus?: string(name='SupplyStatus', description='The delivery status of the resource. Possible values:

-Delivered: Delivered
-Delivering: Delivery in progress'),
          supplyStartTime?: string(name='SupplyStartTime', description='The start time of resource delivery. The time follows the [ISO8601](~~ 25696 ~~) standard and uses UTC +0. The format is yyyy-MM-ddTHH:mm:ssZ.'),
          supplyEndTime?: string(name='SupplyEndTime', description='The deadline for resource delivery. The time follows the [ISO8601](~~ 25696 ~~) standard and uses UTC +0. The format is yyyy-MM-ddTHH:mm:ssZ.'),
        }
      ](name='SupplyInfo')
      }(name='SupplyInfos', description='The delivery status of the reported resources.'),
    }
  ](name='Demand')
  }(name='Demands', description='The number of records that match the filter conditions in the specified region.'),
}

model DescribeDemandsResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeDemandsResponseBody(name='body'),
}

/**
 * ## API description

You can call this operation to query the details of the resources reported by Alibaba Cloud, including the type, delivery, and consumption of the reported resources.

By default, I/O optimized instance types and the report form status of VPC-connected ECS instances are queried.

If you need to obtain information about creating an ECS resource requirement report (CreateDemand), modifying the ECS resource requirement report (ModifyDemand), and deleting the ECS resource requirement report (DeleteDemand), contact your account manager.


 */
async function describeDemands(request: DescribeDemandsRequest): DescribeDemandsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeDemands', 'POST', 'undefined', 'json', false, 'none', request);
}

model RecoverVirtualBorderRouterRequest {
  regionId?: string(name='RegionId', position='Query'),
  vbrId?: string(name='VbrId', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  clientToken?: string(name='ClientToken', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  userCidr?: string(name='UserCidr', position='Query'),
}

model RecoverVirtualBorderRouterResponseBody = {
  requestId?: string(name='RequestId'),
}

model RecoverVirtualBorderRouterResponse = {
  headers: map[string]string(name='headers'),
  body: RecoverVirtualBorderRouterResponseBody(name='body'),
}

async function recoverVirtualBorderRouter(request: RecoverVirtualBorderRouterRequest): RecoverVirtualBorderRouterResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'RecoverVirtualBorderRouter', 'POST', 'undefined', 'json', false, 'none', request);
}

model DescribeResourceByTagsRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  tag?: [ 
    {
      key?: string(name='key', description='资源的标签键。

>为提高兼容性，建议您尽量使用Tag.N.Key参数。'),
      value?: string(name='Value', description='资源的标签值。N的取值范围：1~20。一旦传入该值，允许为空字符串。最多支持128个字符。'),
    }
  ](name='Tag', position='Query'),
  pageNumber?: int32(name='PageNumber', description='The page number of the query result. Start value: 1

Default value: 1.', position='Query'),
  resourceType?: string(name='ResourceType', description='The type of the resource. Valid values:

-instance:ECS instance
-disk: disk
-snapshot: snapshot
-image: image
-securitygroup: Security Group
-volume: storage volume
-eni: eni
-ddh: Dedicated host
-keypair:SSH key pair
-launchtemplate: launch Template

The preceding values are all in lowercase.', position='Query'),
  regionId?: string(name='RegionId', description='The ID of the region to which the resource belongs. You can call [DescribeRegions](~~ 25609 ~~) to view the latest region list.', position='Query'),
  pageSize?: int32(name='PageSize', description='The number of entries per page displayed in the query results. Maximum Value: 100

Default value: 50', position='Query'),
}

model DescribeResourceByTagsResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.'),
  pageSize?: int32(name='PageSize', description='The number of entries per page displayed in the query results.'),
  pageNumber?: int32(name='PageNumber', description='The page number of the query result.'),
  totalCount?: int32(name='TotalCount', description='The total number of returned resources.'),
  resources?: {
    resource?: [ 
    {
      resourceType?: string(name='ResourceType', description='The type of the resource.'),
      resourceId?: string(name='ResourceId', description='The ID of the resource.'),
      regionId?: string(name='RegionId', description='The ID of the region.'),
    }
  ](name='Resource')
  }(name='Resources', description='The collection of resource information associated with the tag.'),
}

model DescribeResourceByTagsResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeResourceByTagsResponseBody(name='body'),
}

async function describeResourceByTags(request: DescribeResourceByTagsRequest): DescribeResourceByTagsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeResourceByTags', 'POST', 'undefined', 'json', false, 'none', request);
}

model DescribeImagesRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  tag?: [ 
    {
      key?: string(name='key', description='镜像的标签键。

>该参数即将被弃用，为提高兼容性，建议您使用另一个`Tag.N.Key`参数。'),
      value?: string(name='Value', description='镜像的标签值。N的取值范围：1~20'),
    }
  ](name='Tag', position='Query'),
  filter?: [ 
    {
      key?: string(name='Key', description='查询资源时的筛选键。取值范围：

- 当该参数取值为`CreationStartTime`时，可以查询在指定时间点（`Filter.N.Value`）后创建的资源信息。
- 当该参数取值为`CreationEndTime`时，可以查询在指定时间点（`Filter.N.Value`）前创建的资源信息。'),
      value?: string(name='Value', description='查询资源时的筛选值。指定该参数时必须同时指定`Filter.N.Key`参数，格式为：`yyyy-MM-ddTHH:mmZ`，采用UTC +0时区。'),
    }
  ](name='Filter', position='Query'),
  imageId?: string(name='ImageId', description='The ID of the image.', position='Query'),
  showExpired?: boolean(name='ShowExpired', description='Indicates whether the subscription image has expired.

> This parameter will be deprecated soon. To improve compatibility, try to use other parameters.', position='Query'),
  isSupportIoOptimized?: boolean(name='IsSupportIoOptimized', description='Indicates whether the image can run on an I/O optimized instance.', position='Query'),
  OSType?: string(name='OSType', description='The operating system type of the image. Valid values:

-windows
-linux', position='Query'),
  architecture?: string(name='Architecture', description='The architecture of the image. Valid values:

-i386
-x86_64
-arm64', position='Query'),
  status?: string(name='Status', description='You can call this operation to query images in a certain state. Valid values:

-Creating: The image is being created.
-Waiting: multiple tasks are being queued.
-Available (default): The image that you can use.
-UnAvailable: images that you cannot use.
-CreateFailed: the image fails to be created.
-Deprecated: Deprecated images.

Support simultaneous image multiple values, value between the comma (,).', position='Query'),
  actionType?: string(name='ActionType', description='The scenario where the image needs to be used. Valid values:

-CreateEcs (default): creates an instance.
-ChangeOS: replace the system disk or operating system.', position='Query'),
  pageSize?: int32(name='PageSize', description='The number of entries to return on each page. Maximum Value: 100

Default value: 10', position='Query'),
  isPublic?: boolean(name='IsPublic', description='<props = "intl"> Whether to query published community images. Valid values:</props>
<props="intl">
-true: queries published community images. If you set this parameter to true, the ImageOwnerAlias must be others.
-false: you can call this operation to query images of other types except the Community Image. The value of the ImageOwnerAlias parameter shall prevail.

</props>

<props = "intl"> Default value: false</props>', position='Query'),
  imageOwnerId?: long(name='ImageOwnerId', description='<props = "china"> The ID of the Alibaba Cloud account to which the image belongs. This parameter takes effect only when you query a shared image. </props>

<props = "intl"> The ID of the Alibaba Cloud account to which the image belongs. This parameter takes effect only when you query shared images and Community images. </props>

<props = "partner"> The ID of the Alibaba Cloud account to which the image belongs. This parameter takes effect only when you query a shared image. </props>', position='Query'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group to which the custom image belongs. When you use this parameter to filter resources, the number of resources cannot exceed 1,000.', position='Query'),
  imageName?: string(name='ImageName', description='The name of the image.', position='Query'),
  regionId?: string(name='RegionId', description='The ID of the region to which the image belongs. You can call [DescribeRegions](~~ 25609 ~~) to view the latest region list.', position='Query'),
  instanceType?: string(name='InstanceType', description='Specifies the images that can be used by the instance type.', position='Query'),
  pageNumber?: int32(name='PageNumber', description='The page number of the image resource list. Start value: 1

Default value: 1.', position='Query'),
  isSupportCloudinit?: boolean(name='IsSupportCloudinit', description='Indicates whether the image supports cloud-init.', position='Query'),
  usage?: string(name='Usage', description='Indicates whether the image is already running on the ECS instance. Valid values:

-instance: the image is running and is used by ECS instances.
-none: the image is idle and no ECS instance is available.', position='Query'),
  dryRun?: boolean(name='DryRun', description='Specifies whether to PreCheck only this request.

-true: sends a check request without querying the resource status. Check whether the AccessKey is valid, whether the RAM user is authorized, and whether required parameters are specified. If the check fails, the corresponding error is returned. If the check succeeds, an error code DryRunOperation is returned.
-false: a normal request is sent. After the request passes the check, the 2XX HTTP status code is returned and the resource status is directly queried.

Default value: false', position='Query'),
  imageFamily?: string(name='ImageFamily', description='The name of the Image family. You can set this parameter to filter images of the current family when querying images.

Default value: Null.', position='Query'),
  imageOwnerAlias?: string(name='ImageOwnerAlias', description='The source of the image. Valid values:

<props="china">
-system: a public image provided by Alibaba Cloud.
-self: The custom image you created.
-others: images shared by other Alibaba Cloud users or published community images.
-marketplace: The image provided by the marketplace. You can directly use the cloud marketplace images that you query without subscribing to them in advance. You must pay attention to the billing details of Alibaba Cloud marketplace images.

</props>

<props="intl">
-system: a public image provided by Alibaba Cloud.
-self: The custom image you created.
-others: images shared by other Alibaba Cloud users or published community images. Note:
-The IsPublic must be true when you search for a community image.
-When you search for a shared image, you must set the IsPublic to false or leave no value.
-marketplace: The image provided by the marketplace. You can directly use the cloud marketplace images that you query without subscribing to them in advance. You must pay attention to the billing details of Alibaba Cloud marketplace images.

</props>

<props="partner">
-system: a public image provided by Alibaba Cloud.
-self: The custom image you created.
-others: images shared by other Alibaba Cloud users or published community images.
-marketplace: The image provided by the marketplace. You can directly use the cloud marketplace images that you query without subscribing to them in advance. You must pay attention to the billing details of Alibaba Cloud marketplace images.

</props>

Default value: NULL. Null indicates that the system, self, and others values are returned.', position='Query'),
  snapshotId?: string(name='SnapshotId', description='A custom image created based on a snapshot ID.', position='Query'),
}

model DescribeImagesResponseBody = {
  pageSize?: int32(name='PageSize', description='The number of entries in the current page.'),
  pageNumber?: int32(name='PageNumber', description='The current page number.'),
  requestId?: string(name='RequestId', description='The ID of the request.'),
  totalCount?: int32(name='TotalCount', description='The total number of images.'),
  regionId?: string(name='RegionId', description='Mirror respective geographical ID.'),
  images?: {
    image?: [ 
    {
      creationTime?: string(name='CreationTime', description='The time when the image was created.'),
      status?: string(name='Status', description='The status of the image. Possible values:

-UnAvailable: UnAvailable
-Available: Available
-Creating: Creating
-CreateFailed: Failed to be created.'),
      imageFamily?: string(name='ImageFamily', description='The name of the Image family.'),
      progress?: string(name='Progress', description='The progress of the image completion. Unit: percentage.'),
      isCopied?: boolean(name='IsCopied', description='Indicates whether the image is copied.'),
      isSupportIoOptimized?: boolean(name='IsSupportIoOptimized', description='Indicates whether it can be run on I/O optimized instances.'),
      imageOwnerAlias?: string(name='ImageOwnerAlias', description='The source of the image. Possible values:

-system: a public image provided by Alibaba Cloud.
-self: The custom image you created.
-others: shared images or Community images provided by other Alibaba Cloud users.
-marketplace: The image provided by the marketplace.'),
      isSupportCloudinit?: boolean(name='IsSupportCloudinit', description='Indicates whether Cloud Init is supported.'),
      imageVersion?: string(name='ImageVersion', description='The version of the image.'),
      usage?: string(name='Usage', description='The type of the resource to be referenced. Possible values:

-instance: one or more ECS instances are created.
-none: no ECS instance has been created.'),
      isSelfShared?: string(name='IsSelfShared', description='Indicates whether the custom image has been shared with other users.'),
      description?: string(name='Description', description='The description.'),
      size?: int32(name='Size', description='The size of the image. Unit: GiB.'),
      resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group to which the image belongs.'),
      platform?: string(name='Platform', description='The operating system platform.'),
      OSNameEn?: string(name='OSNameEn', description='The name of the operating system.'),
      imageName?: string(name='ImageName', description='The name of the image.'),
      OSName?: string(name='OSName', description='The Chinese display name of the operating system.'),
      imageId?: string(name='ImageId', description='The ID of the image.'),
      OSType?: string(name='OSType', description='The operating system type. Possible values:

-Windows
-linux'),
      isSubscribed?: boolean(name='IsSubscribed', description='Indicates whether you have subscribed to the terms of service of the image product corresponding to the product code of the image.'),
      productCode?: string(name='ProductCode', description='The ID of the image product in the marketplace.'),
      architecture?: string(name='Architecture', description='The architecture type of the image system. Possible values:

-i386
-x86_64
-arm64'),
      diskDeviceMappings?: {
        diskDeviceMapping?: [ 
        {
          type?: string(name='Type', description='The type of the image.'),
          importOSSBucket?: string(name='ImportOSSBucket', description='The OSS bucket to which the imported Image belongs.'),
          progress?: string(name='Progress', description='If the image is being copied, the progress of the copy task is returned.'),
          snapshotId?: string(name='SnapshotId', description='The ID of the snapshot.'),
          importOSSObject?: string(name='ImportOSSObject', description='The OSS object to which the imported Image belongs.'),
          device?: string(name='Device', description='The device information of the cloud disk, such as/dev/xvdb.

> This parameter will be discontinued soon. We recommend that you do not use this parameter to improve code compatibility.'),
          size?: string(name='Size', description='The size of the disk.'),
          remainTime?: int32(name='RemainTime', description='For an image that is being copied, the remaining time of the copy task is returned. Unit: seconds.'),
          format?: string(name='Format', description='The image format.'),
        }
      ](name='DiskDeviceMapping')
      }(name='DiskDeviceMappings', description='The mapping between disks and snapshots in an image.'),
      tags?: {
        tag?: [ 
        {
          tagValue?: string(name='TagValue', description='The tag value of the image.'),
          tagKey?: string(name='TagKey', description='The tag key of the image.'),
        }
      ](name='Tag')
      }(name='Tags', description='The tag pair of the image.'),
      isPublic?: boolean(name='IsPublic', description='<props = "intl"> indicates whether the image is a public image. Public images include public images provided by Alibaba Cloud and custom images that you have published as Community images. Possible value:</props>
<props="intl">
-true: public images
-false: non-public image

</props>


'),
      imageOwnerId?: long(name='ImageOwnerId', description='<props = "china"> The ID of the Alibaba Cloud account to which the image belongs. This parameter takes effect only when you query a shared image. </props>

<props = "intl"> The ID of the Alibaba Cloud account to which the image belongs. This parameter takes effect only when you query shared images and Community images. </props>

<props = "partner"> The ID of the Alibaba Cloud account to which the image belongs. This parameter takes effect only when you query a shared image. </props>'),
    }
  ](name='Image')
  }(name='Images', description='A collection of Images.'),
}

model DescribeImagesResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeImagesResponseBody(name='body'),
}

/**
 * ## API description

-The image resources that you can query include your custom images, public images provided by Alibaba Cloud, Alibaba Cloud marketplace images, and shared images shared by other Alibaba Cloud users.

-Supports paging query. The query results include the total number of available image resources and the image resources on the current page. The number of entries per page is 10 by default.

-When you call an API through Alibaba Cloud CLI, the request parameter values of different data types must comply with the format requirements. For more information, see [CLI parameter format description](~~ 110340 ~~).

 */
async function describeImages(request: DescribeImagesRequest): DescribeImagesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeImages', 'POST', 'undefined', 'json', false, 'none', request);
}

model SignAgreementRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  agreementType?: string(name='AgreementType', position='Query'),
}

model SignAgreementResponseBody = {
  requestId?: string(name='RequestId'),
}

model SignAgreementResponse = {
  headers: map[string]string(name='headers'),
  body: SignAgreementResponseBody(name='body'),
}

async function signAgreement(request: SignAgreementRequest): SignAgreementResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'SignAgreement', 'POST', 'undefined', 'json', false, 'none', request);
}

model ImportImageRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  diskDeviceMapping?: [ 
    {
      diskImSize?: int32(name='DiskImSize', description='自定义镜像大小。

>该参数即将被弃用，为提高兼容性，请尽量使用`DiskDeviceMapping.N.DiskImageSize`参数。'),
      device?: string(name='Device', description='指定DiskDeviceMapping.N.Device在自定义镜像中的设备名。

> 该参数即将停止使用，为提高代码兼容性，建议您尽量不要使用该参数。'),
      OSSBucket?: string(name='OSSBucket', description='镜像文件所在的OSS Bucket。

> 首次导入镜像到该OSS Bucket前，请参见接口说明章节添加RAM授权策略，否则会报错`NoSetRoletoECSServiceAcount`。'),
      format?: string(name='Format', description='镜像格式。取值范围：

- RAW
- VHD
- QCOW2

默认值：无，表示阿里云自动检测镜像格式，以检测格式为准。'),
      OSSObject?: string(name='OSSObject', description='镜像上传至OSS Bucket后，保存在Bucket中的镜像文件的文件名（key）。'),
      diskImageSize?: int32(name='DiskImageSize', description='导入镜像后，自定义镜像的空间大小。

该空间由系统盘和数据盘组成，当N=1时，表示系统盘，当N=2~17时，表示数据盘。您必须保证系统盘的空间大小大于等于导入的镜像文件大小。取值范围：

- N=1时，取值范围：5 GiB~500 GiB
- N=2~17时，取值范围：5 GiB~1000 GiB

当您将源镜像文件上传至OSS后，可以在OSS Bucket中查看镜像文件的大小。'),
    }
  ](name='DiskDeviceMapping', position='Query'),
  tag?: [ 
    {
      key?: string(name='Key', description='镜像的标签键。N的取值范围：1~20。一旦传入该值，则不允许为空字符串。最多支持128个字符，不能以`aliyun`和`acs:`开头，不能包含`http://`或者`https://`。'),
      value?: string(name='Value', description='镜像的标签值。N的取值范围：1~20。一旦传入该值，允许为空字符串。最多支持128个字符，不能以`acs:`开头，不能包含`http://`或者`https://`。'),
    }
  ](name='Tag', position='Query'),
  regionId?: string(name='RegionId', description='The ID of the region from which the image is defined. You can call [DescribeRegions](~~ 25609 ~~) to view the latest region list.', position='Query'),
  platform?: string(name='Platform', description='The operating system release. Valid values:

-CentOS
-Ubuntu
-SUSE
-OpenSUSE
-Debian
-CoreOS
-Aliyun
-Anolis
-Windows Server 2003
-Windows Server 2008
-Windows Server 2012
-Others Linux
-Customized Linux

Default value: Others Linux', position='Query'),
  OSType?: string(name='OSType', description='The operating system platform type. Valid values:

-windows
-linux

Default value: linux', position='Query'),
  imageName?: string(name='ImageName', description='The name of the image. The description must be 2 to 128 characters in length. It must start with a letter and cannot start with aliyun" or ACS: ". It cannot contain "http://" or "https://". It can contain numbers, periods (.), colons (:), underscores (_), and hyphens (-).', position='Query'),
  licenseType?: string(name='LicenseType', description='After importing the image, activate the license type used by the operating system. Valid values:

-Auto: Alibaba Cloud detects the source operating system and assigns a license. In the automatic mode, the system preferentially searches for whether the "Platform" you set has an Alibaba Cloud official channel License and assigns it to the imported Image. If this type of License is not available, the system switches to the BYOL(Bring Your Own License) mode.
-Aliyun: uses the official Alibaba Cloud license based on the "Platform" you set.
-BYOL: The license provided by the source operating system. When using BYOL, you must ensure that your license key can be used in Alibaba Cloud.

Default value: Auto

', position='Query'),
  description?: string(name='Description', description='The description of the image. The description must be 2 to 256 characters in length and cannot start with "http:// "or "https.', position='Query'),
  roleName?: string(name='RoleName', description='The name of the RAM role used to import images.', position='Query'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group to which the imported Image belongs.', position='Query'),
  bootMode?: string(name='BootMode', description='Modify the startup mode of an image. Valid values:

-BIOS:BIOS startup mode.
-UEFI:UEFI startup mode.

Default value: BIOS. If "Architecture = arm64", this parameter defaults to UEFI and can only be set to UEFI.

> you need to know the startup mode supported by the specified image. After you use this parameter to modify the startup mode, the instance must match the startup mode supported by the image to start normally.', position='Query'),
  architecture?: string(name='Architecture', description='The system architecture. Valid values:

-i386
-x86_64
-arm64

Default value: x86_64', position='Query'),
}

model ImportImageResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.'),
  imageId?: string(name='ImageId', description='The ID of the image.'),
  taskId?: string(name='TaskId', description='The ID of the image import task.'),
  regionId?: string(name='RegionId', description='The ID of the region.'),
}

model ImportImageResponse = {
  headers: map[string]string(name='headers'),
  body: ImportImageResponseBody(name='body'),
}

/**
 * ## API description

When you call this operation, note that:

-You must upload the image file to OSS in advance. For more information, see [Upload files](~~ 31886 ~~).

-When importing an image for the first time, you must use RAM to authorize the ECS instance to access your OSS Bucket. Otherwise, an error "NoSetRoletoECSServiceAcount" is returned ". You can perform one-click authorization in the RAM console. For more information, see [cloud resource access authorization](https://ram.console.aliyun.com/? spm=5176.2020520101image.0.0.2ffa4df57kSoHX#/role/authorize? request=%7B%22Requests%22%3A%20%7B%22request1%22%3A%20%7B%22RoleName%22%3A%20%22AliyunECSImageImportDefaultRole%22%2C%20%22TemplateId%22%3A%20%22ECSImportRole%22%7D%2C%20%22request2%22%3A%20%7B%22RoleName%22%3A%20%22AliyunECSImageExportDefaultRole%22%2C%20%22TemplateId%22%3A%20%22ECSExportRole%22%7D%7D%2C%20%22ReturnUrl%22%3A%20%22https%3A//ecs.console.aliyun.com/%22%2C%20%22Service%22%3A%20%22ECS% 22% 7D). You can also manually grant permissions. The following table lists the policies and permissions of some operations. For more information, see [account access control](~~ 25481 ~~).

1. Create the role "AliyunECSImageImportDefaultRole" (this name is required, otherwise the image import fails). The role policy is as follows:

"""
{
"Statement ": [
{
"Action": "sts:AssumeRole ",
"Effect": "Allow ",
"Principal ": {
"Service ": [
"ecs.aliyuncs.com"
]
}
}
],
"Version": "1"
}
"""

2. Under this role, add the system policy "AliyunECSImageImportRolePolicy ". You can also create a custom policy. The permissions must include:

"""
{
"Version": "1 ",
"Statement ": [
{
"Action ": [
"oss:GetObject ",
"oss:GetBucketLocation ",
"oss:GetBucketInfo"
],
"Resource ": "*",
"Effect": "Allow"
}
]
}
"""
-You cannot delete an image that is being imported. You can only call [CancelTask](~~ 25624 ~~) to cancel the image import task.

-The region of the imported image must be the same as that of the OSS Bucket uploaded by the image file.

-The value of N in the "DiskDeviceMapping. "parameter ranges from 1 to 17. If N is 1, it indicates the system disk. If N is 2 to 17, it indicates the data disk.

-When you set the parameters to "Architecture = arm64" or "Platform = Anolis", note that:

-To make the imported image support password configuration or key pair modification, the image must meet the following requirements:

-The kernel of the operating system must support the "config_fw_cfg_sysfs "feature. By default, the Linux community kernel version 4.6 and later versions support this feature. CentOS kernel versions 3.10.0-826.el7 and later versions support this feature by default. You can run the "grep -nr CONFIG_FW_CFG_SYSFS /boot/config-$(uname -r)"command on the server corresponding to the image. If the response contains "config_fw_cfg_sysfs =, the kernel in the image already supports the CONFIG_FW_CFG_SYSFS feature.

-The latest version of cloud-init is installed in the operating system. cloud-init version 19.1 must be in version 19.1.3 or later, and cloud-init version 0.7.6a in some earlier operating systems must be in version 0.7.6 a15 or later. For more information, see [install cloud-init](~~ 57803 ~~).

-The operating system must support SHA-512 encryption algorithms.

-To enable the imported image to support disk expansion and file system expansion, the image must meet the following requirements:

-The kernel version of the operating system must be later than version 3.6.

-Support the growpart command. Support the command need to install "cloud-utils-growpart" bag, different operating system installation differently. For more information, see [extended partition and file system_Linux system disk](~~ 111738 ~~).

-Supports the resize2fs command. To support this command, you need to install the "e2fsprogs" package, which is installed in the operating system by default. If it is not installed, you need to install it yourself.

-The latest version of cloud-init is installed in the operating system. cloud-init version 19.1 must be in version 19.1.3 or later, and cloud-init version 0.7.6a in some earlier operating systems must be in version 0.7.6 a15 or later. For more information, see [install cloud-init](~~ 57803 ~~).
 */
async function importImage(request: ImportImageRequest): ImportImageResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ImportImage', 'POST', 'undefined', 'json', false, 'none', request);
}

model ModifyForwardEntryRequest {
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  forwardTableId?: string(name='ForwardTableId', position='Query'),
  forwardEntryId?: string(name='ForwardEntryId', position='Query'),
  externalIp?: string(name='ExternalIp', position='Query'),
  externalPort?: string(name='ExternalPort', position='Query'),
  internalIp?: string(name='InternalIp', position='Query'),
  internalPort?: string(name='InternalPort', position='Query'),
  ipProtocol?: string(name='IpProtocol', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
}

model ModifyForwardEntryResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyForwardEntryResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyForwardEntryResponseBody(name='body'),
}

async function modifyForwardEntry(request: ModifyForwardEntryRequest): ModifyForwardEntryResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyForwardEntry', 'POST', 'undefined', 'json', false, 'none', request);
}

model RenewInstanceRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', description='The ID of the RAM user.', position='Query'),
  instanceId?: string(name='InstanceId', description='The ID of the instance to be renewed.', position='Query'),
  periodUnit?: string(name='PeriodUnit', description='The unit of the renewal Period. Valid values:

-<props="china">Week</props>
-Month (default)
', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', description='The ID of the resource master account, that is, the UID.', position='Query'),
  period?: int32(name='Period', description='The subscription duration. If "DedicatedHostId" is specified, the value range cannot exceed the subscription duration of the dedicated host. Valid values:

-<props = "china"> the value of "Dune" is "Week ". Valid values of "1": 1 to 4</props>

-The value of "Dune" is "Month ". "period" values are: 1~12, 24, 36, 48, 60


> you must specify one of the renewal period parameters ("1", "1" Dune") or the unified expiration date parameter ("ExpectedRenewDay"). However, you cannot set this parameter at the same time.', position='Query'),
  clientToken?: string(name='ClientToken', description='Ensure the idempotence of the request. Generate a parameter value from your client. Make sure that the value is unique among different requests. **ClientToken** supports only ASCII characters and cannot exceed 64 characters. For more information, see [how to ensure idempotence](~~ 25693 ~~).', position='Query'),
  expectedRenewDay?: int32(name='ExpectedRenewDay', description='Unified expiration date. The value of this parameter must be consistent with the specified expiration date. Otherwise, the call fails. If you specify this parameter, your instance will be renewed to the unified expiration date. Valid values: 1 to 28.

For more information about the limits of the unified expiration date feature, see [unified instance expiration date](~~ 108486 ~~).

> you must specify one of the renewal period parameters ("1", "1" Dune") or the unified expiration date parameter ("ExpectedRenewDay"). However, you cannot set this parameter at the same time.', position='Query'),
}

model RenewInstanceResponseBody = {
  orderId?: string(name='OrderId', description='The ID of the order.'),
  requestId?: string(name='RequestId', description='The ID of the request.'),
}

model RenewInstanceResponse = {
  headers: map[string]string(name='headers'),
  body: RenewInstanceResponseBody(name='body'),
}

/**
 * ## API description

<props = "china"> make sure that you have fully understood the billing method and product pricing of [ECS](https://www.aliyun.com/price/product#/ecs/detail) before using this interface. </props>

<props = "intl"> make sure that you have fully understood the billing method and product pricing of [ECS](https://www.alibabacloud.com/product/ecs#pricing) before using this interface. </props>

When you call this operation, note that:

-You can only renew a subscription ECS instance for a period of time or to a unified expiration date.

-The renewal period and the operation to the unified expiration date of the instance cannot be performed synchronously. That is, one of the renewal period parameters ("renew", "renewdune") and the unified expiration date parameters ("ExpectedRenewDay") must be specified, but cannot be set at the same time.

-<props = "china"> your account must support account balance payment or credit payment. </props>

-<props = "intl"> your account must support credit payment. </props>

-<props = "partner"> your account must support credit payment. </props>

 */
async function renewInstance(request: RenewInstanceRequest): RenewInstanceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'RenewInstance', 'POST', 'undefined', 'json', false, 'none', request);
}

model CopyImageRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  encryptAlgorithm?: string(name='EncryptAlgorithm', position='Query'),
  tag?: [ 
    {
      key?: string(name='Key', description='复制后的镜像的标签键。N的取值范围：1~20。一旦传入该值，则不允许为空字符串。最多支持128个字符，不能以`aliyun`和`acs:`开头，不能包含`http://`或者`https://`。'),
      value?: string(name='Value', description='复制后的镜像的标签值。N的取值范围：1~20。一旦传入该值，可以为空字符串。最多支持128个字符，不能以`acs:`开头，不能包含`http://`或者`https://`。'),
    }
  ](name='Tag', position='Query'),
  ownerId?: long(name='OwnerId', description='The ID of the RAM user.', position='Query'),
  regionId?: string(name='RegionId', description='The ID of the region from which the image is defined. You can call [DescribeRegions](~~ 25609 ~~) to view the latest region list.', position='Query'),
  destinationRegionId?: string(name='DestinationRegionId', description='The ID of the destination region.', position='Query'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the Resource Group of the copied image.', position='Query'),
  imageId?: string(name='ImageId', description='The ID of the custom image.', position='Query'),
  KMSKeyId?: string(name='KMSKeyId', description='The accesskey ID used to encrypt the image.', position='Query'),
  encrypted?: boolean(name='Encrypted', description='Specifies whether to encrypt the copied image.

Default value: false', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='The account name of the resource master account.', position='Query'),
  destinationImageName?: string(name='DestinationImageName', description='The name of the copied image. The description must be 2 to 128 characters in length. It must start with a letter and cannot start with aliyun" or ACS: ". It cannot contain "http://" or "https://". It can contain numbers, periods (.), colons (:), underscores (_), and hyphens (-).

Default value: Null.', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', description='The ID of the resource master account, that is, the UID.', position='Query'),
  destinationDescription?: string(name='DestinationDescription', description='The description of the copied image. The description must be 2 to 256 characters in length and cannot start with "http:// "or "https.

Default value: Null.', position='Query'),
}

model CopyImageResponseBody = {
  imageId?: string(name='ImageId', description='The ID of the copied image.'),
  requestId?: string(name='RequestId', description='The ID of the request.'),
}

model CopyImageResponse = {
  headers: map[string]string(name='headers'),
  body: CopyImageResponseBody(name='body'),
}

/**
 * ## API description

You can use the copied image to create an ECS instance (RunInstances) in another region, or change the system disk (ReplaceSystemDisk) of the instance.

When you call this operation, note that:

-The custom image must be in the available status ("Available").

-The source image must be an image under your account and cannot be copied across accounts.

-When you copy an image, you cannot delete the copied image ([DeleteImage](~~ 25537 ~~), but you can cancel the copy task ([CancelCopyImage](~~ 25539 ~~)).

-Only one image copy task can be run in the same region. Other tasks must be queued until the last task is completed.
 */
async function copyImage(request: CopyImageRequest): CopyImageResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CopyImage', 'POST', 'undefined', 'json', false, 'none', request);
}

model CreateVpcRequest {
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  cidrBlock?: string(name='CidrBlock', position='Query'),
  vpcName?: string(name='VpcName', position='Query'),
  description?: string(name='Description', position='Query'),
  clientToken?: string(name='ClientToken', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  userCidr?: string(name='UserCidr', position='Query'),
}

model CreateVpcResponseBody = {
  vpcId?: string(name='VpcId'),
  VRouterId?: string(name='VRouterId'),
  requestId?: string(name='RequestId'),
  routeTableId?: string(name='RouteTableId'),
}

model CreateVpcResponse = {
  headers: map[string]string(name='headers'),
  body: CreateVpcResponseBody(name='body'),
}

async function createVpc(request: CreateVpcRequest): CreateVpcResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateVpc', 'POST', 'undefined', 'json', false, 'none', request);
}

model DescribeInstanceMonitorDataRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  period?: int32(name='Period', description='The interval between obtaining monitoring data. Unit: seconds. Valid values:

-60
-600
-3600

Default value: 60', position='Query'),
  instanceId?: string(name='InstanceId', description='The ID of the instance to be queried.', position='Query'),
  startTime?: string(name='StartTime', description='The start time of obtaining data. The time follows the [ISO8601](~~ 25696 ~~) standard and uses UTC +0. The format is yyyy-MM-ddTHH:mm:ssZ. If the specified number of seconds is not "00", it is automatically converted to the next minute.', position='Query'),
  endTime?: string(name='EndTime', description='The end of the time range to query data. The time follows the [ISO8601](~~ 25696 ~~) standard and uses UTC +0. The format is yyyy-MM-ddTHH:mm:ssZ. If the specified number of seconds is not "00", it is automatically converted to the next minute.', position='Query'),
}

model DescribeInstanceMonitorDataResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.'),
  monitorData?: {
    instanceMonitorData?: [ 
    {
      CPUCreditBalance?: float(name='CPUCreditBalance', description='The total number of credits for burstable instances.'),
      BPSRead?: int32(name='BPSRead', description='The read bandwidth of the instance disk, including the system disk and data disk. Unit: Byte/s.'),
      internetTX?: int32(name='InternetTX', description='When you query monitoring information ("TimeStamp"), the public network data traffic sent by the instance within the specified interval ("1"). Unit: kbits.'),
      CPU?: int32(name='CPU', description='The percentage of the vCPU used by the instance. Unit: Percentage (%).'),
      CPUCreditUsage?: float(name='CPUCreditUsage', description='The number of credits used by the burstable instance.'),
      IOPSWrite?: int32(name='IOPSWrite', description='I/O write operations on cloud disks (including system disks and data disks) of the instance. Unit: Times/s.'),
      intranetTX?: int32(name='IntranetTX', description='The intranet data traffic sent by the instance within the specified interval ("timestamp") when the monitoring information is queried. Unit: kbits.'),
      instanceId?: string(name='InstanceId', description='The ID of the instance.'),
      BPSWrite?: int32(name='BPSWrite', description='The write bandwidth of the cloud disk (including the system disk and data disk) of the instance. Unit: Byte/s.'),
      CPUNotpaidSurplusCreditUsage?: float(name='CPUNotpaidSurplusCreditUsage', description='Excess unpaid points.'),
      CPUAdvanceCreditBalance?: float(name='CPUAdvanceCreditBalance', description='Excess credits (the excess credits of burstable instances).'),
      IOPSRead?: int32(name='IOPSRead', description='The I/O read operation of the instance disk (including the system disk and data disk). Unit: Times/s.'),
      internetBandwidth?: int32(name='InternetBandwidth', description='The Internet bandwidth of the instance. Unit: kbits/s.'),
      internetRX?: int32(name='InternetRX', description='When you query monitoring information ("TimeStamp"), the public network data traffic received by the instance within the specified interval ("1"). Unit: kbits.'),
      timeStamp?: string(name='TimeStamp', description='The timestamp used to query monitoring information.'),
      intranetRX?: int32(name='IntranetRX', description='The intranet data traffic received by the instance within the specified interval ("renew") when the monitoring information is queried ("TimeStamp"). Unit: kbits.'),
      intranetBandwidth?: int32(name='IntranetBandwidth', description='The internal bandwidth of the instance. Unit: kbits/s.'),
    }
  ](name='InstanceMonitorData')
  }(name='MonitorData', description='The monitoring data set of the instance.'),
}

model DescribeInstanceMonitorDataResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeInstanceMonitorDataResponseBody(name='body'),
}

/**
 * ## API description

When you call this operation, note that:

-A maximum of 400 monitoring data records can be returned at a time. If the specified parameter "(EndTime-StartTime)/" is greater than 400, an error message is returned.

-You can query the monitoring information in the last 30 days at a time. If the specified "StartTime" parameter exceeds 30 days, an error message is returned.

-If a part of the returned information is missing, the system may not obtain the corresponding information. For example, the instance is in the Stopped (Stopped) state.
 */
async function describeInstanceMonitorData(request: DescribeInstanceMonitorDataRequest): DescribeInstanceMonitorDataResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeInstanceMonitorData', 'POST', 'undefined', 'json', false, 'none', request);
}

model DeleteDedicatedHostClusterRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  dedicatedHostClusterId?: string(name='DedicatedHostClusterId', description='The ID of the DDH cluster.', position='Query'),
  regionId?: string(name='RegionId', description='The region ID of the DDH cluster. You can call [DescribeRegions](~~ 25609 ~~) to view the latest region list.', position='Query'),
}

model DeleteDedicatedHostClusterResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.'),
}

model DeleteDedicatedHostClusterResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteDedicatedHostClusterResponseBody(name='body'),
}

async function deleteDedicatedHostCluster(request: DeleteDedicatedHostClusterRequest): DeleteDedicatedHostClusterResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteDedicatedHostCluster', 'POST', 'undefined', 'json', false, 'none', request);
}

model CreateMaintenancePropertyRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  startTime?: string(name='StartTime', position='Query'),
  endTime?: string(name='EndTime', position='Query'),
  actionOnMaintenance?: string(name='ActionOnMaintenance', position='Query'),
  instanceId?: [ string ](name='InstanceId', position='Query'),
}

model CreateMaintenancePropertyResponseBody = {
  requestId?: string(name='RequestId'),
}

model CreateMaintenancePropertyResponse = {
  headers: map[string]string(name='headers'),
  body: CreateMaintenancePropertyResponseBody(name='body'),
}

async function createMaintenanceProperty(request: CreateMaintenancePropertyRequest): CreateMaintenancePropertyResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateMaintenanceProperty', 'POST', 'undefined', 'json', false, 'none', request);
}

model CreateStorageSetRequest {
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  zoneId?: string(name='ZoneId', description='The zone to which the bucket belongs. You can call [DescribeZones](~~ 25610 ~~) to query the latest zone list.', position='Query'),
  description?: string(name='Description', description='The description of the storage set. The description must be 2 to 256 characters in length and cannot start with http:// or https.', position='Query'),
  clientToken?: string(name='ClientToken', description='Ensure the idempotence of the request. Generate a parameter value from your client. Make sure that the value is unique among different requests. **ClientToken** supports only ASCII characters and cannot exceed 64 characters. For more information, see [how to ensure idempotence](~~ 25693 ~~).', position='Query'),
  regionId?: string(name='RegionId', description='The region to which the bucket belongs. You can call [DescribeRegions](~~ 25609 ~~) to view the latest region list.', position='Query'),
  maxPartitionNumber?: int32(name='MaxPartitionNumber', description='The maximum partition size of the Storage Set. The maximum partition number supported by the StorageSet. Valid values: 2 to 2. The maximum value cannot exceed the quota displayed after [DescribeAccountAttributes](~~ 73772 ~~) is called.

Default value: 2.', position='Query'),
  storageSetName?: string(name='StorageSetName', description='The name of the storage set. The description must be 2 to 128 characters in length. It must start with a letter and cannot start with http:// or https. It can contain numbers, colons (:), underscores (_), and hyphens (-).', position='Query'),
}

model CreateStorageSetResponseBody = {
  storageSetId?: string(name='StorageSetId', description='The ID of the storage set.'),
  requestId?: string(name='RequestId', description='The ID of the request.'),
}

model CreateStorageSetResponse = {
  headers: map[string]string(name='headers'),
  body: CreateStorageSetResponseBody(name='body'),
}

/**
 * ## API description

A storage set can distribute cloud disks or shared block storage. You can set the number of partitions for a storage set. A larger number of partitions indicates that the physical locations of cloud disks or shared block storage are more dispersed.

When you use this API, note the following:

-You can have a maximum of buckets in a region. You can call [DescribeAccountAttributes](~~ 73772 ~~) to query the number limit.

-The number of partitions that you can specify in a zone is limited. You can call [DescribeAccountAttributes](~~ 73772 ~~) to query the number limit.
 */
async function createStorageSet(request: CreateStorageSetRequest): CreateStorageSetResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateStorageSet', 'POST', 'undefined', 'json', false, 'none', request);
}

model DetachKeyPairRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  instanceIds?: string(name='InstanceIds', description='The ID of the instance to which the SSH key pair is unbound. The value can be a JSON Array consisting of multiple instance IDs. A maximum of 50 IDs can be specified. Separate IDs with commas (,).', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='The account name of the resource master account.', position='Query'),
  ownerId?: long(name='OwnerId', description='The ID of the RAM user.', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', description='The ID of the resource master account, that is, the UID.', position='Query'),
  keyPairName?: string(name='KeyPairName', description='The name of the SSH key pair.', position='Query'),
  regionId?: string(name='RegionId', description='The region ID of the SSH key pair. You can call [DescribeRegions](~~ 25609 ~~) to view the latest region list.', position='Query'),
}

model DetachKeyPairResponseBody = {
  keyPairName?: string(name='KeyPairName', description='The name of the key pair.'),
  requestId?: string(name='RequestId', description='The ID of the request.'),
  totalCount?: string(name='TotalCount', description='The total number of instances that unbind the key pair.'),
  failCount?: string(name='FailCount', description='The number of instances that failed to unbind the key pair.'),
  results?: {
    result?: [ 
    {
      code?: string(name='Code', description='The operation status code. A value of 200 indicates that the operation is successful.'),
      message?: string(name='Message', description='The operation information. For example, when "Code = 200", "Message" is "successful ".'),
      instanceId?: string(name='InstanceId', description='The ID of the instance.'),
      success?: string(name='Success', description='Indicates whether the operation is successful.'),
    }
  ](name='Result')
  }(name='Results', description='A collection of results that are successfully or failed to unbind a key pair.'),
}

model DetachKeyPairResponse = {
  headers: map[string]string(name='headers'),
  body: DetachKeyPairResponseBody(name='body'),
}

/**
 * ## API description

When you call this operation, note the following:

-After unbinding the SSH key pair, you need to restart the instance ([RebootInstance](~~ 25502 ~~)) for the change to take effect.
-After the SSH key pair is Unbound, the instance uses the username and password authentication method by default.
 */
async function detachKeyPair(request: DetachKeyPairRequest): DetachKeyPairResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DetachKeyPair', 'POST', 'undefined', 'json', false, 'none', request);
}

model DescribeTasksRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', description='The ID of the resource master account, that is, the UID.', position='Query'),
  taskIds?: string(name='TaskIds', description='The ID of the task. You can specify a maximum of 100 task IDs at a time. Separate the IDs with commas (,).', position='Query'),
  taskAction?: string(name='TaskAction', description='The operation that you want to perform. Valid values:

-ImportImage: import images
-ExportImage: export images
-RedeployInstance: redeploy the ECS instance
-ModifyDiskSpec: change the disk type', position='Query'),
  taskStatus?: string(name='TaskStatus', description='The status of the task. Valid values:

-Finished: Completed
-Processing: Running
-Failed: Failed.

Default value: None
> only tasks in the Finished, Processing, and Failed status can be queried. If you enter other values, the query will not take effect.', position='Query'),
  pageNumber?: int32(name='PageNumber', description='The page number of the query result.

Start value: 1

Default value: 1.', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='The account name of the resource master account.', position='Query'),
  ownerId?: long(name='OwnerId', description='The ID of the RAM user.', position='Query'),
  pageSize?: int32(name='PageSize', description='The number of entries to return on each page.

Maximum Value: 100

Default value: 10', position='Query'),
  regionId?: string(name='RegionId', description='The ID of the region. You can call [DescribeRegions](~~ 25609 ~~) to view the latest region list.', position='Query'),
  endTime?: string(name='EndTime', description='The end of the creation time range. The time follows the [ISO8601](~~ 25696 ~~) standard and uses UTC +0. The format is yyyy-MM-ddTHH:mm:ssZ.', position='Query'),
  startTime?: string(name='StartTime', description='The start point of the creation time interval. The time follows the [ISO8601](~~ 25696 ~~) standard and uses UTC +0. The format is yyyy-MM-ddTHH:mm:ssZ.', position='Query'),
}

model DescribeTasksResponseBody = {
  pageSize?: int32(name='PageSize', description='The number of entries in the current page.'),
  pageNumber?: int32(name='PageNumber', description='The current page number.'),
  requestId?: string(name='RequestId', description='The ID of the request.'),
  totalCount?: int32(name='TotalCount', description='The number of entries in the list.'),
  regionId?: string(name='RegionId', description='The ID of the region.'),
  taskSet?: {
    task?: [ 
    {
      creationTime?: string(name='CreationTime', description='The creation time.'),
      taskStatus?: string(name='TaskStatus', description='The status of the task.'),
      finishedTime?: string(name='FinishedTime', description='The end time.'),
      supportCancel?: string(name='SupportCancel', description='Indicates whether the task can be canceled.'),
      taskId?: string(name='TaskId', description='The ID of the task.'),
      taskAction?: string(name='TaskAction', description='The name of the task.'),
    }
  ](name='Task')
  }(name='TaskSet', description='The collection of tasks.'),
}

model DescribeTasksResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeTasksResponseBody(name='body'),
}

async function describeTasks(request: DescribeTasksRequest): DescribeTasksResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeTasks', 'POST', 'undefined', 'json', false, 'none', request);
}

model DescribeRenewalPriceRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='The account name of the resource master account.', position='Query'),
  regionId?: string(name='RegionId', description='The ID of the region to which the instance belongs. You can call [DescribeRegions](~~ 25609 ~~) to view the latest region list.', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', description='The ID of the resource master account, that is, the UID.', position='Query'),
  ownerId?: long(name='OwnerId', description='The ID of the RAM user.', position='Query'),
  period?: int32(name='Period', description='The renewal duration. Valid values:

-If the value of "PriceUnit" is "Month", valid values: 1 to 9.
-If the value of "PriceUnit" is "Year", valid values: 1 to 3.

Default value: 1.

> you cannot set the renewal duration parameter ("1", "1" Dune") and the unified expiration date parameter ("ExpectedRenewDay") at the same time.', position='Query'),
  priceUnit?: string(name='PriceUnit', description='The renewal period. Valid values:

-Month: the renewal period is one Month.
-Year: the renewal period is one Year.

Default value: Month', position='Query'),
  resourceType?: string(name='ResourceType', description='Query the resource type of the renewal price. Value: instance

Default value: instance', position='Query'),
  resourceId?: string(name='ResourceId', description='The ID of the resource to query the renewal price. When the value of "ResourceType" is "instance", "ResourceId" can be interpreted as "InstanceId ".', position='Query'),
  expectedRenewDay?: int32(name='ExpectedRenewDay', description='Unified expiration date. If this parameter is specified, the price of the instance to the unified expiration date is queried. Valid values: 1 to 28.

For more information about the unified expiration date feature, see [unified instance expiration date](~~ 108486 ~~).

> you cannot set the renewal duration parameter ("1", "1" Dune") and the unified expiration date parameter ("ExpectedRenewDay") at the same time.', position='Query'),
}

model DescribeRenewalPriceResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.'),
  priceInfo?: {
    rules?: {
      rule?: [ 
      {
        description?: string(name='Description', description='The description of the activity rule.'),
        ruleId?: long(name='RuleId', description='The ID of the activity.'),
      }
    ](name='Rule')
    }(name='Rules', description='The activity rule.'),
    price?: {
      originalPrice?: float(name='OriginalPrice', description='Original price.'),
      discountPrice?: float(name='DiscountPrice', description='Discount.'),
      currency?: string(name='Currency', description='The unit of currency.'),
      tradePrice?: float(name='TradePrice', description='The final price, which is the original price minus the discount.'),
      detailInfos?: {
        resourcePriceModel?: [ 
        {
          resource?: string(name='Resource', description='The name of the resource corresponding to the price.'),
          originalPrice?: float(name='OriginalPrice', description='Original price.'),
          discountPrice?: float(name='DiscountPrice', description='Discount price.'),
          tradePrice?: float(name='TradePrice', description='The transaction price.'),
        }
      ](name='ResourcePriceModel')
      }(name='DetailInfos', description='Resource pricing details.'),
    }(name='Price', description='The price.'),
  }(name='PriceInfo', description='The data type consisting of price information types (PriceInfo), including price and discount rule information.'),
}

model DescribeRenewalPriceResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeRenewalPriceResponseBody(name='body'),
}

/**
 * ## API description

-You can only query the renewal duration of a subscription ECS instance or the renewal price on the unified expiration date.

-Note the following when setting parameters:

-If only required parameters are set, the instance renewal period of one month is queried by default.
-You cannot query the renewal period price and the renewal price to the unified expiration date at the same time. That is, the renewal period parameter ("renew", "renewdune") and the renewal to the unified expiration date parameter ("ExpectedRenewDay") cannot be set at the same time.

 */
async function describeRenewalPrice(request: DescribeRenewalPriceRequest): DescribeRenewalPriceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeRenewalPrice', 'POST', 'undefined', 'json', false, 'none', request);
}

model DescribeInstanceAutoRenewAttributeRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  resourceOwnerId?: long(name='ResourceOwnerId', description='The ID of the resource master account, that is, the UID.', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='The account name of the resource master account.', position='Query'),
  ownerId?: long(name='OwnerId', description='The ID of the RAM user.', position='Query'),
  regionId?: string(name='RegionId', description='The ID of the region to which the instance belongs. You can call [DescribeRegions](~~ 25609 ~~) to view the latest region list.', position='Query'),
  ownerAccount?: string(name='OwnerAccount', description='The logon name of the RAM user.', position='Query'),
  instanceId?: string(name='InstanceId', description='The ID of the instance. You can query up to 100 subscription instances in batches. Separate multiple instance IDs with commas (,).

You must specify at least one of the "InstanceId" and "RenewalStatus" parameters.', position='Query'),
  pageNumber?: string(name='PageNumber', description='The page number of the returned resource information list.

Start value: 1

Default value: 1.', position='Query'),
  pageSize?: string(name='PageSize', description='The number of entries to return on each page. Unit: rows.

Maximum Value: 100

Default value: 10', position='Query'),
  renewalStatus?: string(name='RenewalStatus', description='The automatic renewal status of the instance. Valid values:

-AutoRenewal: set to automatic renewal.

-Normal: Cancels automatic renewal.

-NotRenewal: no renewal is required. The system does not send expiration reminders, but only sends non-renewal reminders three days before expiration. If you no longer renew an ECS instance, you can change it from [ModifyInstanceAutoRenewAttribute](~~ 52843 ~~) to pending ("Normal"), and then renew it by yourself or set it to automatic.', position='Query'),
}

model DescribeInstanceAutoRenewAttributeResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.'),
  pageNumber?: int32(name='PageNumber', description='The page number.'),
  pageSize?: int32(name='PageSize', description='The number of rows per page.'),
  totalCount?: int32(name='TotalCount', description='The total number of returned instances.'),
  instanceRenewAttributes?: {
    instanceRenewAttribute?: [ 
    {
      periodUnit?: string(name='PeriodUnit', description='The unit of the automatic renewal period.'),
      duration?: int32(name='Duration', description='The automatic renewal period.'),
      renewalStatus?: string(name='RenewalStatus', description='The automatic renewal status of the instance. Possible values:

-AutoRenewal: set to automatic renewal.

-Normal: Cancels automatic renewal.

-NotRenewal: no renewal is required. The system does not send expiration reminders, but only sends non-renewal reminders three days before expiration. If you no longer renew an ECS instance, you can change it from [ModifyInstanceAutoRenewAttribute](~~ 52843 ~~) to pending ("Normal"), and then renew it by yourself or set it to automatic.'),
      instanceId?: string(name='InstanceId', description='The ID of the instance.'),
      autoRenewEnabled?: boolean(name='AutoRenewEnabled', description='Indicates whether automatic renewal is enabled.'),
    }
  ](name='InstanceRenewAttribute')
  }(name='InstanceRenewAttributes', description='A collection of instance renewal attributes InstanceRenewAttribute.'),
}

model DescribeInstanceAutoRenewAttributeResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeInstanceAutoRenewAttributeResponseBody(name='body'),
}

/**
 * ## API description

-Before setting auto-renewal or manual renewal, you can check whether the instance renewal status is automatic.

-Only subscription instances are supported. If you call this operation on a pay-as-you-go instance, an error is returned.
 */
async function describeInstanceAutoRenewAttribute(request: DescribeInstanceAutoRenewAttributeRequest): DescribeInstanceAutoRenewAttributeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeInstanceAutoRenewAttribute', 'POST', 'undefined', 'json', false, 'none', request);
}

model DeletePrefixListRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  regionId?: string(name='RegionId', description='The ID of the region.', position='Query'),
  prefixListId?: string(name='PrefixListId', description='The ID of the prefix list.', position='Query'),
}

model DeletePrefixListResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.'),
}

model DeletePrefixListResponse = {
  headers: map[string]string(name='headers'),
  body: DeletePrefixListResponseBody(name='body'),
}

/**
 * ## API description

If the Prefix List is associated with other resources, you cannot delete it directly. You must remove the prefix list from other resources before deleting it. You can call [DescribePrefixListAssociations](~~ 204724 ~~) to query the associated resources of a specified prefix list.
 */
async function deletePrefixList(request: DeletePrefixListRequest): DeletePrefixListResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeletePrefixList', 'POST', 'undefined', 'json', false, 'none', request);
}

model ModifySecurityGroupRuleRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  securityGroupId?: string(name='SecurityGroupId', description='The ID of the Target security group.', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', description='The ID of the resource master account, that is, the UID.', position='Query'),
  ownerId?: long(name='OwnerId', description='The ID of the RAM user.', position='Query'),
  regionId?: string(name='RegionId', description='The region ID of the Target security group. You can call [DescribeRegions](~~ 25609 ~~) to view the latest region list.', position='Query'),
  destCidrIp?: string(name='DestCidrIp', description='The Destination IPv4 CIDR block. CIDR and IPv4 IP addresses are supported.

Default value: None', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='The account name of the resource master account.', position='Query'),
  sourceGroupOwnerId?: long(name='SourceGroupOwnerId', description='The ID of the Alibaba Cloud account to which the source Security Group belongs.

-If "SourceGroupOwnerId" and "SourceGroupOwnerAccount" are not set, the access permissions of other security groups are set.
-If you have set the "SourceCidrIp" parameter, the "SourceGroupOwnerId" parameter is invalid.', position='Query'),
  ipv6DestCidrIp?: string(name='Ipv6DestCidrIp', description='The Destination IPv6 CIDR block. CIDR and IPv6 IP addresses are supported.

> only VPC-type IP addresses are supported.

Default value: None', position='Query'),
  portRange?: string(name='PortRange', description='The port range related to the transport layer protocol opened by the destination security group. Valid values:

-TCP/UDP: valid values: 1 to 65535. Use a slash (/) to separate the start port from the end port. Example: 1/200
-ICMP:-1/-1
-GRE protocol:-1/-1
-all:-1/-1', position='Query'),
  sourceGroupOwnerAccount?: string(name='SourceGroupOwnerAccount', description='The Alibaba Cloud account to which the source Security Group belongs.

-If "SourceGroupOwnerAccount" and "SourceGroupOwnerID" are not set, the access permissions of other security groups are set.
-If the "SourceCidrIp" parameter is set, the "SourceGroupOwnerAccount" parameter is invalid.', position='Query'),
  description?: string(name='Description', description='The description of the security group rule. The description must be 1 to 512 characters in length.', position='Query'),
  clientToken?: string(name='ClientToken', description='Ensure the idempotence of the request. Generate a parameter value from your client. Make sure that the value is unique among different requests. **ClientToken** supports only ASCII characters and cannot exceed 64 characters. For more information, see [how to ensure idempotence](~~ 25693 ~~).', position='Query'),
  ipProtocol?: string(name='IpProtocol', description='The transport layer protocol. Case insensitive. Valid values:

-icmp
-gre
-tcp
-udp
-all: all protocols are supported.', position='Query'),
  sourceCidrIp?: string(name='SourceCidrIp', description='Set the source IPv4 CIDR block for the access permission. CIDR and IPv4 IP addresses are supported.

Default value: None', position='Query'),
  ipv6SourceCidrIp?: string(name='Ipv6SourceCidrIp', description='Set the Source IPv6 CIDR block for the access permission. CIDR and IPv6 IP addresses are supported.

> only VPC-type IP addresses are supported.

Default value: None', position='Query'),
  priority?: string(name='Priority', description='The priority of the security group rule. Valid values: 1 to 100.

Default value: 1.', position='Query'),
  sourcePortRange?: string(name='SourcePortRange', description='The range of ports related to the transport layer protocol opened by the source security group. Valid values:

-TCP/UDP: valid values: 1 to 65535. Use a slash (/) to separate the start port from the end port. Example: 1/200
-ICMP:-1/-1
-GRE protocol:-1/-1
-all:-1/-1', position='Query'),
  policy?: string(name='Policy', description='The access permission. Valid values:

-accept: Accepts access.
-drop: The request is denied. No deny message is returned.

Default value: accept', position='Query'),
  nicType?: string(name='NicType', description='The NIC type of the classic network security group rule. Valid values:

-internet: public network
-intranet: intranet

Default value: internet

In the following cases, the parameter NicType can only be set to intranet:

-If the network type of the security group rule is VPC, you must set the NicType parameter, which can only be intranet.
-If you set the mutual access between security groups, that is, only the "SourceGroupId" parameter is specified, it can only be set to intranet.

', position='Query'),
  sourcePrefixListId?: string(name='SourcePrefixListId', description='The ID of the source prefix list. You can call [DescribePrefixLists](~~ 205046 ~~) to query the list IDs of available prefixes.

If you specify one of the "SourceCidrIp", "Ipv6SourceCidrIp", or "SourceGroupId" parameters, this parameter is ignored.', position='Query'),
  sourceGroupId?: string(name='SourceGroupId', description='The ID of the source security group. Set at least one "SourceGroupId" or "SourceCidrIp" parameter.

-If "SourceGroupId" is specified but "SourceCidrIp" is not specified, the value of "NicType" can only be intranet.
-If both "SourceGroupId" and "SourceCidrIp" are specified, the default value is "SourceCidrIp.', position='Query'),
}

model ModifySecurityGroupRuleResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.'),
}

model ModifySecurityGroupRuleResponse = {
  headers: map[string]string(name='headers'),
  body: ModifySecurityGroupRuleResponseBody(name='body'),
}

/**
 * ## API description

In the security group-related API documents, the initiator of inbound traffic is the Source, and the receiver of data transmission is the Dest.

Any of the following parameters can determine an inbound rule of a security group, but only one parameter cannot determine a security group rule.

-Rules for authorizing access from specified CIDR blocks. For example, IpProtocol, PortRange, (optional) SourcePortRange, NicType, Policy, (optional) DestCidrIp, and SourceCidrIp.

"""
https://ecs.aliyuncs.com/? Action=ModifySecurityGroupRule
&SecurityGroupId=sg-bp67acfmxazb4p ****
&SourceCidrIp=10.0.0.0/8
&IpProtocol=tcp
&PortRange=80/80
&Policy=accept
&Description=This is a new security group rule.
& <common request parameters>
"""

-Rules for authorizing access from other security groups. For example, IpProtocol, PortRange, (optional) SourcePortRange, NicType, Policy, (optional) DestCidrIp, and SourceGroupId.

"""
https://ecs.aliyuncs.com/? Action=ModifySecurityGroupRule
&SecurityGroupId=sg-bp67acfmxazb4p ****
&SourceGroupId=sg-bp67acfmxa123b ****
&IpProtocol=tcp
&PortRange=80/80
&Policy=accept
&Description=This is a new security group rule.
& <common request parameters>
"""

-Security group rules associated with the prefix list. For example, IpProtocol, PortRange, (optional) SourcePortRange, NicType, Policy, (optional) DestCidrIp, and SourcePrefixListId.

"""
https://ecs.aliyuncs.com/? Action=ModifySecurityGroupRule
&SecurityGroupId=sg-bp67acfmxazb4p ****
&SourcePrefixListId=pl-x1j1k5ykzqlixdcy ****
&IpProtocol=tcp
&PortRange=80/80
&Policy=accept
&Description=This is a new security group rule.
& <common request parameters>
"""
 */
async function modifySecurityGroupRule(request: ModifySecurityGroupRuleRequest): ModifySecurityGroupRuleResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifySecurityGroupRule', 'POST', 'undefined', 'json', false, 'none', request);
}

model DescribeResourcesModificationRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', description='The ID of the RAM user.', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', description='The ID of the resource master account, that is, the UID.', position='Query'),
  memory?: float(name='Memory', description='The memory size of the instance type. Unit: GiB. For more information, see [instance type family](~~ 25378 ~~). Memory is a valid parameter only when DestinationResource is set to InstanceType.', position='Query'),
  instanceType?: string(name='InstanceType', description='The instance type. For more information, see [instance type family](~~ 25378 ~~), or call [DescribeInstanceTypes](~~ 25620 ~~) to obtain the latest specification. If the parameter DestinationResource is set to SystemDisk, you must specify the InstanceType parameter at the same time.', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='The account name of the resource master account.', position='Query'),
  regionId?: string(name='RegionId', description='The ID of the destination region. You can call [DescribeRegions](~~ 25609 ~~) to view the latest region list.', position='Query'),
  migrateAcrossZone?: boolean(name='MigrateAcrossZone', description='Indicates whether the instance type can be upgraded across clusters. Valid values:

-true: Supported
-false: not supported

Default value: false

If the MigrateAcrossZone parameter is set to true, note the following when you upgrade the ECS instance based on the returned information:

-Classic network type instance:
-For [phased-out instance types](~~ 55263 ~~), when a non-I/O optimized instance is changed to an I/O optimized instance, the private IP address of the instance, the device name and software authorization code of the cloud disk change. For Linux instances, basic cloud disks are identified as xvda or xvdb, and ultra cloud disks (cloud_efficiency) and SSD cloud disks (cloud_ssd) are identified as vda or vdb.
-For [normal instance type families](~~ 25378 ~~), the private IP address of the instance changes.

-VPC instances: for [phased-out instance types](~~ 55263 ~~), when non-I/O optimized instances are changed to I/O optimized instances, the device name and software authorization code of the cloud disk change. For Linux instances, basic cloud disks are identified as xvda or xvdb, and ultra cloud disks (cloud_efficiency) and SSD cloud disks (cloud_ssd) are identified as vda or vdb.', position='Query'),
  resourceId?: string(name='ResourceId', description='The ID of the resource. For example, if the resource to be queried is an instance, it can be understood as InstanceId.', position='Query'),
  destinationResource?: string(name='DestinationResource', description='The type of the target resource. Valid values:

-InstanceType: instance type
-SystemDisk: system disk type', position='Query'),
  operationType?: string(name='OperationType', description='Change the operation type of the resource configuration.

-Valid values of subscription resources:

-Upgrade: Upgrade resources
-Downgrade: Downgrade resources
-RenewDowngrade: renewal and downgrade
-RenewModify: renewal and configuration change for expired instances

-The value of the pay-as-you-go resource is Upgrade.

Default value: Upgrade', position='Query'),
  cores?: int32(name='Cores', description='The number of vCPU cores of the instance type. For more information, see [instance type family](~~ 25378 ~~). If DestinationResource = InstanceType parameter is valid, Cores is the valid parameter.', position='Query'),
}

model DescribeResourcesModificationResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.'),
  availableZones?: {
    availableZone?: [ 
    {
      zoneId?: string(name='ZoneId', description='The ID of the zone.'),
      status?: string(name='Status', description='The status of the resource. Possible values:

-Available: sufficient resources
-SoldOut: resources are sold out
'),
      statusCategory?: string(name='StatusCategory', description='Resource categories are classified by inventory. Possible values:

-WithStock: sufficient inventory
-ClosedWithStock: the inventory is close to the low-level line.
-WithoutStock: the inventory is out of stock.'),
      regionId?: string(name='RegionId', description='The ID of the region.'),
      availableResources?: {
        availableResource?: [ 
        {
          type?: string(name='Type', description='The type of the resource. Possible values:

-Zone: Zone
-IoOptimized:I/O optimization
-InstanceType: instance type
-SystemDisk: system disk type
-DataDisk: data disk type
-Network: Network type
'),
          supportedResources?: {
            supportedResource?: [ 
            {
              status?: string(name='Status', description='The status of the resource. Possible values:

-Available: sufficient resources
-SoldOut: resources are sold out
'),
              value?: string(name='Value', description='The value of the resource.'),
              max?: int32(name='Max', description='The maximum value of the resource type. This parameter is not returned if it is null.'),
              unit?: string(name='Unit', description='The unit of the resource type. This parameter is not returned if it is null.'),
              statusCategory?: string(name='StatusCategory', description='Resource categories are classified by inventory. Possible values:

-WithStock: sufficient inventory
-ClosedWithStock: the inventory is close to the low-level line.
-WithoutStock: the inventory is out of stock.'),
              min?: int32(name='Min', description='The minimum value of the resource type. This parameter is not returned if it is null.'),
            }
          ](name='SupportedResource')
          }(name='SupportedResources', description='An array of specific resources that can be created.'),
        }
      ](name='AvailableResource')
      }(name='AvailableResources', description='An array of specific resources that can be created.'),
    }
  ](name='AvailableZone')
  }(name='AvailableZones', description='A collection of data center information AvailableZone.'),
}

model DescribeResourcesModificationResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeResourcesModificationResponseBody(name='body'),
}

async function describeResourcesModification(request: DescribeResourcesModificationRequest): DescribeResourcesModificationResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeResourcesModification', 'POST', 'undefined', 'json', false, 'none', request);
}

model DeleteLaunchTemplateRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', description='The ID of the RAM user.', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='The account name of the resource master account.', position='Query'),
  regionId?: string(name='RegionId', description='The ID of the region to which the instance launch template belongs. You can call [DescribeRegions](~~ 25609 ~~) to view the latest region list.', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', description='The ID of the resource master account, that is, the UID.', position='Query'),
  launchTemplateId?: string(name='LaunchTemplateId', description='The ID of the launch template. For more information, call [DescribeLaunchTemplates](~~ 73759 ~~). You must specify "LaunchTemplateId" or "LaunchTemplateName" to determine the launch template.', position='Query'),
  launchTemplateName?: string(name='LaunchTemplateName', description='The name of the launch template. You must specify "LaunchTemplateId" or "LaunchTemplateName" to determine the launch template.', position='Query'),
}

model DeleteLaunchTemplateResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.'),
}

model DeleteLaunchTemplateResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteLaunchTemplateResponseBody(name='body'),
}

async function deleteLaunchTemplate(request: DeleteLaunchTemplateRequest): DeleteLaunchTemplateResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteLaunchTemplate', 'POST', 'undefined', 'json', false, 'none', request);
}

model DescribeNewProjectEipMonitorDataRequest {
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  allocationId?: string(name='AllocationId', position='Query'),
  startTime?: string(name='StartTime', position='Query'),
  endTime?: string(name='EndTime', position='Query'),
  period?: int32(name='Period', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
}

model DescribeNewProjectEipMonitorDataResponseBody = {
  requestId?: string(name='RequestId'),
  eipMonitorDatas?: {
    eipMonitorData?: [ 
    {
      eipTX?: int32(name='EipTX'),
      eipPackets?: int32(name='EipPackets'),
      eipBandwidth?: int32(name='EipBandwidth'),
      timeStamp?: string(name='TimeStamp'),
      eipFlow?: int32(name='EipFlow'),
      eipRX?: int32(name='EipRX'),
    }
  ](name='EipMonitorData')
  }(name='EipMonitorDatas'),
}

model DescribeNewProjectEipMonitorDataResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeNewProjectEipMonitorDataResponseBody(name='body'),
}

async function describeNewProjectEipMonitorData(request: DescribeNewProjectEipMonitorDataRequest): DescribeNewProjectEipMonitorDataResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeNewProjectEipMonitorData', 'POST', 'undefined', 'json', false, 'none', request);
}

model UnbindIpRangeRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  instanceId?: string(name='InstanceId', position='Query'),
  ipAddress?: string(name='IpAddress', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
}

model UnbindIpRangeResponseBody = {
  requestId?: string(name='RequestId'),
}

model UnbindIpRangeResponse = {
  headers: map[string]string(name='headers'),
  body: UnbindIpRangeResponseBody(name='body'),
}

async function unbindIpRange(request: UnbindIpRangeRequest): UnbindIpRangeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UnbindIpRange', 'POST', 'undefined', 'json', false, 'none', request);
}

model DescribeInstanceRamRoleRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  pageNumber?: int32(name='PageNumber', description='The page number of the returned resource information list.

Start value: 1

Default value: 1.', position='Query'),
  regionId?: string(name='RegionId', description='The region of the instance RAM role. You can call [DescribeRegions](~~ 25609 ~~) to view the latest region list.', position='Query'),
  ownerId?: long(name='OwnerId', description='The ID of the RAM user.', position='Query'),
  instanceIds?: string(name='InstanceIds', description='The ID of the instance to be queried. You can query up to 100 instances at a time. You must specify at least one of the "InstanceIds" and "RamRoleName" parameters.', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', description='The ID of the resource master account, that is, the UID.', position='Query'),
  ramRoleName?: string(name='RamRoleName', description='You can call this operation to query all ECS instances that are assigned a RAM role to an instance. You can use the RAM API [ListRoles](~~ 28713 ~~) to query the created instance RAM role. You must specify at least one of the "InstanceIds" and "RamRoleName" parameters.', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='The account name of the resource master account.', position='Query'),
  pageSize?: int32(name='PageSize', description='The number of entries to return on each page. Unit: rows.

Maximum Value: 50

Default value: 10', position='Query'),
}

model DescribeInstanceRamRoleResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.'),
  totalCount?: int32(name='TotalCount', description='The number of RAM roles returned.'),
  regionId?: string(name='RegionId', description='The region of the instance RAM role.'),
  instanceRamRoleSets?: {
    instanceRamRoleSet?: [ 
    {
      ramRoleName?: string(name='RamRoleName', description='The list of instance RAM role names.'),
      instanceId?: string(name='InstanceId', description='The ID of the instance.'),
    }
  ](name='InstanceRamRoleSet')
  }(name='InstanceRamRoleSets', description='A set of information consisting of instance RAM role types InstanceRamRoleSet.'),
}

model DescribeInstanceRamRoleResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeInstanceRamRoleResponseBody(name='body'),
}

/**
 * ## API description

When calling an API through Alibaba Cloud CLI, the request parameter values of different data types must comply with the format requirements. For more information, see [CLI parameter format description](~~ 110340 ~~).
 */
async function describeInstanceRamRole(request: DescribeInstanceRamRoleRequest): DescribeInstanceRamRoleResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeInstanceRamRole', 'POST', 'undefined', 'json', false, 'none', request);
}

model CreateImageRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  imageVersion?: string(name='ImageVersion', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  diskDeviceMapping?: [ 
    {
      snapshotId?: string(name='SnapshotId', description='根据指定的快照创建自定义镜像。'),
      size?: int32(name='Size', description='DiskDeviceMapping.N云盘的大小，单位为GiB。DiskDeviceMapping.N.Size的取值和默认值和DiskDeviceMapping.N.SnapshotId有关：

- 如果没有指定SnapshotId，Size取值以及默认值为：
    - 普通云盘：5~2000GiB，默认为5
    - 其他云盘：20~32768GiB，默认为20
- 如果指定了SnapshotId，Size取值必须大于等于SnapshotId的大小，默认为SnapshotId的大小。'),
      device?: string(name='Device', description='指定DiskDeviceMapping.N在自定义镜像中的设备名称。取值范围：

- 其他云盘（例如SSD云盘、高效云盘和ESSD云盘）：/dev/vda~/dev/vdz
- 普通云盘：/dev/xvda~/dev/xvdz'),
      diskType?: string(name='DiskType', description='指定DiskDeviceMapping.N.在新镜像中的云盘类型。您可以通过该参数使用数据盘快照做为镜像的系统盘，如果不指定，默认为快照对应的云盘类型。取值范围：

- system：系统盘
- data：数据盘'),
    }
  ](name='DiskDeviceMapping', position='Query'),
  tag?: [ 
    {
      key?: string(name='key', description='镜像的标签键。

>为提高兼容性，建议您尽量使用Tag.N.Key参数。'),
      value?: string(name='Value', description='镜像的标签值。N的取值范围：1~20。一旦传入该值，允许为空字符串。最多支持128个字符，不能以acs:开头，不能包含http://或者https://。'),
    }
  ](name='Tag', position='Query'),
  instanceId?: string(name='InstanceId', description='The ID of the instance.', position='Query'),
  regionId?: string(name='RegionId', description='The region ID of the image. You can call [DescribeRegions](~~ 25609 ~~) to view the latest region list.', position='Query'),
  snapshotId?: string(name='SnapshotId', description='Creates a custom image based on the specified snapshot.', position='Query'),
  clientToken?: string(name='ClientToken', description='Ensure the idempotence of the request. Generate a parameter value from your client. Make sure that the value is unique among different requests. **ClientToken** supports only ASCII characters and cannot exceed 64 characters. For more information, see [how to ensure idempotence](~~ 25693 ~~).', position='Query'),
  platform?: string(name='Platform', description='After you specify a data disk snapshot as the system disk of the image, you must use the Platform to determine the operating system release of the system disk. Valid values:

-CentOS
-Ubuntu
-SUSE
-OpenSUSE
-RedHat
-Debian
-CoreOS
-Aliyun
-Windows Server 2012
-Windows 7
-Customized Linux
-Others Linux (default)', position='Query'),
  imageFamily?: string(name='ImageFamily', description='The name of the Image family. The description must be 2 to 128 characters in length. It must start with a letter and cannot start with aliyun or acs:. It cannot contain http:// or https://. It can contain numbers, colons (:), underscores (_), and hyphens (-).

Default value: Null.', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', description='The ID of the resource master account, that is, the UID.', position='Query'),
  ownerId?: long(name='OwnerId', description='The ID of the RAM user.', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='The account name of the resource master account.', position='Query'),
  imageName?: string(name='ImageName', description='The name of the image. The description must be 2 to 128 characters in length. It must start with a letter and cannot start with http:// or https. It can contain numbers, colons (:), underscores (_), and hyphens (-).

Default value: Null.', position='Query'),
  architecture?: string(name='Architecture', description='After you specify a data disk snapshot as the system disk of the image, you must use the Architecture to determine the system Architecture of the system disk. Valid values:

-i386
-x86_64 (default)', position='Query'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group to which the custom image belongs.', position='Query'),
  description?: string(name='Description', description='The description of the image. The description must be 2 to 256 characters in length and cannot start with http:// or https.

Default value: Null.', position='Query'),
}

model CreateImageResponseBody = {
  imageId?: string(name='ImageId', description='The ID of the image.'),
  requestId?: string(name='RequestId', description='The ID of the request.'),
}

model CreateImageResponse = {
  headers: map[string]string(name='headers'),
  body: CreateImageResponseBody(name='body'),
}

/**
 * ## API description

When you call this operation, note that:

-Wait until the image status becomes Available (Available) before using the image resources.

-When querying ECS instance information, if the returned data contains "{"OperationLocks": {"LockReason" : "security"}}", all operations are prohibited.

The following describes three methods to create a custom image by using this API. The priority of request parameters is "InstanceId" > "DiskDeviceMapping"> "SnapshotId". If your request contains two or more parameters, the higher priority parameter is used by default to create an image.

-**Method 1**: use an instance as a template. You only need to specify the instance ID("InstanceId"). The instance must be in the running ("Running") or stopped ("Stopped") state. After the API is called, a snapshot is added to each disk of the instance. If the cached data of a running instance is not on the disk, the data of the created custom image may be inconsistent with that of the instance. Therefore, we recommend that you stop the instance ([StopInstances](~~ 155372 ~~)) and create an image.

-**Method 2**: to create a custom image for the system disk of an instance, you only need to specify a historical snapshot ID("SnapshotId") of the system disk of the instance. The specified snapshot cannot be created before July 15, 2013.

-**Method 3**: combine multiple snapshots into an image template, and establish a data Association ("DiskDeviceMapping") for several cloud disks.

When using method 3 to create a custom image, note the following:

-Only one system disk snapshot can be specified. The device name of the system disk must be/dev/xvda.

-You can specify multiple data disk snapshots. By default, the device names of data disks are assigned by the system in an orderly manner. The names are sorted from/dev/xvdb to/dev/xvdz in sequence and cannot be repeated.

-You do not need to specify "SnapshotId". If you do not specify this parameter, an empty data disk of the specified size without any data is created.

-The specified snapshot cannot be created before July 15, 2013.
 */
async function createImage(request: CreateImageRequest): CreateImageResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateImage', 'POST', 'undefined', 'json', false, 'none', request);
}

model DescribeHaVipsRequest {
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  pageNumber?: int32(name='PageNumber', position='Query'),
  pageSize?: int32(name='PageSize', position='Query'),
  filter?: [ 
    {
      key?: string(name='Key'),
      value?: [ string ](name='Value'),
    }
  ](name='Filter', position='Query'),
}

model DescribeHaVipsResponseBody = {
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  pageNumber?: int32(name='PageNumber'),
  totalCount?: int32(name='TotalCount'),
  haVips?: {
    haVip?: [ 
    {
      status?: string(name='Status'),
      vpcId?: string(name='VpcId'),
      vSwitchId?: string(name='VSwitchId'),
      ipAddress?: string(name='IpAddress'),
      description?: string(name='Description'),
      haVipId?: string(name='HaVipId'),
      createTime?: string(name='CreateTime'),
      masterInstanceId?: string(name='MasterInstanceId'),
      regionId?: string(name='RegionId'),
      associatedEipAddresses?: {
        associatedEipAddresse?: [ string ](name='associatedEipAddresse')
      }(name='AssociatedEipAddresses'),
      associatedInstances?: {
        associatedInstance?: [ string ](name='associatedInstance')
      }(name='AssociatedInstances'),
    }
  ](name='HaVip')
  }(name='HaVips'),
}

model DescribeHaVipsResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeHaVipsResponseBody(name='body'),
}

async function describeHaVips(request: DescribeHaVipsRequest): DescribeHaVipsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeHaVips', 'POST', 'undefined', 'json', false, 'none', request);
}

model DescribeInstanceAttributeRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  instanceId?: string(name='InstanceId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
}

model DescribeInstanceAttributeResponseBody = {
  status?: string(name='Status'),
  serialNumber?: string(name='SerialNumber'),
  creationTime?: string(name='CreationTime'),
  requestId?: string(name='RequestId'),
  description?: string(name='Description'),
  instanceName?: string(name='InstanceName'),
  instanceNetworkType?: string(name='InstanceNetworkType'),
  memory?: int32(name='Memory'),
  imageId?: string(name='ImageId'),
  clusterId?: string(name='ClusterId'),
  vlanId?: string(name='VlanId'),
  stoppedMode?: string(name='StoppedMode'),
  hostName?: string(name='HostName'),
  instanceId?: string(name='InstanceId'),
  instanceType?: string(name='InstanceType'),
  internetMaxBandwidthIn?: int32(name='InternetMaxBandwidthIn'),
  internetMaxBandwidthOut?: int32(name='InternetMaxBandwidthOut'),
  regionId?: string(name='RegionId'),
  instanceChargeType?: string(name='InstanceChargeType'),
  ioOptimized?: string(name='IoOptimized'),
  cpu?: int32(name='Cpu'),
  expiredTime?: string(name='ExpiredTime'),
  zoneId?: string(name='ZoneId'),
  internetChargeType?: string(name='InternetChargeType'),
  creditSpecification?: string(name='CreditSpecification'),
  securityGroupIds?: {
    securityGroupId?: [ string ](name='SecurityGroupId')
  }(name='SecurityGroupIds'),
  publicIpAddress?: {
    ipAddress?: [ string ](name='IpAddress')
  }(name='PublicIpAddress'),
  innerIpAddress?: {
    ipAddress?: [ string ](name='IpAddress')
  }(name='InnerIpAddress'),
  vpcAttributes?: {
    vpcId?: string(name='VpcId'),
    natIpAddress?: string(name='NatIpAddress'),
    vSwitchId?: string(name='VSwitchId'),
    privateIpAddress?: {
      ipAddress?: [ string ](name='IpAddress')
    }(name='PrivateIpAddress'),
  }(name='VpcAttributes'),
  eipAddress?: {
    internetChargeType?: string(name='InternetChargeType'),
    ipAddress?: string(name='IpAddress'),
    bandwidth?: int32(name='Bandwidth'),
    allocationId?: string(name='AllocationId'),
  }(name='EipAddress'),
  dedicatedHostAttribute?: {
    dedicatedHostName?: string(name='DedicatedHostName'),
    dedicatedHostId?: string(name='DedicatedHostId'),
  }(name='DedicatedHostAttribute'),
  operationLocks?: {
    lockReason?: [ 
    {
      lockReason?: string(name='LockReason'),
    }
  ](name='LockReason')
  }(name='OperationLocks'),
}

model DescribeInstanceAttributeResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeInstanceAttributeResponseBody(name='body'),
}

async function describeInstanceAttribute(request: DescribeInstanceAttributeRequest): DescribeInstanceAttributeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeInstanceAttribute', 'POST', 'undefined', 'json', false, 'none', request);
}

model DetachDiskRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', description='The ID of the resource master account, that is, the UID.', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', description='The ID of the RAM user.', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='The account name of the resource master account.', position='Query'),
  instanceId?: string(name='InstanceId', description='The ID of the ECS instance to be detached.', position='Query'),
  diskId?: string(name='DiskId', description='The ID of the disk to be detached.', position='Query'),
  deleteWithInstance?: boolean(name='DeleteWithInstance', description='When you detach a system disk, the system disk is automatically released. Indicates whether the system disk is released at the same time when the ECS instance is released.

-true: release.
-false: not released. A cloud disk is converted to a pay-as-you-go data disk and is retained.

Default value: true

Note:

-This parameter is not supported for disks with multiple mount features enabled.
-If the data disk is unmounted, the default value is "false ".', position='Query'),
}

model DetachDiskResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.'),
}

model DetachDiskResponse = {
  headers: map[string]string(name='headers'),
  body: DetachDiskResponseBody(name='body'),
}

/**
 * ## API description

Note the following when you call this operation:

-The cloud disk must be attached to the instance and the status is in use ("in_use").

-When you detach a data disk, the attached instance must be in the **running**("Running") or **stopped**("Stopped") status.

-When you detach a system disk, the attached instance must be in the **stopped**("Stopped") state.

-After the attached instance is under security control, "OperationLocks" cannot be marked as "LockReason": "security.

-DetachDisk is an asynchronous operation. It takes about one minute to uninstall the operation.
 */
async function detachDisk(request: DetachDiskRequest): DetachDiskResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DetachDisk', 'POST', 'undefined', 'json', false, 'none', request);
}

model StopDiskReplicaPairRequest {
  ownerId?: long(name='OwnerId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  replicaPairId?: string(name='ReplicaPairId', position='Query'),
}

model StopDiskReplicaPairResponseBody = {
  requestId?: string(name='RequestId'),
}

model StopDiskReplicaPairResponse = {
  headers: map[string]string(name='headers'),
  body: StopDiskReplicaPairResponseBody(name='body'),
}

async function stopDiskReplicaPair(request: StopDiskReplicaPairRequest): StopDiskReplicaPairResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'StopDiskReplicaPair', 'POST', 'undefined', 'json', false, 'none', request);
}

model RedeployDedicatedHostRequest {
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  dedicatedHostId?: string(name='DedicatedHostId', description='The ID of the dedicated host.', position='Query'),
  regionId?: string(name='RegionId', description='The ID of the region to which the dedicated host belongs. You can call [DescribeRegions](~~ 25609 ~~) to view the latest region list.', position='Query'),
}

model RedeployDedicatedHostResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.'),
}

model RedeployDedicatedHostResponse = {
  headers: map[string]string(name='headers'),
  body: RedeployDedicatedHostResponseBody(name='body'),
}

/**
 * ## API description
When the status of a DDH is UnderAssessment, that is, the latency of a fault, we recommend that you call this operation to perform a fault migration for the DDH to avoid permanent faults. You can call the API [DescribeDedicatedHosts](~~ 134242 ~~) to query the status information of the DDH.
 */
async function redeployDedicatedHost(request: RedeployDedicatedHostRequest): RedeployDedicatedHostResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'RedeployDedicatedHost', 'POST', 'undefined', 'json', false, 'none', request);
}

model ModifyDemandRequest {
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  clientToken?: string(name='ClientToken', position='Query'),
  regionId?: string(name='RegionId', description='The ID of the region to which the reported instance belongs. You can call [DescribeRegions](~~ 25609 ~~) to view the latest region list.', position='Query'),
  instanceType?: string(name='InstanceType', description='The resource type of the reported instance. See [instance type family](~~ 25378 ~~) or call [DescribeInstanceTypes](~~ 25620 ~~) to view the performance parameters of the reported instance type, or see [selection configuration](~~ 58291 ~~) learn how to select an instance type.', position='Query'),
  periodUnit?: string(name='PeriodUnit', description='The duration of the resource purchase. Valid values:
-Day
-Week
-Month (default)', position='Query'),
  amount?: int32(name='Amount', description='The number of required specifications. Valid values: 1 to 100000.', position='Query'),
  period?: int32(name='Period', description='The duration of the resource to be purchased. This parameter is required. Unit: month. This parameter takes effect only when the instancechargetype" parameter is set to PrePaid. Valid values:

When the value of-PeriodUnit is Week, the value of Period is {"1", "2", "3", "4"}.

When the value of-PeriodUnit is Month, the value of Period is {"1", "2", "3", "4", "5", "6", "7", "8", "9", "12", "24", "36", "48", "60"}.', position='Query'),
  demandId?: string(name='DemandId', description='The ID of the report to be modified.', position='Query'),
  instanceChargeType?: string(name='InstanceChargeType', description='The billing method of the reported instance. Valid values:

-PrePaid: Subscription
-PostPaid (default): Pay-as-you-go', position='Query'),
  demandDescription?: string(name='DemandDescription', description='The description of the report. The description must be 2 to 256 characters in length and cannot start with http:// or https.', position='Query'),
  startTime?: string(name='StartTime', description='The earliest purchase time. The time follows the [ISO8601](~~ 25696 ~~) standard and uses UTC +0. The format is yyyy-MM-dd HH:mm:ss.

If the value of seconds (ss) is not 00, it is automatically set to the beginning of the current minute (mm).

The latest purchase time is later than the earliest purchase time.

The time span between morning and evening is generally not allowed to exceed 10 days.', position='Query'),
  demandName?: string(name='DemandName', description='The name of the report. The description must be 2 to 128 characters in length. It must start with a letter and cannot start with http:// or https. It can contain letters, digits, colons (:), underscores (_), periods (.), and hyphens (-).

Default value: the name of the instance type.', position='Query'),
  endTime?: string(name='EndTime', description='The latest purchase time. The time follows the [ISO8601](~~ 25696 ~~) standard and uses UTC +0. The format is yyyy-MM-dd HH:mm:ss.

If the value of seconds (ss) is not 00, it is automatically set to the beginning of the current minute (mm).

The latest purchase time is later than the earliest purchase time.

The length of time in the morning and evening cannot exceed 10 days.
', position='Query'),
  zoneId?: string(name='ZoneId', description='The ID of the zone to which the reported instance belongs. For more information, see [DescribeZones](~~ 25610 ~~) for a list of zones.

Default value: Null.', position='Query'),
}

model ModifyDemandResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.'),
}

model ModifyDemandResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyDemandResponseBody(name='body'),
}

/**
 * ## API description

You can call this operation to modify instance type requirements. Alibaba Cloud provides relevant resources based on your requirements.
Only I/O optimized instance types and VPC-connected ECS instances can be reported.
You can only modify parameters other than "DemandName" and "DemandDescription" in the rejected state.

> This API is in the beta test and has not been officially launched. We recommend that you do not use this API. Please wait.
 */
async function modifyDemand(request: ModifyDemandRequest): ModifyDemandResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyDemand', 'POST', 'undefined', 'json', false, 'none', request);
}

model DeleteFleetRequest {
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  fleetId?: string(name='FleetId', position='Query'),
  terminateInstances?: boolean(name='TerminateInstances', position='Query'),
}

model DeleteFleetResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteFleetResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteFleetResponseBody(name='body'),
}

async function deleteFleet(request: DeleteFleetRequest): DeleteFleetResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteFleet', 'POST', 'undefined', 'json', false, 'none', request);
}

model ModifyIntranetBandwidthKbRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  instanceId?: string(name='InstanceId', position='Query'),
  intranetMaxBandwidthIn?: int32(name='IntranetMaxBandwidthIn', position='Query'),
  intranetMaxBandwidthOut?: int32(name='IntranetMaxBandwidthOut', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
}

model ModifyIntranetBandwidthKbResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyIntranetBandwidthKbResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyIntranetBandwidthKbResponseBody(name='body'),
}

async function modifyIntranetBandwidthKb(request: ModifyIntranetBandwidthKbRequest): ModifyIntranetBandwidthKbResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyIntranetBandwidthKb', 'POST', 'undefined', 'json', false, 'none', request);
}

model DescribeFleetHistoryRequest {
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  fleetId?: string(name='FleetId', position='Query'),
}

model DescribeFleetHistoryResponseBody = {
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  pageNumber?: int32(name='PageNumber'),
  totalCount?: int32(name='TotalCount'),
  fleetHistorys?: {
    fleetHistory?: [ 
    {
      status?: string(name='Status'),
      startTime?: string(name='StartTime'),
      taskId?: string(name='TaskId'),
      lastEventTime?: string(name='LastEventTime'),
      activityDetails?: {
        activityDetail?: [ 
        {
          status?: float(name='Status'),
          detail?: string(name='Detail'),
        }
      ](name='ActivityDetail')
      }(name='ActivityDetails'),
    }
  ](name='FleetHistory')
  }(name='FleetHistorys'),
}

model DescribeFleetHistoryResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeFleetHistoryResponseBody(name='body'),
}

async function describeFleetHistory(request: DescribeFleetHistoryRequest): DescribeFleetHistoryResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeFleetHistory', 'POST', 'undefined', 'json', false, 'none', request);
}

model DescribeRecommendInstanceTypeRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  memory?: float(name='Memory', description='The memory size of the ECS instance. Unit: GiB.

> If both the "Cores" and "memore" parameters are specified, all instance types that meet the vCPU cores and memory size are matched.', position='Query'),
  ownerId?: long(name='OwnerId', description='The ID of the RAM user.', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='The account name of the resource master account.', position='Query'),
  scene?: string(name='Scene', description='The recommended instance type. Valid values:

-UPGRADE: UPGRADE or downgrade the instance type.
-CREATE: creates an instance.

Default value: CREATE', position='Query'),
  regionId?: string(name='RegionId', description='The ID of the region. You can call [DescribeRegions](~~ 25609 ~~) to view the latest region list.', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', description='The ID of the resource master account, that is, the UID.', position='Query'),
  cores?: int32(name='Cores', description='The number of vCPU cores of the ECS instance.

> If both the "Cores" and "memore" parameters are specified, all instance types that meet the vCPU cores and memory size are matched.', position='Query'),
  networkType?: string(name='NetworkType', description='The network type of the ECS instance. Valid values:

-classic: classic Network
-vpc: VPC

Default value: vpc', position='Query'),
  instanceType?: string(name='InstanceType', description='The type of the instance. For more information, see [instance type family](~~ 25378 ~~), or call [DescribeInstanceTypes](~~ 25620 ~~) to obtain the latest specification.

> If you specify "InstanceType", you cannot specify "Cores" or "memore ".', position='Query'),
  instanceFamilyLevel?: string(name='InstanceFamilyLevel', description='The instance type family. Valid values:

-EntryLevel: entry-level.
-EnterpriseLevel: enterprise-level.
-CreditEntryLevel: the entry level of points. For more information, see [burstable instances](~~ 59977 ~~).', position='Query'),
  ioOptimized?: string(name='IoOptimized', description='Indicates whether the instance is I/O optimized. The instance type only supports non-I/O optimization and cannot be IoOptimized. Valid values:

-optimized:I/O optimized
-none: Non-IO optimization

Default value: optimized

If you set the phased-out instance type. Default value: none', position='Query'),
  instanceTypeFamily?: [ string ](name='InstanceTypeFamily', description='You can call this operation to filter instances that are not accepted. Valid values of N: 1 to 10. For more information, see [instance type family](~~ 25378 ~~). You can also call [DescribeInstanceTypeFamilys](~~ 25620 ~~) to query the list of instance families.', position='Query'),
  zoneId?: string(name='ZoneId', description='The ID of the zone. You can call [DescribeZones](~~ 25610 ~~) to view the latest list of Alibaba Cloud zones.

Proposal also ZoneMatchMode value for Include (default), priority recommended ZoneId specified available area the instance in the dimension and lists with geographical lower other available area the instance in the specifications.', position='Query'),
  spotStrategy?: string(name='SpotStrategy', description='The bidding policy for preemptible instances. Valid values:

-NoSpot: a pay-as-you-go instance.
-SpotWithPriceLimit: sets the maximum price for preemptible instances.
-SpotAsPriceGo: The system automatically bids at the highest pay-as-you-go price.

> When "SpotStrategy" is used, "InstanceChargerType" must be set to "PostPaid ".

Default value: NoSpot', position='Query'),
  instanceChargeType?: string(name='InstanceChargeType', description='The billing method of the ECS instance. For more information, see [billing Overview](~~ 25398 ~~). Valid values:

-PrePaid: Subscription
-PostPaid: pay-as-you-go

Default value: PostPaid', position='Query'),
  priorityStrategy?: string(name='PriorityStrategy', description='The recommended policy is preferred. Valid values:

-InventoryFirst: Inventory takes precedence.
-PriceFirst: The price takes precedence, which is sorted by the unit price of vCPU per hour from low to high.
-NewProductFirst: the latest product is preferred.

Default value: InventoryFirst', position='Query'),
  maxPrice?: float(name='MaxPrice', description='The maximum hourly price for a pay-as-you-go or preemptible instance.

> When you set the maximum unit price for a preemptible instance, you must set "spotstratege" to "spotwithpricelime ".', position='Query'),
  zoneMatchMode?: string(name='ZoneMatchMode', description='Indicates whether to recommend only the instance types in the zone specified by ZoneId. Valid values:

-Strict: only the instance types in the zone specified by ZoneId are recommended.

-Include: We recommend that you use instance types in other zones in the same region.


When "ZoneId" is specified, the default value of this parameter is Strict, which indicates that only the instance types in the zone specified by ZoneId are recommended.', position='Query'),
  systemDiskCategory?: string(name='SystemDiskCategory', description='The type of the system disk. Valid values:

-cloud_efficiency: Ultra disk
-cloud_ssd:SSD cloud disk
-cloud_essd:ESSD
-cloud: basic cloud disk

Default value for non-I/O optimized instances: cloud

Default value for I/O optimized instances: cloud_efficiency', position='Query'),
}

model DescribeRecommendInstanceTypeResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.'),
  data?: {
    recommendInstanceType?: [ 
    {
      commodityCode?: string(name='CommodityCode', description='The product code of the instance type.'),
      zoneId?: string(name='ZoneId', description='The ID of the zone to which the instance type belongs.'),
      priority?: int32(name='Priority', description='The priority of the order.'),
      networkType?: string(name='NetworkType', description='The network type of the ECS instance.'),
      scene?: string(name='Scene', description='The recommended instance type.'),
      spotStrategy?: string(name='SpotStrategy', description='The preemptible policy of the preemptible instance.'),
      regionId?: string(name='RegionId', description='The ID of the region to which the instance type belongs.'),
      instanceChargeType?: string(name='InstanceChargeType', description='The billing method of the instance.'),
      zones?: {
        zone?: [ 
        {
          zoneNo?: string(name='ZoneNo', description='The ID of the zone to which the instance type belongs.'),
          networkTypes?: {
            networkType?: [ string ](name='NetworkType')
          }(name='NetworkTypes'),
        }
      ](name='zone')
      }(name='Zones', description='The list of zones where the instance type is located.'),
      instanceType?: {
        supportIoOptimized?: string(name='SupportIoOptimized', description='Indicates whether the instance type supports I/O optimization.'),
        cores?: int32(name='Cores', description='The number of vCPU cores of the instance type.'),
        memory?: int32(name='Memory', description='The memory size of the instance type. Unit: MB.'),
        instanceType?: string(name='InstanceType', description='The name of the instance type.'),
        instanceTypeFamily?: string(name='InstanceTypeFamily', description='The instance type family.'),
        generation?: string(name='Generation', description='The instance type family.'),
      }(name='InstanceType', description='The name of the instance type.'),
    }
  ](name='RecommendInstanceType')
  }(name='Data', description='The recommended instance types.'),
}

model DescribeRecommendInstanceTypeResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeRecommendInstanceTypeResponseBody(name='body'),
}

async function describeRecommendInstanceType(request: DescribeRecommendInstanceTypeRequest): DescribeRecommendInstanceTypeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeRecommendInstanceType', 'POST', 'undefined', 'json', false, 'none', request);
}

model DescribeTagKeysRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  pageSize?: int32(name='PageSize', position='Query'),
  pageNumber?: int32(name='PageNumber', position='Query'),
  resourceType?: string(name='ResourceType', position='Query'),
  resourceId?: string(name='ResourceId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  category?: string(name='Category', position='Query'),
}

model DescribeTagKeysResponseBody = {
  requestId?: string(name='RequestId'),
  pageSize?: int32(name='PageSize'),
  pageNumber?: int32(name='PageNumber'),
  totalCount?: int32(name='TotalCount'),
  tagKeys?: {
    tagKey?: [ string ](name='TagKey')
  }(name='TagKeys'),
}

model DescribeTagKeysResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeTagKeysResponseBody(name='body'),
}

async function describeTagKeys(request: DescribeTagKeysRequest): DescribeTagKeysResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeTagKeys', 'POST', 'undefined', 'json', false, 'none', request);
}

model CreateVolumeRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  zoneId?: string(name='ZoneId', position='Query'),
  snapshotId?: string(name='SnapshotId', position='Query'),
  volumeName?: string(name='VolumeName', position='Query'),
  size?: int32(name='Size', position='Query'),
  volumeCategory?: string(name='VolumeCategory', position='Query'),
  description?: string(name='Description', position='Query'),
  volumeEncrypted?: boolean(name='VolumeEncrypted', position='Query'),
  clientToken?: string(name='ClientToken', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  KMSKeyId?: string(name='KMSKeyId', position='Query'),
  storageSetId?: string(name='StorageSetId', position='Query'),
  storageSetPartitionNumber?: int32(name='StorageSetPartitionNumber', position='Query'),
  tag?: [ 
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='Tag', position='Query'),
}

model CreateVolumeResponseBody = {
  volumeId?: string(name='VolumeId'),
  requestId?: string(name='RequestId'),
}

model CreateVolumeResponse = {
  headers: map[string]string(name='headers'),
  body: CreateVolumeResponseBody(name='body'),
}

async function createVolume(request: CreateVolumeRequest): CreateVolumeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateVolume', 'POST', 'undefined', 'json', false, 'none', request);
}

model DeleteInstanceRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', description='The ID of the resource master account, that is, the UID.', position='Query'),
  terminateSubscription?: boolean(name='TerminateSubscription', description='Specifies whether to release expired subscription instances.

Default value: false', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='The account name of the resource master account.', position='Query'),
  ownerId?: long(name='OwnerId', description='The ID of the RAM user.', position='Query'),
  instanceId?: string(name='InstanceId', description='The ID of the instance.', position='Query'),
  force?: boolean(name='Force', description='Indicates whether to force the release of **running**("Running" instance).

-true: forcibly releases **running**("Running") instances. Forced release is equivalent to power failure, and temporary data in the instance memory and storage will be erased and cannot be recovered.
-false (default): the instance is released. The instance must be in the **stopped**("Stopped") state.', position='Query'),
}

model DeleteInstanceResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.'),
}

model DeleteInstanceResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteInstanceResponseBody(name='body'),
}

/**
 * ## API description

-After the instance is released, all physical resources used by the instance are recycled, and all relevant data is lost and cannot be recovered.

-Disks attached to the instance:

-If "DeleteWithInstance = false" is set, the disks are converted to pay-as-you-go disks and retained.

-If "DeleteWithInstance = true" is set, the disk is released at the same time.

-If "DeleteAutoSnapshot = false", the automatic snapshot is retained.

-If "DeleteAutoSnapshot = true", the automatic snapshot is released.

-Keep the manual snapshot of the disk.

-The instance is under [security control](~~ 25695 ~~) and "OperationLocks" is marked with "LockReason ": "Security", even if the "DeleteWithInstance" attribute of the cloud disk is "false ", the system ignores this attribute and releases the disk.
 */
async function deleteInstance(request: DeleteInstanceRequest): DeleteInstanceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteInstance', 'POST', 'undefined', 'json', false, 'none', request);
}

model DeleteActivationRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  regionId?: string(name='RegionId', description='The ID of the region. Only China (Hangzhou), China (Beijing), and China (Shanghai) are supported.', position='Query'),
  activationId?: string(name='ActivationId', description='The ID of the unused activation code.', position='Query'),
}

model DeleteActivationResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.'),
  activation?: {
    creationTime?: string(name='CreationTime', description='The creation time.'),
    deregisteredCount?: int32(name='DeregisteredCount', description='The number of canceled instances.'),
    instanceCount?: int32(name='InstanceCount', description='The maximum number of times an activation code is used to register a managed instance.'),
    description?: string(name='Description', description='The description of the activation code.'),
    registeredCount?: int32(name='RegisteredCount', description='The number of registered instances.'),
    instanceName?: string(name='InstanceName', description='The default instance name prefix.'),
    ipAddressRange?: string(name='IpAddressRange', description='The IP address of the host that allows the activation code.'),
    timeToLiveInHours?: long(name='TimeToLiveInHours', description='The validity period of the activation code. Unit: Hour'),
    activationId?: string(name='ActivationId', description='Activation Code ID.'),
  }(name='Activation', description='A collection of activation codes and usage information.'),
}

model DeleteActivationResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteActivationResponseBody(name='body'),
}

/**
 * ## API description

The activation code must not be used, that is, the number of registered managed instances corresponding to the activation code is 0.
 */
async function deleteActivation(request: DeleteActivationRequest): DeleteActivationResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteActivation', 'POST', 'undefined', 'json', false, 'none', request);
}

model CreateInstanceRequest {
  hibernationOptions?: {
    configured?: boolean(name='Configured', position=''),
  }(name='HibernationOptions'),
  privatePoolOptions?: {
    id?: string(name='Id', description='The ID of the private pool. The ID of the elastic protection service or the capacity reservation service.', position=''),
    matchCriteria?: string(name='MatchCriteria', description='The capacity of the private pool that the instance starts. After the elastic protection service or the capacity reservation service takes effect, the private pool capacity is generated for you to select when the instance is started. Valid values:

-Open: Open mode. The capacity of the open private pool is automatically matched. If the capacity of the private pool does not meet the conditions, use the public pool resources to start. In this mode, you do not need to set the "PrivatePoolOptions.Id" parameter.
-Target: specifies the mode. Start an instance with the specified private pool capacity. If the private pool capacity is unavailable, the instance fails to start. The private pool ID must be specified in this mode, that is, the "PrivatePoolOptions.Id" parameter is required.
-None: the mode is not used. No private pool capacity is used when the instance is started.

Default value: None

In any of the following scenarios, the private pool capacity option can only be set to "None" or no value.
-Create a preemptible instance.
-Create an ECS instance of the classic network type.
-Create an ECS instance on a DDH.', position=''),
  }(name='PrivatePoolOptions'),
  systemDisk?: {
    size?: int32(name='Size', description='The size of the system disk. Unit: GiB. Valid values: 20 to 500.

The value of this parameter must be greater than or equal to max{20, ImageSize}.

Default value: max{40, ImageSize}', position=''),
    category?: string(name='Category', description='The type of the system disk. Valid values:

-cloud_essd:ESSD. You can set the performance level of the ESSD by calling the "SystemDisk.PerformanceLevel" parameter.
-cloud_efficiency: Ultra disk.
-cloud_ssd:SSD cloud disk.
-cloud: basic cloud disk.

For phased-out instance types and non-I/O optimized instances, the default value is cloud. Otherwise, the default value is cloud_efficiency.', position=''),
    description?: string(name='Description', description='System disk description. The description must be 2 to 256 characters in length and cannot start with http:// or https.

Default value: Null.', position=''),
    performanceLevel?: string(name='PerformanceLevel', description='When you create an ESSD as a system disk, set the performance level of the disk. Valid values:

-PL0: The maximum random read/write IOPS per disk is 10,000.
-PL1 (default): The maximum random read/write IOPS per disk is 50,000.
-PL2: The maximum random read/write IOPS per disk is 100,000.
-PL3: The maximum random read/write IOPS per disk is 1 million.

For more information about how to select an ESSD performance level, see [ESSD cloud disk](~~ 122389 ~~).', position=''),
    diskName?: string(name='DiskName', description='System disk name. The description must be 2 to 128 characters in length. It must start with a letter and cannot start with http:// or https. It can contain numbers, colons (:), underscores (_), and hyphens (-).

Default value: Null.', position=''),
  }(name='SystemDisk'),
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  deploymentSetGroupNo?: int32(name='DeploymentSetGroupNo', position='Query'),
  nodeControllerId?: string(name='NodeControllerId', position='Query'),
  httpPutResponseHopLimit?: int32(name='HttpPutResponseHopLimit', position='Query'),
  dataDisk?: [ 
    {
      performanceLevel?: string(name='PerformanceLevel', description='创建ESSD云盘作为数据盘使用时，设置云盘的性能等级。N的取值必须和`DataDisk.N.Category=cloud_essd`中的N保持一致。取值范围：

- PL0：单盘最高随机读写IOPS 1万。
- PL1（默认）：单盘最高随机读写IOPS 5万。
- PL2：单盘最高随机读写IOPS 10万。
- PL3：单盘最高随机读写IOPS 100万。

有关如何选择ESSD性能等级，请参见[ESSD云盘](~~122389~~)。'),
      description?: string(name='Description', description='数据盘描述。长度为2~256个英文或中文字符，不能以http://和https://开头。

默认值：空'),
      snapshotId?: string(name='SnapshotId', description='创建数据盘n使用的快照。N的取值范围为1~16。

- 指定参数`DataDisk.N.SnapshotId`后，参数`DataDisk.N.Size`会被忽略，实际创建的云盘大小为指定的快照的大小。

- 不能使用早于2013年7月15日（含）创建的快照，请求会报错被拒绝。'),
      size?: int32(name='Size', description='第n个数据盘的容量大小，n的取值范围为1~16，内存单位为GiB。取值范围：

-   cloud_efficiency：20~32768
-   cloud_ssd：20~32768
-   cloud_essd：20~32768
-   cloud：5~2000

该参数的取值必须大于等于参数`SnapshotId`指定的快照的大小。'),
      device?: string(name='Device', description='挂载点。

> 该参数即将停止使用，为提高代码兼容性，建议您尽量不要使用该参数。'),
      diskName?: string(name='DiskName', description='数据盘名称。长度为2~128个英文或中文字符。必须以大小字母或中文开头，不能以http://和https://开头。可以包含数字、半角冒号（:）、下划线（_）或者连字符（-）。

默认值：空'),
      category?: string(name='Category', description='数据盘N的云盘种类。取值范围：

-   cloud_efficiency：高效云盘
-   cloud_ssd：SSD云盘
-   cloud_essd：ESSD云盘
-   cloud：普通云盘

I/O优化实例的默认值为cloud_efficiency，非I/O优化实例的默认值为cloud。'),
      deleteWithInstance?: boolean(name='DeleteWithInstance', description='数据盘是否随实例释放。

默认值：true'),
      KMSKeyId?: string(name='KMSKeyId', description='云盘使用的KMS密钥ID。'),
      encryptAlgorithm?: string(name='EncryptAlgorithm'),
      encrypted?: boolean(name='Encrypted', description='数据盘N是否加密。

默认值：false'),
      storageClusterId?: string(name='StorageClusterId', description='专属块存储集群ID。如果您在创建ECS实例时，需要使用专属块存储集群中的云盘资源作为数据盘，请设置该参数。'),
    }
  ](name='DataDisk', position='Query'),
  arn?: [ 
    {
      roleType?: string(name='RoleType'),
      rolearn?: string(name='Rolearn'),
      assumeRoleFor?: long(name='AssumeRoleFor'),
    }
  ](name='Arn', position='Query'),
  tag?: [ 
    {
      key?: string(name='key', description='标签键。

> 为提高兼容性，建议您尽量使用Tag.N.Key参数。'),
      value?: string(name='Value', description='实例、云盘和主网卡的标签值。N的取值范围：1~20。一旦传入该值，可以为空字符串。最多支持128个字符，不能以acs:开头，不能包含http://或者https://。'),
    }
  ](name='Tag', position='Query'),
  internetMaxBandwidthOut?: int32(name='InternetMaxBandwidthOut', description='The maximum outbound public bandwidth. Unit: Mbit/s. Valid values: 0 to 100.

Default value: 0.', position='Query'),
  storageSetPartitionNumber?: int32(name='StorageSetPartitionNumber', description='The maximum number of partitions in a bucket. Valid values: 2 or more.', position='Query'),
  userData?: string(name='UserData', description='The user data of the instance must be encoded in Base64. the maximum size of the raw data is 16kB.', position='Query'),
  hpcClusterId?: string(name='HpcClusterId', description='The ID of the HPC cluster to which the instance belongs.', position='Query'),
  vSwitchId?: string(name='VSwitchId', description='If you want to create a VPC instance, you must specify the vSwitch ID. You can call [DescribeVSwitches](~~ 35748 ~~) to query the information about the created vSwitch.

> If you specify the "VSwitchId" parameter, the specified "ZoneId" parameter must be consistent with the zone where the vSwitch is located. If you do not specify the "ZoneId" parameter, the system automatically selects the zone where the specified vSwitch is located.', position='Query'),
  ioOptimized?: string(name='IoOptimized', description='Indicates whether the instance is I/O optimized. Valid values:

-none: Non-I/O optimized
-optimized:I/O optimized

The default value of the [phased-out instance type](~~ 55263 ~~) instance is none.

The default value of other instance types is optimized.', position='Query'),
  passwordInherit?: boolean(name='PasswordInherit', description='Specifies whether to use the default password of the image. When you use this parameter, the Password parameter must be empty, and you must ensure that the Password has been set for the image you are using.', position='Query'),
  clusterId?: string(name='ClusterId', description='The ID of the cluster to which the instance belongs.

> This parameter will be deprecated soon. To improve compatibility, try to use other parameters.', position='Query'),
  securityEnhancementStrategy?: string(name='SecurityEnhancementStrategy', description='Specifies whether to enable security hardening. Valid values:

-Active: enables security hardening, which takes effect only for system images.
-Deactive: does not enable security hardening and takes effect for all image types.', position='Query'),
  internetMaxBandwidthIn?: int32(name='InternetMaxBandwidthIn', description='The maximum inbound public bandwidth. Unit: Mbit/s. Valid values:

-1 to 10 when the purchased network bandwidth is less than or equal to 10 Mbit/s. Default value: 10
-When the purchased network bandwidth is greater than 10 Mbit/s: 1 to "InternetMaxBandwidthOut". The default value is "InternetMaxBandwidthOut.', position='Query'),
  password?: string(name='Password', description='The password of the instance. The description must be 8 to 30 characters in length and must contain letters, digits, and special characters. Special symbols can be:

"""
()"~! @%& *-_+ =} [],.?/
"""

Note:

-If you specify Password parameters, we recommend that you send requests over HTTPS to avoid Password leakage.
-Windows instance cannot start with a forward slash (/).
-Some operating system instances do not support password configuration, only key pairs can be configured. For example, Others Linux and Fedora CoreOS.', position='Query'),
  spotDuration?: int32(name='SpotDuration', description='The retention period of a preemptible instance. Unit: hours. Valid values: 0 to 6.

-The retention period is 2 to 6 and is being invited for testing. If you want to activate the service, submit a ticket.
-If the value is 0, the mode is not protected.

Default value: 1.', position='Query'),
  tenancy?: string(name='Tenancy', description='Specifies whether to create an instance on a dedicated host. Valid values:

-default: creates an instance on a non-dedicated host.

-host: creates an instance on a dedicated host. If you do not specify "DedicatedHostId", Alibaba Cloud automatically selects a dedicated host to deploy the instance.

default value: default', position='Query'),
  httpTokens?: string(name='HttpTokens', description='Specifies whether to use the enhanced mode (IMDSv2) when accessing instance metadata. Valid values:
-optional: not mandatory.
-required: force use. If this parameter is set, the instance metadata cannot be accessed in normal mode.

Default value: optional.
> For more information about how to access instance metadata, see [instance metadata access mode](~~ 150575 ~~).', position='Query'),
  regionId?: string(name='RegionId', description='The ID of the region to which the instance belongs. You can call [DescribeRegions](~~ 25609 ~~) to view the latest region list.', position='Query'),
  deploymentSetId?: string(name='DeploymentSetId', description='The ID of the deployment set.', position='Query'),
  instanceType?: string(name='InstanceType', description='The type of the instance.

-Product selection: see [instance type family](~~ 25378 ~~) or call [DescribeInstanceTypes](~~ 25620 ~~) to view the performance data of the target instance type, for more information about how to select an instance type, see [select configuration](~~ 58291 ~~).
-Query inventory: call [DescribeAvailableResource](~~ 66186 ~~) to view the resource supply in a specified region or zone.', position='Query'),
  deletionProtection?: boolean(name='DeletionProtection', description='The release protection property of the instance, which specifies whether to release the instance through the console or API([DeleteInstance](~~ 25507 ~~)).

-true: enable instance release protection.
-false: disables instance release protection.

> This attribute applies only to pay-as-you-go instances and can only restrict manual release operations. This attribute does not take effect for system release operations.', position='Query'),
  ramRoleName?: string(name='RamRoleName', description='The name of the instance RAM role. You can use the RAM API [ListRoles](~~ 28713 ~~) to query the created instance RAM role.', position='Query'),
  affinity?: string(name='Affinity', description='Indicates whether the DDH instance is associated with the DDH. Valid values:

-default: the instance is not associated with a dedicated host. If you have enabled the shutdown saving mode for an instance and restart the instance after the instance is stopped, if the original DDH has insufficient available resources, the instance is placed on another DDH of the automatic deployment resource pool.

-host: the instance is associated with a dedicated host. Instances that have enabled the shutdown mode are still placed on the original dedicated host when they are restarted after the instance is stopped. If the original dedicated host does not have sufficient resources, the instance fails to be restarted.

default value: default', position='Query'),
  periodUnit?: string(name='PeriodUnit', description='The duration of the resource purchase. Valid values:

<props="china">
-Week
-Month

</props>

<props="intl">
-Month

</props>

<props="partner">
-Month

</props>

Default value: Month', position='Query'),
  securityGroupId?: string(name='SecurityGroupId', description='The ID of the security group to which the new instance belongs. Instances in the same security group can access each other.', position='Query'),
  vlanId?: string(name='VlanId', description='The ID of the VPC.', position='Query'),
  creditSpecification?: string(name='CreditSpecification', description='Modify the running mode of a burstable instance. Valid values:

-Standard: Standard mode. For more information about instance performance, see performance constraint mode in [What is burstable instance](~~ 59977 ~~).
-Unlimited: Unlimited Mode. For more information about instance performance, see Unlimited mode in [What is burstable instance](~~ 59977 ~~).

Default value: None', position='Query'),
  storageSetId?: string(name='StorageSetId', description='The ID of the storage set.', position='Query'),
  spotPriceLimit?: float(name='SpotPriceLimit', description='Set the maximum hourly price for an instance. A maximum of three decimal places are supported. This parameter takes effect when the value of "spotstratege" is "spotwithpricelime.', position='Query'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group to which the instance belongs.', position='Query'),
  autoRenew?: boolean(name='AutoRenew', description='Specifies whether to enable automatic renewal. This parameter takes effect only when the value of "InstanceChargeType" is "PrePaid. Valid values:

-true: auto renewal.
-false: the instance is not automatically renewed.', position='Query'),
  autoRenewPeriod?: int32(name='AutoRenewPeriod', description='The duration of each automatic renewal. This parameter is required when the AutoRenew parameter is set to True.

<props = "china"> when the PeriodUnit is Week, the value range of the AutoRenewPeriod is {"1", "2", "3"}. </props>

When the PeriodUnit is Month, the value range of the AutoRenewPeriod is {"1", "2", "3", "6", "12"}.
', position='Query'),
  imageId?: string(name='ImageId', description='The ID of the image file. To use Alibaba Cloud marketplace images, you can view "ImageId" on the Alibaba Cloud Marketplace image vendor details page ". This parameter is required if you do not specify "imagefamile" to select the latest available custom image of the Image family.', position='Query'),
  description?: string(name='Description', description='The description of the instance. The description must be 2 to 256 characters in length and cannot start with http:// or https.

Default value: Null.', position='Query'),
  spotStrategy?: string(name='SpotStrategy', description='The preemptible policy of the instance. This parameter takes effect only when the value of "InstanceChargeType" is "PostPaid. Valid values:

-NoSpot (default): a pay-as-you-go instance.
-SpotWithPriceLimit: sets the maximum price for preemptible instances.
-SpotAsPriceGo: The system automatically bids based on the actual market price.', position='Query'),
  zoneId?: string(name='ZoneId', description='The ID of the zone to which the instance belongs. For more information, see [DescribeZones](~~ 25610 ~~) for a list of zones.

> If you specify the "VSwitchId" parameter, the specified "ZoneId" parameter must be consistent with the zone where the vSwitch is located. If you do not specify the "ZoneId" parameter, the system automatically selects the zone where the specified vSwitch is located.

Default value: NULL. The system automatically selects this parameter.', position='Query'),
  useAdditionalService?: boolean(name='UseAdditionalService', description='Specifies whether to use the virtual machine system configurations provided by Alibaba Cloud (Windows:NTP and KMS;Linux:NTP and YUM).', position='Query'),
  hostName?: string(name='HostName', description='The hostname of the ECS instance.

-Periods (.) and hyphens (-) cannot be used as start and end characters, and cannot be used consecutively.
-Windows instance: the name must be 2 to 15 characters in length and cannot contain periods (.). It can contain uppercase and lowercase letters, digits, and hyphens (-).
-Other types of instances (such as Linux): The name must be 2 to 64 characters in length and can contain multiple periods (.), A period can contain uppercase and lowercase letters, digits, and hyphens (-).', position='Query'),
  keyPairName?: string(name='KeyPairName', description='The name of the key pair.

-Windows the instance. Ignore this parameter. The default value is null. Even if this parameter is specified, only the "Password" content is executed.
-The password logon method for Linux instances is initialized to disable. To improve instance security, we strongly recommend that you use the key pair connection method.', position='Query'),
  httpEndpoint?: string(name='HttpEndpoint', description='Specifies whether to enable the access channel for instance metadata. Valid values:
-enabled: enabled
-disabled: disabled

Default value: enabled
> For more information about instance metadata, see [instance metadata Overview](~~ 49122 ~~).', position='Query'),
  innerIpAddress?: string(name='InnerIpAddress', description='The internal IP address of the instance.', position='Query'),
  instanceChargeType?: string(name='InstanceChargeType', description='The billing method of the instance. Valid values:

-PrePaid: subscription. If you select this type of payment method, make sure that your account supports balance payment and credit payment. Otherwise, the error message "InvalidPayMethod" is returned.
-PostPaid (default): Pay-as-you-go.', position='Query'),
  internetChargeType?: string(name='InternetChargeType', description='The billing method of the network. Valid values:

-PayByBandwidth: pay-by-bandwidth.
-PayByTraffic (default): Pay by traffic.

> **pay-by-traffic** mode: The peak inbound and outbound bandwidth is the upper limit of the bandwidth and is not used as a service commitment indicator. When a resource scramble occurs, the peak bandwidth may be limited. If your business needs to be guaranteed by bandwidth, use the **pay-by-bandwidth** mode.', position='Query'),
  clientToken?: string(name='ClientToken', description='Ensure the idempotence of the request. Generate a parameter value from your client. Make sure that the value is unique among different requests. **ClientToken** supports only ASCII characters and cannot exceed 64 characters. For more information, see [how to ensure idempotence](~~ 25693 ~~).', position='Query'),
  privateIpAddress?: string(name='PrivateIpAddress', description='The private IP address of the instance. The IP address must be the idle address of the CIDR block of the vSwitch (VSwitchId).', position='Query'),
  instanceName?: string(name='InstanceName', description='The name of the instance. The description must be 2 to 128 characters in length. It must start with a letter and cannot start with http:// or https. It can contain numbers, colons (:), underscores (_), periods (.), and hyphens (-). If this parameter is not specified, the default value is the InstanceId of the instance.', position='Query'),
  dryRun?: boolean(name='DryRun', description='Specifies whether to PreCheck only this request. Valid values:

-true: sends a check request and does not create an instance. Check items include required parameters, request format, business restrictions, and ECS inventory. If the check fails, the corresponding error is returned. If the check succeeds, the error code "DryRunOperation" is returned ".
-false (default): Sends a normal request and directly creates an instance after passing the check.', position='Query'),
  imageFamily?: string(name='ImageFamily', description='The name of the Image family. You can set this parameter to obtain the latest available custom images in the current image family to create an instance.
-If "ImageId" is set, this parameter cannot be set.
-If "ImageId" is not set, this parameter can be set.', position='Query'),
  spotInterruptionBehavior?: string(name='SpotInterruptionBehavior', description='The interrupt mode of the preemptible instance. You can only release instances Terminate by default.', position='Query'),
  dedicatedHostId?: string(name='DedicatedHostId', description='Specifies whether to create an ECS instance on a dedicated host.

<props = "china"> You can use [DescribeDedicatedHosts](~~ 134242 ~~) to query the ID List of dedicated hosts. </props>

<props = "intl"> You can use [DescribeDedicatedHosts](~~ 134242 ~~) to query the ID List of dedicated hosts. </props>

Preemptible instances cannot be created on dedicated hosts. When the "DedicatedHostId" parameter is specified, the "spotstratege" and "spotpricelime" settings in the request are automatically ignored.', position='Query'),
  period?: int32(name='Period', description='The duration of the resource to be purchased. Unit: "__Dune. This parameter is required only when the value of "InstanceChargeType" is set to "PrePaid. If "DedicatedHostId" is specified, the value range cannot exceed the subscription duration of the dedicated host. Valid values:

<props="china">
When-PeriodUnit = Week, the value of Period is {"1", "2", "3", and "4"}.
When-PeriodUnit = Month, the value of Period is {"1", "2", "3", "4", "5", "6", "7", "8", "9", "12", "24", "36", "48", "60"}.

</props>

<props="intl">
When-PeriodUnit = Month, the value of Period is {"1", "2", "3", "4", "5", "6", "7", "8", "9", "12", "24", "36", "48", "60"}.

</props>

<props="partner">
When-PeriodUnit = Month, the value of Period is {"1", "2", "3", "4", "5", "6", "7", "8", "9", "12", "24", "36", "48", "60"}.

</props>', position='Query'),
}

model CreateInstanceResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.'),
  instanceId?: string(name='InstanceId', description='The ID of the instance.'),
  orderId?: string(name='OrderId', description='The ID of the order. This parameter is returned only when you create a subscription instance (the request parameter "InstanceChargeType = PrePaid").'),
  tradePrice?: float(name='TradePrice', description='Order selling price.'),
}

model CreateInstanceResponse = {
  headers: map[string]string(name='headers'),
  body: CreateInstanceResponseBody(name='body'),
}

/**
 * ## API description

> You can call [DescribeAvailableResource](~~ 66186 ~~) to view the instance resources in the specified region or zone. We recommend that you use the [Running](~~ 63440 ~~) API if you want to create multiple instances and the instances automatically enter the Running (RunInstances) state.

<props = "china"> Real-name authentication is required to create an ECS instance. For more information, see [account real-name authentication documentation](~~ 48263 ~~). </props>

When creating an ECS instance, note the following:

-**Billing * *:

-Creating an instance involves resource billing. We recommend that you know the billing method of the ECS instance in advance. For more information, see [billing Overview](~~ 25398 ~~).

-If the billing method of the instance is subscription ("PrePaid"), the available coupons are used by default when you pay for the instance.

-**Instance type * *:

-You can use the "IoOptimized" parameter to specify whether to create an I/O optimized instance.

-Product selection: see [instance type family](~~ 25378 ~~) or call [DescribeInstanceTypes](~~ 25620 ~~) to view the performance data of the target instance type, for more information about how to select an instance type, see [select configuration](~~ 58291 ~~).

-Query inventory: call [DescribeAvailableResource](~~ 66186 ~~) to view the resource supply in a specified region or zone.

> If "QuotaExceed. An ElasticQuota" error indicates that the number of instances to be created for the selected instance type in the current region exceeds the system limit, or the vCPU quota for the full instance type exceeds the system limit, you can go to the [ECS console](https://ecs.console.aliyun.com/? spm = a2c8b.12215451.favorites.decs.5e3a336aMGTtzy#/privileges/quota) or [quota Center](https://quotas.console.aliyun.com/products/ecs/quotas) apply for an increase in the quota.

-**Image * *:

-The image determines the system disk configuration of the instance. The system disk of the instance is the full clone of the specified image.

-When the instance memory is 512 MiB, you cannot use Windows Server images other than half-year channels.

-32-bit operating system images cannot be used when the instance memory is 4 GiB or more.

-**Network type * *:

-A VPC instance must belong to only one vSwitch.

-When "VSwitchId" is specified, "SecurityGroupId" and "VSwitchId" must belong to the same VPC.

-"PrivateIpAddress" depends on "VSwitchId". You cannot specify "PrivateIpAddress" separately ". When "VSwitchId" and "PrivateIpAddress" are specified at the same time, "PrivateIpAddress" must be included in the idle subnet CIDR block of the vSwitch.

-**Internet bandwidth * *:

-Starting from November 27, 2020, the peak bandwidth of an ECS instance is affected by the account speed limit policy. To increase the peak bandwidth, open a ticket. Specific rate limiting policy: in a single region, the total actual peak bandwidth of all ECS instances billed by traffic is no more than 5 Gbit/s; the total actual peak bandwidth of all pay-by-bandwidth ECS instances cannot exceed 50 Gbit/s.

-Instances created with "CreateInstance" are not assigned public IP addresses. You can call [AllocatePublicIpAddress](~~ 25544 ~~) to assign public IP addresses.

-The settings of "InternetChargeType" and "InternetMaxBandwidthOut" determine the bandwidth fee.

-Alibaba Cloud inbound data traffic is free of charge. The value of "InternetMaxBandwidthIn" has nothing to do with billing.

-"InternetChargeType = PayByBandwidth" indicates pay-by-bandwidth, and "InternetMaxBandwidthOut" indicates the selected fixed bandwidth.

-"InternetChargeType = PayByTraffic" indicates that the billing method is pay-as-you-go. "InternetMaxBandwidthOut" takes the upper limit of the bandwidth. The billing method is based on the actual network traffic.

-**Security Group * *:

-You must create a security group in advance, which can be created through [CreateSecurityGroup](~~ 25553 ~~).

-The number of instances in a security group depends on the security group type. For more information, see the security group section of [limits](~~ 25412 ~~).

-Instances in the same security group can access each other over the internal network. By default, different security groups are isolated from each other and cannot access each other, but they can be authorized to access each other. For more information, see [AuthorizeSecurityGroup](~~ 25554 ~~) and [AuthorizeSecurityGroupEgress](~~ 25560 ~~).

-**Storage * *:

-An instance is allocated a system disk of the corresponding size based on the specified image. The system disk capacity must be greater than or equal to "max{20, ImageSize}". For more information about the types of system disks, see the "SystemDisk.Category" parameter.

-The system disk of an I/O optimized instance can only be ESSD ("cloud_essd"), SSD ("cloud_ssd "), and ultra disk ("cloud_efficiency").

-The maximum capacity of data disks varies with the type of cloud disks. For more information, see "DataDisk.N.Size" parameter description.

-A maximum of 16 data disks can be added to an instance. Data disk mount points are allocated by default from/dev/xvdb to/dev/xvdz.

-**Custom data**: If the instance meets the limits of [instance Custom Data](~~ 49121 ~~), you can enter UserData information. The UserData is encoded in Base64. Because the "UserData" you set is not encrypted when you send API requests, we recommend that you do not pass confidential information, such as passwords and private keys, in plaintext. If this parameter is required, we recommend that you encrypt it, encode it in Base64, and then decrypt it in the same way.

-**Others**: when you use APIs in Alibaba Cloud CLI and SDKs, you must remove some input parameters with periods (.) before using them. For example, "systemdiskcategore" indicates the input parameter "SystemDisk. Categore ".
 */
async function createInstance(request: CreateInstanceRequest): CreateInstanceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateInstance', 'POST', 'undefined', 'json', false, 'none', request);
}

model EnablePhysicalConnectionRequest {
  regionId?: string(name='RegionId', position='Query'),
  physicalConnectionId?: string(name='PhysicalConnectionId', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  clientToken?: string(name='ClientToken', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  userCidr?: string(name='UserCidr', position='Query'),
}

model EnablePhysicalConnectionResponseBody = {
  requestId?: string(name='RequestId'),
}

model EnablePhysicalConnectionResponse = {
  headers: map[string]string(name='headers'),
  body: EnablePhysicalConnectionResponseBody(name='body'),
}

async function enablePhysicalConnection(request: EnablePhysicalConnectionRequest): EnablePhysicalConnectionResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'EnablePhysicalConnection', 'POST', 'undefined', 'json', false, 'none', request);
}

model DescribeInstanceTypeFamiliesRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  ownerId?: long(name='OwnerId', description='The ID of the RAM user.', position='Query'),
  regionId?: string(name='RegionId', description='The ID of the region. You can call [DescribeRegions](~~ 25609 ~~) to view the latest region list.', position='Query'),
  ownerAccount?: string(name='OwnerAccount', description='The logon name of the RAM user.', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', description='The ID of the resource master account, that is, the UID.', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='The account name of the resource master account.', position='Query'),
  generation?: string(name='Generation', description='The series information of the instance type family. For more information, see [instance type family](~~ 25378 ~~). Valid values:

-ecs-1: the type of the series I instance. The instance is released earlier and cost-effective.

-ecs-2: The Second software and hardware upgrade of the instance type family of Series II improves the performance of the instance.

-ecs-3: the instance type family of Series III. The instance has excellent performance and can meet different business requirements.

-ecs-4: Series IV instance family, including common enterprise-level instance types (g5, c5, r5, etc.), ECS bare metal instance types (ebmc5s, ebmg5s, ebmr5s, etc.), burstable instance types (t5) provide strong scenario adaptability and can meet a large number of popular business requirements with lower latency.

-ecs-5: Series V instance families, including common enterprise-level instance types (g6, c6, and r6), ECS bare metal instance types (ebmg6, ebmg6e, and ebmc6), storage enhanced instance types (g6e) provide faster response and better performance.

-ecs-6: Series VI instance families, including enterprise-level instance types (hfc7, hfg7, and hfr7), ebmhfg7, and, the instance type family is being invited for testing.', position='Query'),
}

model DescribeInstanceTypeFamiliesResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.'),
  instanceTypeFamilies?: {
    instanceTypeFamily?: [ 
    {
      generation?: string(name='Generation', description='The generation of the instance type family.'),
      instanceTypeFamilyId?: string(name='InstanceTypeFamilyId', description='The ID of the instance type family.'),
    }
  ](name='InstanceTypeFamily')
  }(name='InstanceTypeFamilies', description='A collection of instance type families InstanceTypeFamily.'),
}

model DescribeInstanceTypeFamiliesResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeInstanceTypeFamiliesResponseBody(name='body'),
}

async function describeInstanceTypeFamilies(request: DescribeInstanceTypeFamiliesRequest): DescribeInstanceTypeFamiliesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeInstanceTypeFamilies', 'POST', 'undefined', 'json', false, 'none', request);
}

model RollbackVolumeRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  volumeId?: string(name='VolumeId', position='Query'),
  snapshotId?: string(name='SnapshotId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
}

model RollbackVolumeResponseBody = {
  requestId?: string(name='RequestId'),
}

model RollbackVolumeResponse = {
  headers: map[string]string(name='headers'),
  body: RollbackVolumeResponseBody(name='body'),
}

async function rollbackVolume(request: RollbackVolumeRequest): RollbackVolumeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'RollbackVolume', 'POST', 'undefined', 'json', false, 'none', request);
}

model DeleteVolumeRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  volumeId?: string(name='VolumeId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
}

model DeleteVolumeResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteVolumeResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteVolumeResponseBody(name='body'),
}

async function deleteVolume(request: DeleteVolumeRequest): DeleteVolumeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteVolume', 'POST', 'undefined', 'json', false, 'none', request);
}

model CreateForwardEntryRequest {
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  forwardTableId?: string(name='ForwardTableId', position='Query'),
  externalIp?: string(name='ExternalIp', position='Query'),
  externalPort?: string(name='ExternalPort', position='Query'),
  internalIp?: string(name='InternalIp', position='Query'),
  internalPort?: string(name='InternalPort', position='Query'),
  ipProtocol?: string(name='IpProtocol', position='Query'),
}

model CreateForwardEntryResponseBody = {
  forwardEntryId?: string(name='ForwardEntryId'),
  requestId?: string(name='RequestId'),
}

model CreateForwardEntryResponse = {
  headers: map[string]string(name='headers'),
  body: CreateForwardEntryResponseBody(name='body'),
}

async function createForwardEntry(request: CreateForwardEntryRequest): CreateForwardEntryResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateForwardEntry', 'POST', 'undefined', 'json', false, 'none', request);
}

model DescribeRouterInterfacesRequest {
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  pageNumber?: int32(name='PageNumber', position='Query'),
  pageSize?: int32(name='PageSize', position='Query'),
  filter?: [ 
    {
      key?: string(name='Key'),
      value?: [ string ](name='Value'),
    }
  ](name='Filter', position='Query'),
}

model DescribeRouterInterfacesResponseBody = {
  requestId?: string(name='RequestId'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  totalCount?: int32(name='TotalCount'),
  routerInterfaceSet?: {
    routerInterfaceType?: [ 
    {
      healthCheckTargetIp?: string(name='HealthCheckTargetIp'),
      creationTime?: string(name='CreationTime'),
      status?: string(name='Status'),
      spec?: string(name='Spec'),
      oppositeInterfaceId?: string(name='OppositeInterfaceId'),
      routerInterfaceId?: string(name='RouterInterfaceId'),
      chargeType?: string(name='ChargeType'),
      oppositeRouterType?: string(name='OppositeRouterType'),
      oppositeInterfaceOwnerId?: string(name='OppositeInterfaceOwnerId'),
      description?: string(name='Description'),
      name?: string(name='Name'),
      oppositeRouterId?: string(name='OppositeRouterId'),
      oppositeInterfaceSpec?: string(name='OppositeInterfaceSpec'),
      routerId?: string(name='RouterId'),
      oppositeInterfaceBusinessStatus?: string(name='OppositeInterfaceBusinessStatus'),
      connectedTime?: string(name='ConnectedTime'),
      oppositeInterfaceStatus?: string(name='OppositeInterfaceStatus'),
      healthCheckSourceIp?: string(name='HealthCheckSourceIp'),
      endTime?: string(name='EndTime'),
      oppositeRegionId?: string(name='OppositeRegionId'),
      oppositeAccessPointId?: string(name='OppositeAccessPointId'),
      businessStatus?: string(name='BusinessStatus'),
      role?: string(name='Role'),
      routerType?: string(name='RouterType'),
      accessPointId?: string(name='AccessPointId'),
    }
  ](name='RouterInterfaceType')
  }(name='RouterInterfaceSet'),
}

model DescribeRouterInterfacesResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeRouterInterfacesResponseBody(name='body'),
}

async function describeRouterInterfaces(request: DescribeRouterInterfacesRequest): DescribeRouterInterfacesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeRouterInterfaces', 'POST', 'undefined', 'json', false, 'none', request);
}

model ModifyManagedInstanceRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  instanceId?: string(name='InstanceId', position='Query'),
  instanceName?: string(name='InstanceName', position='Query'),
}

model ModifyManagedInstanceResponseBody = {
  requestId?: string(name='RequestId'),
  instance?: {
    instanceName?: string(name='InstanceName'),
    instanceId?: string(name='InstanceId'),
  }(name='Instance'),
}

model ModifyManagedInstanceResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyManagedInstanceResponseBody(name='body'),
}

async function modifyManagedInstance(request: ModifyManagedInstanceRequest): ModifyManagedInstanceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyManagedInstance', 'POST', 'undefined', 'json', false, 'none', request);
}

model DescribeLaunchTemplatesRequest {
  templateTag?: [ 
    {
      key?: string(name='Key', description='启动模板的标签键。N的取值范围：1~20

使用一个标签过滤资源，查询到该标签下的资源数量不能超过1000个；使用多个标签过滤资源，查询到同时绑定了多个标签的资源数量不能超过1000个。如果资源数量超过1000个，请使用[ListTagResources](~~110425~~)接口进行查询。'),
      value?: string(name='Value', description='启动模板的标签值。N的取值范围：1~20'),
    }
  ](name='TemplateTag', position='Query'),
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  launchTemplateId?: [ string ](name='LaunchTemplateId', description='The ID of one or more instance launch templates. You can query up to 100 launch templates. You must specify LaunchTemplateId or LaunchTemplateName to determine the template.', position='Query'),
  launchTemplateName?: [ string ](name='LaunchTemplateName', description='The name of one or more instance launch templates. You can query up to 100 launch templates.', position='Query'),
  regionId?: string(name='RegionId', description='The ID of the region. You can call [DescribeRegions](~~ 25609 ~~) to view the latest region list.', position='Query'),
  templateResourceGroupId?: string(name='TemplateResourceGroupId', description='The ID of the resource group to which the launch template belongs. When you use this parameter to filter resources, the number of resources cannot exceed 1,000.', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='The account name of the resource master account.', position='Query'),
  ownerId?: long(name='OwnerId', description='The ID of the RAM user.', position='Query'),
  pageSize?: int32(name='PageSize', description='The number of entries to return on each page.

Default value: 10', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', description='The ID of the resource master account, that is, the UID.', position='Query'),
  pageNumber?: int32(name='PageNumber', description='The page number of the instance launch template list. Start value: 1

Default value: 1.', position='Query'),
}

model DescribeLaunchTemplatesResponseBody = {
  pageSize?: int32(name='PageSize', description='The number of entries to return on each page.'),
  requestId?: string(name='RequestId', description='The ID of the request.'),
  pageNumber?: int32(name='PageNumber', description='The current page number.'),
  totalCount?: int32(name='TotalCount', description='The total number of instance launch templates.'),
  launchTemplateSets?: {
    launchTemplateSet?: [ 
    {
      launchTemplateName?: string(name='LaunchTemplateName', description='The name of the template.'),
      defaultVersionNumber?: long(name='DefaultVersionNumber', description='The default version of the template.'),
      modifiedTime?: string(name='ModifiedTime', description='The modification time.'),
      launchTemplateId?: string(name='LaunchTemplateId', description='The ID of the template.'),
      createTime?: string(name='CreateTime', description='The time when the instance launch template was created.'),
      resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group to which the launch template belongs.'),
      createdBy?: string(name='CreatedBy', description='The creator of the template.'),
      latestVersionNumber?: long(name='LatestVersionNumber', description='The latest version of the template.'),
      tags?: {
        tag?: [ 
        {
          tagValue?: string(name='TagValue', description='The tag value of the launch template.'),
          tagKey?: string(name='TagKey', description='The tag key of the launch template.'),
        }
      ](name='Tag')
      }(name='Tags', description='The tag pair attribute of the launch template.'),
    }
  ](name='LaunchTemplateSet')
  }(name='LaunchTemplateSets', description='A collection of instance launch templates.'),
}

model DescribeLaunchTemplatesResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeLaunchTemplatesResponseBody(name='body'),
}

async function describeLaunchTemplates(request: DescribeLaunchTemplatesRequest): DescribeLaunchTemplatesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeLaunchTemplates', 'POST', 'undefined', 'json', false, 'none', request);
}

model EipNotifyPaidRequest {
  data?: string(name='data', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  clientToken?: string(name='ClientToken', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  userCidr?: string(name='UserCidr', position='Query'),
}

model EipNotifyPaidResponseBody = {
  code?: string(name='code'),
  success?: boolean(name='success'),
  message?: string(name='message'),
  data?: string(name='data'),
  requestId?: string(name='requestId'),
}

model EipNotifyPaidResponse = {
  headers: map[string]string(name='headers'),
  body: EipNotifyPaidResponseBody(name='body'),
}

async function eipNotifyPaid(request: EipNotifyPaidRequest): EipNotifyPaidResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'EipNotifyPaid', 'POST', 'undefined', 'json', false, 'none', request);
}

model ReleasePublicIpAddressRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  instanceId?: string(name='InstanceId', position='Query'),
  publicIpAddress?: string(name='PublicIpAddress', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
}

model ReleasePublicIpAddressResponseBody = {
  requestId?: string(name='RequestId'),
}

model ReleasePublicIpAddressResponse = {
  headers: map[string]string(name='headers'),
  body: ReleasePublicIpAddressResponseBody(name='body'),
}

async function releasePublicIpAddress(request: ReleasePublicIpAddressRequest): ReleasePublicIpAddressResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ReleasePublicIpAddress', 'POST', 'undefined', 'json', false, 'none', request);
}

model DisableActivationRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  activationId?: string(name='ActivationId', description='Activation Code ID.', position='Query'),
  regionId?: string(name='RegionId', description='The ID of the region. Only China (Hangzhou), China (Beijing), and China (Shanghai) are supported.', position='Query'),
}

model DisableActivationResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.'),
  activation?: {
    creationTime?: string(name='CreationTime', description='The creation time.'),
    deregisteredCount?: int32(name='DeregisteredCount', description='The number of canceled instances.'),
    instanceCount?: int32(name='InstanceCount', description='The maximum number of times an activation code is used to register a managed instance.'),
    description?: string(name='Description', description='The description of the activation code.'),
    registeredCount?: int32(name='RegisteredCount', description='The number of registered instances.'),
    instanceName?: string(name='InstanceName', description='The default instance name prefix.'),
    disabled?: boolean(name='Disabled', description='Indicates whether the activation code is disabled.'),
    ipAddressRange?: string(name='IpAddressRange', description='The IP address of the host that allows the activation code.'),
    timeToLiveInHours?: long(name='TimeToLiveInHours', description='The validity period of the activation code. Unit: Hour'),
    activationId?: string(name='ActivationId', description='Activation Code ID.'),
  }(name='Activation', description='A collection of activation codes and usage information.'),
}

model DisableActivationResponse = {
  headers: map[string]string(name='headers'),
  body: DisableActivationResponseBody(name='body'),
}

/**
 * ## API description

You can call this operation to disable the activation code. After the activation code is disabled, you cannot register a new managed instance with this activation code, but the registered managed instance is not affected.
 */
async function disableActivation(request: DisableActivationRequest): DisableActivationResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DisableActivation', 'POST', 'undefined', 'json', false, 'none', request);
}

model ReportInstancesStatusRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  regionId?: string(name='RegionId', description='The region ID of the instance. You can call [DescribeRegions](~~ 25609 ~~) to view the latest region list.', position='Query'),
  device?: [ string ](name='Device', description='The list of device names attached to one or more disks with the same exception. If you are using an ECS bare metal instance, enter the SLOT information list of the disk device.

Valid values of N: 1 to 100. Multiple values are in the form of duplicate lists.

> for elastic bare metal server instance, when the parameter "reason" value for "abnormal-local-disk or abnormal-cloud-disk ", or parameter "issuecategory" value for" hardware-disk-error "when the parameter is required.', position='Query'),
  startTime?: string(name='StartTime', description='The start time of the instance exception. The time follows the ISO 8601 standard and uses UTC +0. The format is yyyy-MM-ddTHH:mm:ssZ.', position='Query'),
  reason?: string(name='Reason', description='The impact of the exception on the ECS instance. Valid values:

-instance-hang: the ECS instance is unavailable or cannot be connected.
-instance-stuck-in-status: the ECS instance stays in a state for a long time, such as Starting or Stopping.
-abnormal-network: the ECS instance has a network exception.
-abnormal-local-disk: The local disk attached to the ECS instance is abnormal.
-abnormal-cloud-disk: An error occurred while mounting the cloud disk or shared block storage on the ECS instance.
-others: Other exception types. If the preceding impact types do not meet the requirements, you can set "Reason = others" and describe more information in "Description.', position='Query'),
  issueCategory?: string(name='IssueCategory', description='The type of the exception. This parameter applies only to ECS bare metal instances. Valid values:
-hardware-cpu-error:CPU failure
-hardware-motherboard-error: motherboard failure
-hardware-mem-error: memory failure
-hardware-power-error: power failure
-hardware-disk-error: disk failure
-hardware-networkcard-error: Nic failure
-hardware-raidcard-error:SAS/RAID card failure
-hardware-fan-error: fan failure
-others: others', position='Query'),
  instanceId?: [ string ](name='InstanceId', description='The ID of one or more ECS instances. Valid values of N: 1 to 100. Multiple values are in the form of duplicate lists.', position='Query'),
  description?: string(name='Description', description='The detailed description of the exception.', position='Query'),
  diskId?: [ string ](name='DiskId', description='The ID of one or more disks that have the same exception. If you are using an ECS bare metal instance, enter the SN list of the disk device.

Valid values of N: 1 to 100. Multiple values are in the form of duplicate lists.

> when the parameter "reason" value for "abnormal-local-disk or abnormal-cloud-disk", or parameter "issuecategory" value for "hardware-disk-error when, this parameter is required.', position='Query'),
  endTime?: string(name='EndTime', description='The end time of the instance exception. The time follows the ISO 8601 standard and uses UTC +0. The format is yyyy-MM-ddTHH:mm:ssZ.', position='Query'),
}

model ReportInstancesStatusResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.'),
}

model ReportInstancesStatusResponse = {
  headers: map[string]string(name='headers'),
  body: ReportInstancesStatusResponseBody(name='body'),
}

async function reportInstancesStatus(request: ReportInstancesStatusRequest): ReportInstancesStatusResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ReportInstancesStatus', 'POST', 'undefined', 'json', false, 'none', request);
}

model DescribeAccountAttributesRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  regionId?: string(name='RegionId', description='The ID of the region. You can call [DescribeRegions](~~ 25609 ~~) to view the latest region list.', position='Query'),
  zoneId?: string(name='ZoneId', description='The ID of the zone.', position='Query'),
  attributeName?: [ string ](name='AttributeName', description='You can call this operation to query the quota of a resource in a specified region. Valid values of N: 1 to 8. Valid values:

-instance-network-type: optional network type.
-max-security-groups: the number of security groups.
-max-elastic-network-interfaces: the number of Enis.
-max-postpaid-instance-vcpu-count: the maximum number of vCPU cores for a pay-as-you-go instance.
-max-spot-instance-vcpu-count: the maximum number of VCPUs in a preemptible instance.
-used-postpaid-instance-vcpu-count: the number of vCPU cores of a pay-as-you-go instance.
-used-spot-instance-vcpu-count: the number of vCPU cores of a preemptible instance.
-max-postpaid-yundisk-capacity: the maximum capacity of a pay-as-you-go cloud disk used as a data disk.
-used-postpaid-yundisk-capacity: the capacity of a pay-as-you-go cloud disk used as a data disk.
-max-dedicated-hosts: the number of dedicated hosts.
-supported-postpaid-instance-types: pay-as-you-go I/O optimized instance types.
-max-axt-command-count: the number of cloud assistant commands.
-max-axt-invocation-daily: the number of cloud assistant commands that can be executed per day.
-real-name-authentication: indicates whether the account has completed real-name authentication.

> You can create ECS instances in mainland China only after you complete real-name authentication.

Default value: Null.', position='Query'),
}

model DescribeAccountAttributesResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.'),
  accountAttributeItems?: {
    accountAttributeItem?: [ 
    {
      attributeName?: string(name='AttributeName', description='The quota category of resources in the specified region. Possible values:

-instance-network-type: optional network type.
-max-security-groups: the number of security groups.
-max-elastic-network-interfaces: the number of Enis.
-max-postpaid-instance-vcpu-count: the maximum number of vCPU cores for a pay-as-you-go instance.
-max-spot-instance-vcpu-count: the maximum number of VCPUs in a preemptible instance.
-used-postpaid-instance-vcpu-count: the number of vCPU cores of a pay-as-you-go instance.
-used-spot-instance-vcpu-count: the number of vCPU cores of a preemptible instance.
-max-postpaid-yundisk-capacity: the maximum capacity of a pay-as-you-go cloud disk used as a data disk.
-used-postpaid-yundisk-capacity: the capacity of a pay-as-you-go cloud disk used as a data disk.
-max-dedicated-hosts: the number of dedicated hosts.
-supported-postpaid-instance-types: pay-as-you-go I/O optimized instance types.
-max-axt-command-count: the number of cloud assistant commands.
-max-axt-invocation-daily: the number of cloud assistant commands that can be executed per day.
-real-name-authentication: indicates whether the account has completed real-name authentication.'),
      attributeValues?: {
        valueItem?: [ 
        {
          diskCategory?: string(name='DiskCategory', description='The type of the data disk. Possible values:
-cloud_efficiency: Ultra disk
-cloud_ssd:SSD cloud disk
-cloud_essd:ESSD
'),
          value?: string(name='Value', description='The quota of a type of resource in the current region or all regions. Possible values:

The following categories return a value of 0 or a positive integer:

-max-security-groups
-max-elastic-network-interfaces
-max-postpaid-instance-vcpu-count
-max-spot-instance-vcpu-count
-used-postpaid-instance-vcpu-count
-used-spot-instance-vcpu-count
-max-postpaid-yundisk-capacity
-used-postpaid-yundisk-capacity
-max-dedicated-hosts
-max-axt-command-count
-max-axt-invocation-daily

Assortment for supported-postpay-instance-types when return value: instance dimension value. For more information, see [instance type family](~~ 25378 ~~).

Returns the value when the type is real-name-authentications:

-Yes
-none
-unnecessary

Return value of instance-network-type:

-vpc
-classic'),
          expiredTime?: string(name='ExpiredTime', description='The expiration time of the privilege. This parameter is returned only for account privileges that have the Expiration Time. The time follows the [ISO8601](~~ 25696 ~~) standard and uses UTC +0. The format is yyyy-MM-ddTHH:mm:ssZ.'),
          zoneId?: string(name='ZoneId', description='The ID of the zone.'),
          instanceType?: string(name='InstanceType', description='The instance type.'),
          count?: int32(name='Count', description='The number of privileged attribute types.'),
          instanceChargeType?: string(name='InstanceChargeType', description='The billing method of the instance.'),
        }
      ](name='ValueItem')
      }(name='AttributeValues', description='The number of resource quotas.'),
    }
  ](name='AccountAttributeItem')
  }(name='AccountAttributeItems', description='The information set of account privilege AccountAttributeItem in the specified region.'),
}

model DescribeAccountAttributesResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeAccountAttributesResponseBody(name='body'),
}

/**
 * ## API description

<props = "china">[register](https://account.aliyun.com/register/register.htm) an Alibaba Cloud account, you can create a certain number of ECS resources in different Alibaba cloud regions. For more information, for more information, see [limits](~~ 25412 ~~). </props>

<props = "intl">[register](https://account.alibabacloud.com/register/intl_register.htm) an Alibaba Cloud account, you can create a certain number of ECS resources in different Alibaba cloud regions. For more information, for more information, see [limits](~~ 25412 ~~). </props>

<props = "partner"> after you have registered an Alibaba Cloud account, you can create a certain number of ECS resources in different Alibaba cloud regions. For more information, for more information, see [limits](~~ 25412 ~~). </props>

<props = "china"> You can also [submit a ticket](https://selfservice.console.aliyun.com/ticket/createIndex.htm) to increase the resource usage quota according to your needs. </props>

<props = "intl"> You can also [submit a ticket](https://workorder-intl.console.aliyun.com/#/ticket/createIndex) to increase the resource usage quota according to your needs. </props>

<props = "partner"> You can also submit a ticket to increase the resource usage quota according to your needs. </props>
 */
async function describeAccountAttributes(request: DescribeAccountAttributesRequest): DescribeAccountAttributesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeAccountAttributes', 'POST', 'undefined', 'json', false, 'none', request);
}

model EipFillParamsRequest {
  data?: string(name='data', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  clientToken?: string(name='ClientToken', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  userCidr?: string(name='UserCidr', position='Query'),
}

model EipFillParamsResponseBody = {
  code?: string(name='code'),
  success?: boolean(name='success'),
  message?: string(name='message'),
  data?: string(name='data'),
  requestId?: string(name='requestId'),
}

model EipFillParamsResponse = {
  headers: map[string]string(name='headers'),
  body: EipFillParamsResponseBody(name='body'),
}

async function eipFillParams(request: EipFillParamsRequest): EipFillParamsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'EipFillParams', 'POST', 'undefined', 'json', false, 'none', request);
}

model ModifyPrepayInstanceSpecRequest {
  systemDisk?: {
    category?: string(name='Category', description='Change the system disk type. This parameter can only be upgraded from [phased-out instance type](~~ 55263 ~~) to [normal instance type family](~~ 25378 ~~), this parameter is valid when the non-I/O optimized instance type is upgraded to the I/O optimized instance type. Valid values:

-cloud_efficiency: Ultra disk

-cloud_ssd:SSD cloud disk', position=''),
  }(name='SystemDisk'),
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  instanceType?: string(name='InstanceType', description='The specification of the target instance. For more information, see [instance type family](~~ 25378 ~~) or call [DescribeInstanceTypes](~~ 25620 ~~).', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='The account name of the resource master account.', position='Query'),
  regionId?: string(name='RegionId', description='The ID of the region to which the instance belongs. You can call [DescribeRegions](~~ 25609 ~~) to view the latest region list.', position='Query'),
  ownerId?: long(name='OwnerId', description='The ID of the RAM user.', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', description='The ID of the resource master account, that is, the UID.', position='Query'),
  instanceId?: string(name='InstanceId', description='The ID of the instance.', position='Query'),
  rebootWhenFinished?: boolean(name='RebootWhenFinished', description='Indicates whether to restart the instance immediately after the configuration change. Valid values:
-true: Yes
-false: no

Default value: false

> If the instance is in the **stopped** state, even if you set "rebootwherefinished = true", it remains unchanged and does not perform any operations.', position='Query'),
  endTime?: string(name='EndTime', description='The end time of the temporary change. The time follows the [ISO8601](~~ 25696 ~~) standard and uses UTC +0. The format is yyyy-MM-ddTHH:mmZ.', position='Query'),
  clientToken?: string(name='ClientToken', description='Ensure the idempotence of the request. Generate a parameter value from your client. Make sure that the value is unique among different requests. **ClientToken** supports only ASCII characters and cannot exceed 64 characters. For more information, see [how to ensure idempotence](~~ 25693 ~~).', position='Query'),
  rebootTime?: string(name='RebootTime', description='The restart time of the instance. The time follows the [ISO8601](~~ 25696 ~~) standard and uses UTC +0. The format is yyyy-MM-ddTHH:mmZ.', position='Query'),
  operatorType?: string(name='OperatorType', description='The operation type. Valid values:

-upgrade: upgrades the instance type. Make sure that your account balance is sufficient.

-downgrade: downgrade the instance type. When the instance type set by "InstanceType" is lower than the current instance type, you must set "OperatorType = downgrade ".

> For more information about how to upgrade or downgrade an instance type, see the preceding section.', position='Query'),
  autoPay?: boolean(name='AutoPay', description='Specifies whether to pay automatically when you upgrade the instance type. Valid values:

-true (default): automatic payment.

> make sure that the balance of the payment method is sufficient. Otherwise, an abnormal order will be generated and the order can only be canceled. If the balance of your payment method is insufficient, you can set the parameter "AutoPay" to "false" to generate an unpaid order. You can log on to the ECS console to pay by yourself.

-false: only generated orders are billed.

When the "OperatorType" parameter is set to "downgrade", the "AutoPay" parameter is ignored ".', position='Query'),
  migrateAcrossZone?: boolean(name='MigrateAcrossZone', description='Indicates whether the instance type can be upgraded across clusters.

Default value: false

If the MigrateAcrossZone parameter is set to true, note the following when you upgrade the ECS instance based on the returned information:

Classic network type instance:

* For [phased-out instance types](~~ 55263 ~~), when a non-I/O optimized instance is changed to an I/O optimized instance, the private IP address of the instance, the disk device name and software authorization code change. For Linux instances, basic cloud disks are identified as xvda or xvdb, and ultra cloud disks (cloud_efficiency) and SSD cloud disks (cloud_ssd) are identified as vda or vdb.

* For [normal instance type families](~~ 25378 ~~), the private IP address of the instance changes.

VPC instances: for phased-out instance types, when a non-I/O optimized instance is changed to an I/O optimized instance, the disk device name and software authorization code of the ECS instance change. For Linux instances, basic cloud disks are identified as xvda or xvdb, and ultra cloud disks (cloud_efficiency) and SSD cloud disks (cloud_ssd) are identified as vda or vdb.', position='Query'),
}

model ModifyPrepayInstanceSpecResponseBody = {
  orderId?: string(name='OrderId', description='The ID of the generated order.'),
  requestId?: string(name='RequestId', description='The ID of the request.'),
}

model ModifyPrepayInstanceSpecResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyPrepayInstanceSpecResponseBody(name='body'),
}

/**
 * ## API description

<props = "china"> make sure that you have fully understood the billing method and product pricing of [ECS](https://www.aliyun.com/price/product#/ecs/detail) before using this interface. </props>

<props = "intl"> make sure that you have fully understood the billing method and product pricing of [ECS](https://www.alibabacloud.com/product/ecs#pricing) before using this interface. </props>

Before you upgrade or downgrade a subscription instance type, you can use [DescribeResourcesModification](~~ 66187 ~~) to query the instance types that can be changed. For more information, see Python SDK example [query available resources for ECS configuration changes](~~ 109517 ~~).

When you call this operation, note that:

-You cannot modify the instance type of an expired instance. You can renew the instance and try again.

-Note the following when you downgrade the instance type:

-The instance must be in the **stopped**("Stopped") status.
-You must specify the operation type, that is, "OperatorType = downgrade ".
-Each instance cannot be downgraded more than three times, that is, the price difference refund cannot exceed three times. Downgrade configurations include downgrading instance types, downgrading bandwidth configurations, and converting subscription disks to pay-as-you-go disks.
-The refund for the price difference between the instance types before and after the reduction will be returned to your original billing method, and the used vouchers will not be returned.

-This operation is asynchronous. Wait about 5 to 10 seconds for the configuration change to complete. Then, you must call the API or restart the instance in the console. Otherwise, the specification change will not take effect and the restart of the operating system will not take effect.

-If the instance is in the **stopped** status, you only need to start the instance without restarting it.
-If the instance is set to "rebootwherefinished = true", you do not need to restart the instance separately.
 */
async function modifyPrepayInstanceSpec(request: ModifyPrepayInstanceSpecRequest): ModifyPrepayInstanceSpecResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyPrepayInstanceSpec', 'POST', 'undefined', 'json', false, 'none', request);
}

model EipFillProductRequest {
  data?: string(name='data', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  clientToken?: string(name='ClientToken', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  userCidr?: string(name='UserCidr', position='Query'),
}

model EipFillProductResponseBody = {
  code?: string(name='code'),
  success?: boolean(name='success'),
  message?: string(name='message'),
  data?: string(name='data'),
  requestId?: string(name='requestId'),
}

model EipFillProductResponse = {
  headers: map[string]string(name='headers'),
  body: EipFillProductResponseBody(name='body'),
}

async function eipFillProduct(request: EipFillProductRequest): EipFillProductResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'EipFillProduct', 'POST', 'undefined', 'json', false, 'none', request);
}

model DescribeInstanceMaintenanceAttributesRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  regionId?: string(name='RegionId', description='The ID of the region to which the instance belongs. You can call [DescribeRegions](~~ 25609 ~~) to view the latest region list.', position='Query'),
  instanceId?: [ string ](name='InstanceId', description='The ID of the instance. Valid values of N: 1 to 100', position='Query'),
  pageSize?: long(name='PageSize', description='The number of entries returned per page. Valid values: 1 to 100.

Default value: 10', position='Query'),
  pageNumber?: long(name='PageNumber', description='The page number of the maintenance attribute list.

Start value: 1

Default value: 1.', position='Query'),
}

model DescribeInstanceMaintenanceAttributesResponseBody = {
  pageSize?: int32(name='PageSize', description='The number of entries returned per page.'),
  requestId?: string(name='RequestId', description='The ID of the request.'),
  pageNumber?: int32(name='PageNumber', description='The page number of the maintenance attribute list.'),
  totalCount?: int32(name='TotalCount', description='The total number of maintenance attributes queried.'),
  maintenanceAttributes?: {
    maintenanceAttribute?: [ 
    {
      notifyOnMaintenance?: boolean(name='NotifyOnMaintenance', description='Specifies whether to send event notifications before instance downtime.'),
      instanceId?: string(name='InstanceId', description='The ID of the instance.'),
      maintenanceWindows?: {
        maintenanceWindow?: [ 
        {
          endTime?: string(name='EndTime', description='The end time of the maintenance window.'),
          startTime?: string(name='StartTime', description='The start time of the maintenance time window.'),
        }
      ](name='MaintenanceWindow')
      }(name='MaintenanceWindows', description='The list of instances in the O & M window.'),
      actionOnMaintenance?: {
        defaultValue?: string(name='DefaultValue', description='The default value of the maintenance action.
'),
        value?: string(name='Value', description='The value of the maintenance action. Possible values:

-Stop: the stopped state (that is, the downtime).
-AutoRecover: automatic recovery.
-AutoRedeploy: data disks are damaged due to downtime migration.'),
        supportedValues?: {
          supportedValue?: [ string ](name='SupportedValue')
        }(name='SupportedValues'),
      }(name='ActionOnMaintenance', description='The operation and maintenance properties of the instance.'),
    }
  ](name='MaintenanceAttribute')
  }(name='MaintenanceAttributes', description='The collection of O & M attributes.'),
}

model DescribeInstanceMaintenanceAttributesResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeInstanceMaintenanceAttributesResponseBody(name='body'),
}

/**
 * ## API description
You can call this operation to query the configured maintenance policies. These policies include two maintenance attributes.

-Maintenance time window: the time period specified by you. Maintenance is performed only during this period.
-Maintenance action: the action that you specify to handle instance downtime.
 */
async function describeInstanceMaintenanceAttributes(request: DescribeInstanceMaintenanceAttributesRequest): DescribeInstanceMaintenanceAttributesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeInstanceMaintenanceAttributes', 'POST', 'undefined', 'json', false, 'none', request);
}

model CreateAutoProvisioningGroupRequest {
  launchConfiguration?: {
    dataDisk?: [ 
      {
        performanceLevel?: string(name='PerformanceLevel', description='创建ESSD云盘作为数据盘使用时，设置云盘的性能等级。N的取值必须和`LaunchConfiguration.DataDisk.N.Category`中的N保持一致。取值范围：

- PL0：单盘最高随机读写IOPS 1万
- PL1（默认）：单盘最高随机读写IOPS 5万
- PL2：单盘最高随机读写IOPS 10万
- PL3：单盘最高随机读写IOPS 100万

有关如何选择ESSD性能等级，请参见[ESSD云盘](~~122389~~)。

同时指定启动模板与启动配置信息时，优先使用启动模板。'),
        kmsKeyId?: string(name='KmsKeyId', description='数据盘对应的KMS密钥ID。同时指定启动模板与启动配置信息时，优先使用启动模板。'),
        description?: string(name='Description', description='数据盘的描述。长度为2~256个英文或中文字符，不能以`http://`和`https://`开头。同时指定启动模板与启动配置信息时，优先使用启动模板。'),
        snapshotId?: string(name='SnapshotId', description='创建数据盘N使用的快照。N的取值范围为1~16。

指定该参数后，参数`LaunchConfiguration.DataDisk.N.Size`会被忽略，实际创建的云盘大小为指定的快照的大小。不能使用早于2013年7月15日（含）创建的快照，请求会报错被拒绝。

同时指定启动模板与启动配置信息时，优先使用启动模板。'),
        size?: int32(name='Size', description='第N个数据盘的容量大小，N的取值范围为1~16，单位为GiB。取值范围：

- cloud_efficiency：20~32768
- cloud_ssd：20~32768
- cloud_essd：20~32768
- cloud：5~2000

> 该参数的取值必须大于等于参数`LaunchConfiguration.DataDisk.N.SnapshotId`指定的快照的大小。

同时指定启动模板与启动配置信息时，优先使用启动模板。'),
        device?: string(name='Device', description='数据盘的挂载点。同时指定启动模板与启动配置信息时，优先使用启动模板。'),
        diskName?: string(name='DiskName', description='数据盘名称。长度为2~128个英文或中文字符。必须以大小字母或中文开头，不能以`http://`和`https://`开头。可以包含数字、半角句号（.）、半角冒号（:）、下划线（_）或者短划线（-）。

默认值：空

同时指定启动模板与启动配置信息时，优先使用启动模板。'),
        category?: string(name='Category', description='数据盘N的云盘类型。N的取值范围为1~16。取值范围：

- cloud_efficiency：高效云盘
- cloud_ssd：SSD云盘
- cloud_essd：ESSD云盘
- cloud：普通云盘。

对于I/O优化实例，默认值为cloud_efficiency。对于非I/O优化实例，默认值为cloud。

同时指定启动模板与启动配置信息时，优先使用启动模板。'),
        deleteWithInstance?: boolean(name='DeleteWithInstance', description='数据盘是否随实例释放。取值范围：
- true：数据盘随实例释放。
- false：数据盘不随实例释放。

默认值：true

同时指定启动模板与启动配置信息时，优先使用启动模板。'),
        encrypted?: boolean(name='Encrypted', description='数据盘N是否加密。取值范围：

- true：加密
- false：不加密

默认值：false

同时指定启动模板与启动配置信息时，优先使用启动模板。'),
      }
    ](name='DataDisk', position=''),
    tag?: [ 
      {
        key?: string(name='Key', description='实例的标签键。N的取值范围：1~20。一旦传入该值，则不允许为空字符串。最多支持128个字符，不能以aliyun和acs:开头，不能包含`http://`或`https://`。同时指定启动模板与启动配置信息时，优先使用启动模板。'),
        value?: string(name='Value', description='实例的标签值。N的取值范围：1~20。一旦传入该值，可以为空字符串。最多支持128个字符，不能以acs:开头，不能包含`http://`或者`https://`。同时指定启动模板与启动配置信息时，优先使用启动模板。'),
      }
    ](name='Tag', position=''),
    password?: string(name='Password', position=''),
    securityGroupId?: string(name='SecurityGroupId', description='The ID of the security group to which the instance belongs. When you specify both the launch template and the launch configuration, the launch template is used first.', position=''),
    systemDiskDescription?: string(name='SystemDiskDescription', description='The description of the system disk. The description must be 2 to 256 characters in length and cannot start with "http:// "or "https.

When you specify both the launch template and the launch configuration, the launch template is used first.', position=''),
    deploymentSetId?: string(name='DeploymentSetId', description='The ID of the deployment set.', position=''),
    securityEnhancementStrategy?: string(name='SecurityEnhancementStrategy', description='Specifies whether to enable security hardening. Valid values:

-Active: enables security hardening, which takes effect only for public images.
-Deactive: does not enable security hardening and takes effect for all image types.

When you specify both the launch template and the launch configuration, the launch template is used first.', position=''),
    internetMaxBandwidthOut?: int32(name='InternetMaxBandwidthOut', description='The maximum outbound public bandwidth. Unit: Mbit/s. Valid values: 0 to 100.

Default value: 0.

When you specify both the launch template and the launch configuration, the launch template is used first.', position=''),
    internetMaxBandwidthIn?: int32(name='InternetMaxBandwidthIn', description='The maximum inbound public bandwidth. Unit: Mbit/s. Valid values:

-When the Internet outbound bandwidth is less than or equal to 10Mbit/s: 1 to 10, the default value is 10.
-When the outbound bandwidth of the public network is greater than 10Mbit/s: 1 to "LaunchConfiguration.InternetMaxBandwidthOut". The default value is "LaunchConfiguration.InternetMaxBandwidthOut.

When you specify both the launch template and the launch configuration, the launch template is used first.', position=''),
    imageId?: string(name='ImageId', description='The ID of the image. You can call [DescribeImages](~~ 25534 ~~) to query available image resources. When you specify both the launch template and the launch configuration, the launch template is used first.', position=''),
    creditSpecification?: string(name='CreditSpecification', description='Modify the running mode of a burstable instance. Valid values:

-Standard: Standard mode. For more information about instance performance, see performance constraint mode in [What is burstable instance](~~ 59977 ~~).
-Unlimited: Unlimited Mode. For more information about instance performance, see Unlimited mode in [What is burstable instance](~~ 59977 ~~).

Default value: None

When you specify both the launch template and the launch configuration, the launch template is used first.', position=''),
    systemDiskSize?: int32(name='SystemDiskSize', description='System disk size. The unit is GiB. Valid values: 20 to 500. The value of this parameter must be greater than or equal to max{20, LaunchConfiguration.ImageId image size}.

Default value: max{40. The image size corresponding to the parameter LaunchConfiguration.ImageId}.

When you specify both the launch template and the launch configuration, the launch template is used first.', position=''),
    instanceDescription?: string(name='InstanceDescription', description='The description of the instance. The description must be 2 to 256 characters in length and cannot start with "http:// "or "https. When you specify both the launch template and the launch configuration, the launch template is used first.', position=''),
    ioOptimized?: string(name='IoOptimized', description='Indicates whether the instance is I/O optimized. Valid values:

-none: Non-I/O optimized
-optimized:I/O optimized

The default value of phased-out instance types is none. The default value of other instance types is optimized.

When you specify both the launch template and the launch configuration, the launch template is used first.', position=''),
    systemDiskName?: string(name='SystemDiskName', description='System disk name. The description must be 2 to 128 characters in length. It must start with a letter and cannot start with "http:// "or "https. It can contain numbers, periods (.), colons (:), underscores (_), and hyphens (-).

Default value: Null.

When you specify both the launch template and the launch configuration, the launch template is used first.', position=''),
    userData?: string(name='UserData', description='The user data of the instance. It must be encoded in Base64. the maximum size of raw data is 16KB. When you specify both the launch template and the launch configuration, the launch template is used first.', position=''),
    instanceName?: string(name='InstanceName', description='The name of the instance. The description must be 2 to 128 characters in length. It must start with a letter and cannot start with "http://" or "https. It can contain letters, digits, colons (:), underscores (_), periods (.), and hyphens (-). The default value is the instanceid" of the instance ".

When you create multiple ECS instances, you can set multiple instance names in batches. For more information, see [batch set ordered instance names or host names](~~ 196048 ~~).

When you specify both the launch template and the launch configuration, the launch template is used first.', position=''),
    systemDiskCategory?: string(name='SystemDiskCategory', description='The type of the system disk. Valid values:

-cloud_efficiency: Ultra disk
-cloud_ssd:SSD cloud disk
-cloud_essd:ESSD
-cloud: basic cloud disk

For phased-out instance types and non-I/O optimized instances, the default value is cloud. Otherwise, the default value is cloud_efficiency.

When you specify both the launch template and the launch configuration, the launch template is used first.', position=''),
    ramRoleName?: string(name='RamRoleName', description='The name of the instance RAM role. You can use the RAM API [ListRoles](~~ 28713 ~~) to query the created instance RAM role. When you specify both the launch template and the launch configuration, the launch template is used first.', position=''),
    resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group to which the instance belongs. When you specify both the launch template and the launch configuration, the launch template is used first.', position=''),
    keyPairName?: string(name='KeyPairName', description='The name of the key pair.

-Windows the instance. Ignore this parameter. The default value is null.
-The password logon method for Linux instances is initialized to disable.

When you specify both the launch template and the launch configuration, the launch template is used first.', position=''),
    internetChargeType?: string(name='InternetChargeType', description='The billing method of the network. Valid values:

-PayByBandwidth: pay-by-bandwidth
-PayByTraffic: pay by traffic

> The peak inbound and outbound bandwidth in pay-by-traffic mode is the upper limit of the bandwidth and is not used as a service commitment indicator. When a resource scramble occurs, the peak bandwidth may be limited. If your business needs to be guaranteed by bandwidth, use the pay-by-bandwidth billing method.

When you specify both the launch template and the launch configuration, the launch template is used first.', position=''),
    passwordInherit?: boolean(name='PasswordInherit', description='Specifies whether to use the default password of the image. Valid values:

-true: use
-false: Do not use

When you specify both the launch template and the launch configuration, the launch template is used first.', position=''),
    systemDiskPerformanceLevel?: string(name='SystemDiskPerformanceLevel', description='When you create an ESSD as a system disk, set the performance level of the disk. Valid values:

-PL0 (default): The maximum random read/write IOPS per disk is 10,000.
-PL1: The maximum random read/write IOPS per disk is 50,000
-PL2: The maximum random read/write IOPS per disk is 100,000
-PL3: The maximum random read/write IOPS per disk is 1 million

For more information about how to select an ESSD performance level, see [ESSD cloud disk](~~ 122389 ~~).

When you specify both the launch template and the launch configuration, the launch template is used first.', position=''),
    hostNames?: [ string ](name='HostNames', description='Specify different host names for one or more instances. Limits:

-This parameter takes effect only when you create an auto provisioning Group of the one-time synchronous delivery type ("AutoProvisioningGroupType = instant").
-N indicates the number of instances. Valid values: 1 to 1000. The value must be the same as that of the TotalTargetCapacity parameter.
-Periods (.) and hyphens (-) cannot be used as start and end characters, and cannot be used consecutively.
-Windows instance: the name must be 2 to 15 characters in length and cannot contain periods (.). It can contain uppercase and lowercase letters, digits, and hyphens (-).
-Other types of instances (such as Linux): The name must be 2 to 64 characters in length and can contain multiple periods (.), half end (.) each segment can contain uppercase and lowercase letters, digits, and hyphens (-).
-You cannot set "LaunchConfiguration.HostName" and "LaunchConfiguration.HostNames. **At the same time. Otherwise, an error message is returned.
-When you specify both the startup template and startup configuration information, the startup template is used first.', position=''),
    hostName?: string(name='HostName', description='The name of the instance. Limits:

-Periods (.) and hyphens (-) cannot be used as start and end characters, and cannot be used consecutively.
-Windows instance: the name must be 2 to 15 characters in length and cannot contain periods (.). It can contain uppercase and lowercase letters, digits, and hyphens (-).
-Other types of instances (such as Linux): The name must be 2 to 64 characters in length and can contain multiple periods (.), A segment can contain uppercase and lowercase letters, digits, and hyphens (-).
-You cannot set "LaunchConfiguration.HostName" and "LaunchConfiguration.HostNames. **At the same time. Otherwise, an error message is returned.
-When you specify both the startup template and startup configuration information, the startup template is used first.

', position=''),
  }(name='LaunchConfiguration'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  launchTemplateConfig?: [ 
    {
      vSwitchId?: string(name='VSwitchId', description='扩展启动模板中，ECS实例加入的虚拟交换机的ID。扩展模板中启动的ECS实例的可用区由虚拟交换机决定。

> 设置了`LaunchTemplateConfig`后，`LaunchTemplateConfig.N.VSwitchId`为必选参数。'),
      maxPrice?: double(name='MaxPrice', description='扩展启动模板中，抢占式实例的价格上限。

> 设置了`LaunchTemplateConfig`后，`LaunchTemplateConfig.N.MaxPrice`为必选参数。'),
      priority?: int32(name='Priority', description='扩展启动模板的优先级，取值为0时优先级最高。取值范围：0 ~ +∞

'),
      instanceType?: string(name='InstanceType', description='扩展启动模板对应的实例规格，N的取值范围：1~20。取值范围：请参见[实例规格族](~~25378~~)。'),
      weightedCapacity?: double(name='WeightedCapacity', description='扩展启动模板中，实例规格的权重。取值越高，单台实例满足计算力需求的能力越大，所需的实例数量越小。取值范围：大于0

您可以根据指定实例规格的计算力和集群单节点最低计算力得出权重值。假设单节点最低计算力为8 vCPU、60GiB，则：

- 8 vCPU、60GiB的实例规格权重可以设置为1
- 16 vCPU、120GiB的实例规格权重可以设置为2'),
    }
  ](name='LaunchTemplateConfig', position='Query'),
  systemDiskConfig?: [ 
    {
      diskCategory?: string(name='DiskCategory', description='实例系统盘类型。您可通过该参数指定多种候选磁盘类型，指定顺序作为各磁盘类型的优先级顺序，当某一种磁盘不可用时，自动更换磁盘类型。取值范围：

-   cloud_efficiency：高效云盘
-   cloud_ssd：SSD云盘
-   cloud_essd：ESSD云盘
-   cloud：普通云盘'),
    }
  ](name='SystemDiskConfig', position='Query'),
  dataDiskConfig?: [ 
    {
      diskCategory?: string(name='DiskCategory', description='实例数据盘类型。您可通过该参数指定多种候选磁盘类型，指定顺序作为各磁盘类型的优先级顺序，当某一种磁盘不可用时，自动更换磁盘类型。取值范围：

-   cloud_efficiency：高效云盘
-   cloud_ssd：SSD云盘
-   cloud_essd：ESSD云盘
-   cloud：普通云盘'),
    }
  ](name='DataDiskConfig', position='Query'),
  spotInstanceInterruptionBehavior?: string(name='SpotInstanceInterruptionBehavior', position='Query'),
  payAsYouGoTargetCapacity?: string(name='PayAsYouGoTargetCapacity', description='The target capacity of pay-as-you-go instances in the auto provisioning group. Value range: parameter value less than "TotalTargetCapacity"', position='Query'),
  regionId?: string(name='RegionId', description='The ID of the region where the auto provisioning Group is located. You can call [DescribeRegions](~~ 25609 ~~) to view the latest region list of Alibaba Cloud.', position='Query'),
  validFrom?: string(name='ValidFrom', description='The start time of the auto provisioning group and the "ValidUntil" determine the validity period.

The time follows the [ISO8601](~~ 25696 ~~) standard and uses UTC +0. The format is yyyy-MM-ddTHH:mm:ssZ.

Default value: takes effect immediately', position='Query'),
  terminateInstancesWithExpiration?: boolean(name='TerminateInstancesWithExpiration', description='Specifies whether to release instances in the auto provisioning group upon expiration. Valid values:

-true: Releases instances in the group.
-false: only instances in the group are removed from the auto provisioning group.

Default value: false', position='Query'),
  autoProvisioningGroupName?: string(name='AutoProvisioningGroupName', description='The name of the auto provisioning group. The description must be 2 to 128 characters in length. It must start with a letter and cannot start with http:// or https. It can contain numbers, colons (:), underscores (_), and hyphens (-).', position='Query'),
  description?: string(name='Description', description='The description of the auto provisioning group.', position='Query'),
  spotInstancePoolsToUseCount?: int32(name='SpotInstancePoolsToUseCount', description='This parameter takes effect when "SpotAllocationStrategy" is set to "lowest-price", indicating that the auto provisioning group selects the instance type with the lowest price to create the number of instances.

Valid values: less than N in launchtemplateconfig.', position='Query'),
  launchTemplateId?: string(name='LaunchTemplateId', description='The ID of the instance launch template associated with the auto provisioning group. You can call [DescribeLaunchTemplates](~~ 73759 ~~) to query available instance launch templates. When both the launch template and the launch configuration ("LaunchConfiguration.* ") are specified, the launch template is preferentially used.', position='Query'),
  spotTargetCapacity?: string(name='SpotTargetCapacity', description='The target capacity of preemptible instances in the auto provisioning group. Value range: parameter value less than "TotalTargetCapacity"', position='Query'),
  launchTemplateVersion?: string(name='LaunchTemplateVersion', description='The version of the instance launch template associated with the auto provisioning group. You can call [DescribeLaunchTemplateVersions](~~ 73761 ~~) to query the available instance launch template versions.

Default value: the default version of the launch template.', position='Query'),
  maxSpotPrice?: float(name='MaxSpotPrice', description='The highest price for preemptible instances in the auto provisioning group.

> When "MaxSpotPrice" and "LaunchTemplateConfig.N.MaxPrice" are set at the same time, the minimum value is used.', position='Query'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group to which the auto provisioning group belongs.', position='Query'),
  excessCapacityTerminationPolicy?: string(name='ExcessCapacityTerminationPolicy', description='Whether to release the scale-in instance when the real-time capacity of the auto provisioning group exceeds the target capacity and the scale-in is triggered. Valid values:

-termination: releases the scaled-In instance.
-no-termination: only the scaled-in instances are removed from the auto provisioning group.

Default value: no-termination', position='Query'),
  terminateInstances?: boolean(name='TerminateInstances', description='Specifies whether to release instances in an auto provisioning group. Valid values:

-true: Releases instances in the group.
-false: the instances in the group are retained.

Default value: false', position='Query'),
  defaultTargetCapacityType?: string(name='DefaultTargetCapacityType', description='If the sum of "PayAsYouGoTargetCapacity" and "SpotTargetCapacity" is smaller than "TotalTargetCapacity", the billing method of the difference capacity is specified. Valid values:

-PayAsYouGo: pay-as-you-go instance
-Spot: preemptible instance

Default value: Spot', position='Query'),
  spotAllocationStrategy?: string(name='SpotAllocationStrategy', description='The policy used to create preemptible instances. Valid values:

-lowest-price: the cost optimization policy. Select the instance type with the lowest price.

-diversified: the distribution strategy of the balanced zone. Create instances in the zones specified by the extended launch template and distribute them evenly to each zone.

-capacity-optimized: the capacity optimization distribution policy. Select the optimal instance type and zone based on the inventory.

Default value: lowest-price', position='Query'),
  clientToken?: string(name='ClientToken', description='Ensure the idempotence of the request. Generate a parameter value from your client. Make sure that the value is unique among different requests. The ClientToken can contain only ASCII characters and cannot exceed 64 characters. For more information, see [how to ensure idempotence](~~ 25693 ~~).', position='Query'),
  validUntil?: string(name='ValidUntil', description='The expiration time of the auto provisioning group. The validity period is determined together with "ValidFrom.

The time follows the [ISO8601](~~ 25696 ~~) standard and uses UTC +0. The format is yyyy-MM-ddTHH:mm:ssZ.

Default value: 2099-12-31 T23:59:59Z', position='Query'),
  autoProvisioningGroupType?: string(name='AutoProvisioningGroupType', description='The delivery type of the auto provisioning group. Valid values:

-request: one-time asynchronous delivery. The provisioning group delivers the instance cluster asynchronously only at startup and does not retry after scheduling fails.

-instant: one-time synchronous delivery. The provisioning group creates instances synchronously only at startup, and returns the list of successfully created instances and the cause of creation failure in the request response.

-maintain: continuous supply. The provisioning group attempts to deliver the instance cluster at startup and monitors the real-time capacity. If the target capacity is not reached, it attempts to continue creating ECS instances.

Default value: maintain', position='Query'),
  payAsYouGoAllocationStrategy?: string(name='PayAsYouGoAllocationStrategy', description='Create quantity pay instance strategy. Valid values:

-lowest-price: the cost optimization policy. Select the instance type with the lowest price.

-prioritized: the priority policy. Create an instance based on the priority set by "LaunchTemplateConfig.N.Priority.

Default value: lowest-price', position='Query'),
  minTargetCapacity?: string(name='MinTargetCapacity', description='The minimum capacity of the auto provisioning group. Valid values: positive integer.

After you set this parameter, note that:
-This parameter takes effect only when you create an auto provisioning Group of the one-time synchronous delivery type ("AutoProvisioningGroupType = instant").
-If the instance inventory in the current region is less than the value of this parameter, the API call fails and no instance is created.
-If the instance inventory in the current region is greater than this parameter value, the instance is created based on other parameter values that have been set.', position='Query'),
  totalTargetCapacity?: string(name='TotalTargetCapacity', description='The total capacity of the auto provisioning group. Value range: positive integer

The total capacity must be greater than or equal to the sum of the values of "PayAsYouGoTargetCapacity" and "SpotTargetCapacity.', position='Query'),
}

model CreateAutoProvisioningGroupResponseBody = {
  autoProvisioningGroupId?: string(name='AutoProvisioningGroupId', description='The ID of the auto provisioning group.'),
  requestId?: string(name='RequestId', description='The ID of the request.'),
  launchResults?: {
    launchResult?: [ 
    {
      zoneId?: string(name='ZoneId', description='The ID of the zone to which the instance belongs.'),
      errorMsg?: string(name='ErrorMsg', description='The error message returned when the instance fails to be created.'),
      instanceType?: string(name='InstanceType', description='The instance type.'),
      errorCode?: string(name='ErrorCode', description='The error code returned when the instance fails to be created.'),
      spotStrategy?: string(name='SpotStrategy', description='Quantity instance preemption strategy. Possible values:
-NoSpot: a pay-as-you-go instance.
-SpotWithPriceLimit: sets the maximum price for preemptible instances.
-SpotAsPriceGo: The system automatically bids based on the actual market price.'),
      instanceIds?: {
        instanceId?: [ string ](name='InstanceId')
      }(name='InstanceIds'),
    }
  ](name='LaunchResult')
  }(name='LaunchResults', description='A collection of instances created by the auto provisioning group. This set value is returned only when the delivery type of the auto provisioning Group is one-time synchronous delivery ("instant").'),
}

model CreateAutoProvisioningGroupResponse = {
  headers: map[string]string(name='headers'),
  body: CreateAutoProvisioningGroupResponseBody(name='body'),
}

/**
 * ## API description

-Auto provisioning is a solution that uses preemptible instances and pay-as-you-go instances to quickly deploy instance clusters. It supports one-click deployment of instance clusters across billing methods, zones, and instance type families. For more information, see [create multiple ECS instances by using auto provisioning group APIs](~~ 200772 ~~).

-Auto provisioning uses the auto provisioning group as the carrier to schedule and maintain computing resources. You can use auto provisioning groups to stably provide computing power and mitigate the instability caused by the recovery mechanism of preemptible instances.

-Auto provisioning is free of charge, but you need to pay for the instance resources created from the auto provisioning group. For more information, see [preemptible instance billing](~~ 52088 ~~) and [pay-as-you-go](~~ 40653 ~~).

-If you specify both the launch template ("LaunchTemplateId") and the launch configuration ("LaunchConfiguration.* "), the system preferentially uses the launch template.
 */
async function createAutoProvisioningGroup(request: CreateAutoProvisioningGroupRequest): CreateAutoProvisioningGroupResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateAutoProvisioningGroup', 'POST', 'undefined', 'json', false, 'none', request);
}

model DescribeRouteTablesRequest {
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  VRouterId?: string(name='VRouterId', position='Query'),
  routeTableId?: string(name='RouteTableId', position='Query'),
  routerType?: string(name='RouterType', position='Query'),
  routerId?: string(name='RouterId', position='Query'),
  routeTableName?: string(name='RouteTableName', position='Query'),
  pageNumber?: int32(name='PageNumber', position='Query'),
  pageSize?: int32(name='PageSize', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
}

model DescribeRouteTablesResponseBody = {
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  pageNumber?: int32(name='PageNumber'),
  totalCount?: int32(name='TotalCount'),
  routeTables?: {
    routeTable?: [ 
    {
      creationTime?: string(name='CreationTime'),
      VRouterId?: string(name='VRouterId'),
      routeTableId?: string(name='RouteTableId'),
      resourceGroupId?: string(name='ResourceGroupId'),
      routeTableType?: string(name='RouteTableType'),
      routeEntrys?: {
        routeEntry?: [ 
        {
          type?: string(name='Type'),
          status?: string(name='Status'),
          nextHopType?: string(name='NextHopType'),
          destinationCidrBlock?: string(name='DestinationCidrBlock'),
          instanceId?: string(name='InstanceId'),
          routeTableId?: string(name='RouteTableId'),
          nextHops?: {
            nextHop?: [ 
            {
              weight?: int32(name='Weight'),
              nextHopId?: string(name='NextHopId'),
              nextHopType?: string(name='NextHopType'),
              enabled?: int32(name='Enabled'),
            }
          ](name='NextHop')
          }(name='NextHops'),
        }
      ](name='RouteEntry')
      }(name='RouteEntrys'),
    }
  ](name='RouteTable')
  }(name='RouteTables'),
}

model DescribeRouteTablesResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeRouteTablesResponseBody(name='body'),
}

async function describeRouteTables(request: DescribeRouteTablesRequest): DescribeRouteTablesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeRouteTables', 'POST', 'undefined', 'json', false, 'none', request);
}

model ReleaseCapacityReservationRequest {
  privatePoolOptions?: {
    id?: string(name='Id', description='The ID of the subscription service.', position=''),
  }(name='PrivatePoolOptions'),
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  regionId?: string(name='RegionId', description='The ID of the region to which the capacity reservation service belongs. You can call [DescribeRegions](~~ 25609 ~~) to view the latest region list.', position='Query'),
  dryRun?: boolean(name='DryRun', description='Indicates whether to retrieve the request. Set the value to false. Currently, you can only release the capacity reservation service without retrieving this request.', position='Query'),
}

model ReleaseCapacityReservationResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.'),
}

model ReleaseCapacityReservationResponse = {
  headers: map[string]string(name='headers'),
  body: ReleaseCapacityReservationResponseBody(name='body'),
}

/**
 * ## API description

The capacity reservation service that takes effect immediately. If the release method is manual release, you can call this operation to release the capacity reservation service directly.
 */
async function releaseCapacityReservation(request: ReleaseCapacityReservationRequest): ReleaseCapacityReservationResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ReleaseCapacityReservation', 'POST', 'undefined', 'json', false, 'none', request);
}

model DescribeUserDataRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  instanceId?: string(name='InstanceId', description='The ID of the instance to be queried.', position='Query'),
  regionId?: string(name='RegionId', description='The ID of the region to which the instance belongs. You can call [DescribeRegions](~~ 25609 ~~) to view the latest region list.', position='Query'),
  ownerId?: long(name='OwnerId', description='The ID of the RAM user.', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='The account name of the resource master account.', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', description='The ID of the resource master account, that is, the UID.', position='Query'),
}

model DescribeUserDataResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.'),
  instanceId?: string(name='InstanceId', description='The ID of the instance.'),
  userData?: string(name='UserData', description='The user data of the instance.'),
  regionId?: string(name='RegionId', description='The ID of the region.'),
}

model DescribeUserDataResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeUserDataResponseBody(name='body'),
}

/**
 * ## API description

-The Returned instance custom data is displayed in Base64.

-If the instance does not have custom data, a null value is returned.
 */
async function describeUserData(request: DescribeUserDataRequest): DescribeUserDataResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeUserData', 'POST', 'undefined', 'json', false, 'none', request);
}

model JoinResourceGroupRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', description='The ID of the resource master account, that is, the UID.', position='Query'),
  regionId?: string(name='RegionId', description='The region ID of the resource. You can call [DescribeRegions](~~ 25609 ~~) to view the latest region list.', position='Query'),
  ownerId?: long(name='OwnerId', description='The ID of the RAM user.', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='The account name of the resource master account.', position='Query'),
  resourceId?: string(name='ResourceId', description='The ID of the resource type. For example, if ResourceType = instance, ResourceId can be considered as InstanceId.', position='Query'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the target Resource Group.', position='Query'),
  resourceType?: string(name='ResourceType', description='The type of the ECS resource. Valid values:

-instance: instance
-disk: block storage
-snapshot: snapshot
-image: image
-securitygroup: Security Group
-ddh: Dedicated host
-eni: eni
-keypair: key pair
-launchtemplate: launch Template

The preceding parameter values are case sensitive.', position='Query'),
}

model JoinResourceGroupResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.'),
}

model JoinResourceGroupResponse = {
  headers: map[string]string(name='headers'),
  body: JoinResourceGroupResponseBody(name='body'),
}

/**
 * ## API description

A resource is a cloud service entity that you create in Alibaba Cloud. For example, an ECS instance, an ECS Eni, or an ECS image can be resources. A resource group is a collection of infrastructure for projects, environments, or Stacks. You can manage resources in a resource group to monitor and perform tasks in a centralized manner. This eliminates the burden of repeatedly viewing multiple Alibaba cloud services.
 */
async function joinResourceGroup(request: JoinResourceGroupRequest): JoinResourceGroupResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'JoinResourceGroup', 'POST', 'undefined', 'json', false, 'none', request);
}

model DeleteSnapshotGroupRequest {
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  regionId?: string(name='RegionId', description='The ID of the region to which the instance snapshot belongs. You can call [DescribeRegions](~~ 25609 ~~) to view the latest region list.', position='Query'),
  snapshotGroupId?: string(name='SnapshotGroupId', description='The ID of the instance snapshot.', position='Query'),
}

model DeleteSnapshotGroupResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.'),
  operationProgressSet?: {
    operationProgress?: [ 
    {
      errorMsg?: string(name='ErrorMsg', description='The error message. If the deletion succeeds, a null value is returned.

<props = "intl"> for error codes and error messages, see [error Center](https://error-center.alibabacloud.com/status/product/Ecs). </props>

<props = "china"> for error codes and error messages, see [error Center](https://error-center.aliyun.com/status/product/Ecs). </props>'),
      errorCode?: string(name='ErrorCode', description='The error code. If the deletion succeeds, a null value is returned.

<props = "intl"> for error codes and error messages, see [error Center](https://error-center.alibabacloud.com/status/product/Ecs). </props>

<props = "china"> for error codes and error messages, see [error Center](https://error-center.aliyun.com/status/product/Ecs). </props>'),
      operationStatus?: string(name='OperationStatus', description='Indicates whether the operation is successful. Success is returned if the request succeeds. ErrorCode and ErrorMsg are returned if the request fails.'),
      relatedItemSet?: {
        relatedItem?: [ 
        {
          name?: string(name='Name', description='The name of the resource.'),
          value?: string(name='Value', description='The ID of the resource.'),
        }
      ](name='RelatedItem')
      }(name='RelatedItemSet', description='The resource information.'),
    }
  ](name='OperationProgress')
  }(name='OperationProgressSet', description='A collection of Operation status information when you delete an instance snapshot.'),
}

model DeleteSnapshotGroupResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteSnapshotGroupResponseBody(name='body'),
}

/**
 * ## API description

If the disk snapshot in the instance snapshot has been used to create a custom image, the relevant disk snapshots will not be deleted when the instance snapshot is deleted. If you want to delete a disk snapshot, delete the created custom image ([DeleteImage](~~ 25537 ~~), delete the disk snapshot ([DeleteSnapshot](~~ 25525 ~~)).

 */
async function deleteSnapshotGroup(request: DeleteSnapshotGroupRequest): DeleteSnapshotGroupResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteSnapshotGroup', 'POST', 'undefined', 'json', false, 'none', request);
}

model DescribeDedicatedHostClustersRequest {
  tag?: [ 
    {
      key?: string(name='Key', description='专有宿主机集群的标签键。N的取值范围：1~20。一旦传入该值，则不允许为空字符串。最多支持64个字符，不能以`aliyun`和`acs:`开头，不能包含`http://`或`https://`。

使用一个标签过滤资源，查询到该标签下的资源数量不能超过1000个；使用多个标签过滤资源，查询到同时绑定了多个标签的资源数量不能超过1000个。如果资源数量超过1000个，请使用[ListTagResources](~~110425~~)接口进行查询。'),
      value?: string(name='Value', description='专有宿主机集群的标签值。N的取值范围：1~20。一旦传入该值，则不允许为空字符串。最多支持64个字符，不能以`aliyun`和`acs:`开头，不能包含`http://`或`https://`。'),
    }
  ](name='Tag', position='Query'),
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  status?: string(name='Status', position='Query'),
  lockReason?: string(name='LockReason', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  regionId?: string(name='RegionId', description='The region ID of the DDH cluster. You can call [DescribeRegions](~~ 25609 ~~) to view the latest region list.', position='Query'),
  zoneId?: string(name='ZoneId', description='The ID of the zone where the dedicated host cluster is located. You can call [DescribeZones](~~ 25610 ~~) to view the zones in the Alibaba Cloud region.', position='Query'),
  dedicatedHostClusterName?: string(name='DedicatedHostClusterName', description='The name of the DDH cluster.', position='Query'),
  dedicatedHostClusterIds?: string(name='DedicatedHostClusterIds', description='The ID of the DDH cluster. Values can be by multiple proprietary host cluster ID composition a JSON Array, format is "[" dc-xxxxxxxxx ", "dc-yyyyyyyyy ",... "dc-zzzzzzzzz"]". You can specify a maximum of 100 IDs. Separate multiple IDs with commas (,).', position='Query'),
  pageSize?: int32(name='PageSize', description='The number of entries to return on each page.

Maximum Value: 100

Default value: 10', position='Query'),
  pageNumber?: int32(name='PageNumber', description='The page number of the DDH cluster status list.

Start value: 1

Default value: 1.', position='Query'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group to which the DDH cluster belongs. When you use this parameter to filter resources, the number of resources cannot exceed 1,000.', position='Query'),
}

model DescribeDedicatedHostClustersResponseBody = {
  pageSize?: int32(name='PageSize', description='The number of entries to return on each page.'),
  requestId?: string(name='RequestId', description='The ID of the request.'),
  pageNumber?: int32(name='PageNumber', description='The page number of the DDH cluster status list.'),
  totalCount?: int32(name='TotalCount', description='The total number of dedicated hosts.'),
  dedicatedHostClusters?: {
    dedicatedHostCluster?: [ 
    {
      description?: string(name='Description', description='The description of the DDH cluster.'),
      dedicatedHostClusterId?: string(name='DedicatedHostClusterId', description='The ID of the DDH cluster.'),
      resourceGroupId?: string(name='ResourceGroupId', description='The ID of the Resource Group of the DDH cluster.'),
      zoneId?: string(name='ZoneId', description='The ID of the zone where the dedicated host cluster is located.'),
      regionId?: string(name='RegionId', description='The region ID of the DDH cluster.'),
      dedicatedHostClusterName?: string(name='DedicatedHostClusterName', description='The name of the DDH cluster.'),
      tags?: {
        tag?: [ 
        {
          tagValue?: string(name='TagValue', description='The tag value of the DDH cluster.'),
          tagKey?: string(name='TagKey', description='The tag key of the DDH cluster.'),
        }
      ](name='Tag')
      }(name='Tags', description='The tag of the DDH cluster.'),
      dedicatedHostIds?: {
        dedicatedHostId?: [ string ](name='DedicatedHostId')
      }(name='DedicatedHostIds'),
      dedicatedHostClusterCapacity?: {
        availableVcpus?: int32(name='AvailableVcpus', description='The number of available vCPU.'),
        availableMemory?: int32(name='AvailableMemory', description='The amount of available memory. Unit: GiB'),
        totalMemory?: int32(name='TotalMemory', description='The total memory size. Unit: GiB'),
        totalVcpus?: int32(name='TotalVcpus', description='The total number of VCPUs.'),
        localStorageCapacities?: {
          localStorageCapacity?: [ 
          {
            dataDiskCategory?: string(name='DataDiskCategory', description='The data disk type. Possible values:
-cloud: basic cloud disk
-cloud_efficiency: Ultra disk
-cloud_ssd:SSD cloud disk
-ephemeral_ssd: local SSD
-cloud_essd:ESSD'),
            availableDisk?: int32(name='AvailableDisk', description='The size of the available local disk. Unit: GiB'),
            totalDisk?: int32(name='TotalDisk', description='The total size of the local disk. Unit: GiB'),
          }
        ](name='LocalStorageCapacity')
        }(name='LocalStorageCapacities', description='The local storage capacity.'),
      }(name='DedicatedHostClusterCapacity', description='The capacity of the dedicated host cluster.'),
    }
  ](name='DedicatedHostCluster')
  }(name='DedicatedHostClusters', description='An array of the statuses of one or more DDH clusters.'),
}

model DescribeDedicatedHostClustersResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeDedicatedHostClustersResponseBody(name='body'),
}

/**
 * ## API description

Request parameters are similar to a filter. The filter is a logical AND (AND) relationship. If a parameter is empty, the filter does not work. However, if the value of the "DedicatedHostClusterIds" parameter is an empty JSON Array, that is, "[]", the filter is considered valid and the return value is empty.
 */
async function describeDedicatedHostClusters(request: DescribeDedicatedHostClustersRequest): DescribeDedicatedHostClustersResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeDedicatedHostClusters', 'POST', 'undefined', 'json', false, 'none', request);
}

model DescribeKeyPairsRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  tag?: [ 
    {
      key?: string(name='Key', description='密钥对的标签键。N的取值范围：1~20

使用一个标签过滤资源，查询到该标签下的资源数量不能超过1000个；使用多个标签过滤资源，查询到同时绑定了多个标签的资源数量不能超过1000个。如果资源数量超过1000个，请使用[ListTagResources](~~110425~~)接口进行查询。'),
      value?: string(name='Value', description='密钥对的标签值。N的取值范围：1~20'),
    }
  ](name='Tag', position='Query'),
  ownerId?: long(name='OwnerId', description='The ID of the RAM user.', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', description='The ID of the resource master account, that is, the UID.', position='Query'),
  regionId?: string(name='RegionId', description='The region ID of the key pair. You can call [DescribeRegions](~~ 25609 ~~) to view the latest region list.', position='Query'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group to which the key pair belongs. When you use this parameter to filter resources, the number of resources cannot exceed 1,000.', position='Query'),
  pageNumber?: int32(name='PageNumber', description='The page number of the key pair list. Start value: 1

Default value: 1.', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='The account name of the resource master account.', position='Query'),
  pageSize?: int32(name='PageSize', description='The number of entries to return on each page. Maximum Value: 50

Default value: 10', position='Query'),
  keyPairFingerPrint?: string(name='KeyPairFingerPrint', description='The fingerprint of the key pair. According to the public key fingerprint format defined in RFC4716, MD5 Information Digest Algorithm is adopted. For more information, see [RFC4716](https://tools.ietf.org/html/rfc4716).', position='Query'),
  keyPairName?: string(name='KeyPairName', description='The name of the key pair. Fuzzy search of regular expressions is supported. Use * to match subexpressions. Example:

-"* SshKey": queries the key pair names that end with SshKey, including SshKey.
-Speechshkey * ": queries the names of key pairs that start with SshKey, including SshKey.
-"* SshKey *": the key pair with SshKey in the middle of the query name, including SshKey.
-Speechshkey": exactly matches the SshKey.', position='Query'),
}

model DescribeKeyPairsResponseBody = {
  pageSize?: int32(name='PageSize', description='The number of rows per page.'),
  requestId?: string(name='RequestId', description='The ID of the request.'),
  pageNumber?: int32(name='PageNumber', description='The current page number.'),
  totalCount?: int32(name='TotalCount', description='The total number of key pairs.'),
  keyPairs?: {
    keyPair?: [ 
    {
      creationTime?: string(name='CreationTime', description='The time when the key pair was created.'),
      keyPairName?: string(name='KeyPairName', description='The name of the key pair.'),
      keyPairFingerPrint?: string(name='KeyPairFingerPrint', description='The fingerprint of the key pair.'),
      resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group.'),
      tags?: {
        tag?: [ 
        {
          tagValue?: string(name='TagValue', description='The tag value of the key pair.'),
          tagKey?: string(name='TagKey', description='The tag key of the key pair.'),
        }
      ](name='Tag')
      }(name='Tags', description='The tag of the key pair.'),
    }
  ](name='KeyPair')
  }(name='KeyPairs', description='The collection of key pair information.'),
}

model DescribeKeyPairsResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeKeyPairsResponseBody(name='body'),
}

async function describeKeyPairs(request: DescribeKeyPairsRequest): DescribeKeyPairsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeKeyPairs', 'POST', 'undefined', 'json', false, 'none', request);
}

model DescribeStorageSetDetailsRequest {
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  clientToken?: string(name='ClientToken', description='Ensure the idempotence of the request. Generate a parameter value from your client. Make sure that the value is unique among different requests. **ClientToken** supports only ASCII characters and cannot exceed 64 characters. For more information, see [how to ensure idempotence](~~ 25693 ~~).', position='Query'),
  regionId?: string(name='RegionId', description='The region to which the bucket belongs. You can call [DescribeRegions](~~ 25609 ~~) to view the latest region list.', position='Query'),
  storageSetPartitionNumber?: int32(name='StorageSetPartitionNumber', description='The maximum number of partitions in a storage set.', position='Query'),
  pageNumber?: int32(name='PageNumber', description='The page number of the bucket list.

Start value: 1

Default value: 1.', position='Query'),
  storageSetId?: string(name='StorageSetId', description='The ID of the storage set.', position='Query'),
  diskIds?: string(name='DiskIds', description='The ID of the cloud disk or shared block storage. The value can be a JSON Array consisting of multiple cloud disks or shared block storage IDs. A maximum of 100 IDs can be entered. Separate IDs with commas (,).', position='Query'),
  pageSize?: int32(name='PageSize', description='The number of entries to return on each page.

Maximum Value: 100

Default value: 10', position='Query'),
}

model DescribeStorageSetDetailsResponseBody = {
  pageSize?: int32(name='PageSize', description='The number of entries returned per page.'),
  requestId?: string(name='RequestId', description='The ID of the request.'),
  pageNumber?: int32(name='PageNumber', description='The number of pages in the bucket list.'),
  totalCount?: int32(name='TotalCount', description='The total number of buckets.'),
  disks?: {
    disk?: [ 
    {
      creationTime?: string(name='CreationTime', description='The time when the disk or shared block storage was created.'),
      diskName?: string(name='DiskName', description='The name of the cloud disk or shared block storage.'),
      zoneId?: string(name='ZoneId', description='The zone to which the cloud disk or shared block storage belongs.'),
      storageSetId?: string(name='StorageSetId', description='The ID of the storage set.'),
      diskId?: string(name='DiskId', description='The ID of the cloud disk or shared block storage.'),
      category?: string(name='Category', description='The type of cloud disk or shared block storage.'),
      storageSetPartitionNumber?: int32(name='StorageSetPartitionNumber', description='The number of partitions in the storage set.'),
      regionId?: string(name='RegionId', description='The region to which the cloud disk or shared block storage belongs.'),
    }
  ](name='Disk')
  }(name='Disks', description='A Disk array that returns the details of cloud disks or shared block storage in a storage set.'),
}

model DescribeStorageSetDetailsResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeStorageSetDetailsResponseBody(name='body'),
}

async function describeStorageSetDetails(request: DescribeStorageSetDetailsRequest): DescribeStorageSetDetailsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeStorageSetDetails', 'POST', 'undefined', 'json', false, 'none', request);
}

model AssignIpv6AddressesRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  regionId?: string(name='RegionId', position='Query'),
  networkInterfaceId?: string(name='NetworkInterfaceId', description='The ID of the Eni.', position='Query'),
  ipv6Address?: [ string ](name='Ipv6Address', description='Specify one or more IPv6 addresses for the Eni. You can set up to 10 IPv6 addresses. Valid values of N: 1 to 10.

Valid values: Ipv6Address.1=2001:db8:1234:1 a00::****

> When you call this operation, you must set either the "Ipv6Addresses. **parameter or the "Ipv6AddressCount" parameter, but you cannot set both parameters at the same time.', position='Query'),
  ipv6AddressCount?: int32(name='Ipv6AddressCount', description='Specify the number of randomly generated IPv6 addresses for the Eni. Valid values: 1 to 10.

> When you call this operation, you must set either the "Ipv6Addresses. **parameter or the "Ipv6AddressCount" parameter, but you cannot set both parameters at the same time.', position='Query'),
}

model AssignIpv6AddressesResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.'),
  networkInterfaceId?: string(name='NetworkInterfaceId', description='The ID of the Eni.'),
  ipv6Sets?: {
    ipv6Address?: [ string ](name='Ipv6Address')
  }(name='Ipv6Sets', description='The IPv6 address assigned to the Eni.'),
}

model AssignIpv6AddressesResponse = {
  headers: map[string]string(name='headers'),
  body: AssignIpv6AddressesResponseBody(name='body'),
}

/**
 * ## API description

You can specify the IPv6 addresses of the CIDR block of the vSwitch to which the Eni belongs, or specify the number of IPv6 addresses to automatically create IPv6 addresses. Note:

-The vSwitch to which the Eni belongs must have IPv6 enabled. For more information, see [enable IPv6 CIDR blocks for existing vswitches](~~ 98923 ~~).

-The Eni must be in the Available or InUse state.

-The ECS instance associated with the primary Eni must be in the Running (Running) or Stopped (Stopped) state.

-The number of IPv6 addresses that an Eni can assign depends on the instance type attached to the Eni.
-If the Eni is in the Available state, a maximum of 10 IPv6 addresses can be allocated.

-If an Eni is attached to an instance, the number of IPv6 addresses that can be allocated is limited by the instance type. For more information, see [instance type family](~~ 25378 ~~).

-After you call this operation, you can obtain the assigned IPv6 address information from the returned results.

 */
async function assignIpv6Addresses(request: AssignIpv6AddressesRequest): AssignIpv6AddressesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'AssignIpv6Addresses', 'POST', 'undefined', 'json', false, 'none', request);
}

model DescribeCloudAssistantStatusRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', description='The ID of the RAM user.', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='The account name of the resource master account.', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', description='The ID of the resource master account, that is, the UID.', position='Query'),
  OSType?: string(name='OSType', description='The operating system type of the instance. Valid values:

-Windows
-Linux', position='Query'),
  regionId?: string(name='RegionId', description='The region ID of the instance. You can call [DescribeRegions](~~ 25609 ~~) to view the latest region list.', position='Query'),
  pageNumber?: long(name='PageNumber', description='The current page number.

Start value: 1

Default value: 1.', position='Query'),
  pageSize?: long(name='PageSize', description='The number of entries to return on each page.

Maximum Value: 100

Default value: 10', position='Query'),
  instanceId?: [ string ](name='InstanceId', description='The list of instance ids. A maximum of 100 instances can be requested at a time. Valid values of N: 1 to 100.', position='Query'),
}

model DescribeCloudAssistantStatusResponseBody = {
  pageSize?: long(name='PageSize', description='The number of rows per page.'),
  requestId?: string(name='RequestId', description='The ID of the request.'),
  pageNumber?: long(name='PageNumber', description='The current page number.'),
  totalCount?: long(name='TotalCount', description='The total number of instances.'),
  instanceCloudAssistantStatusSet?: {
    instanceCloudAssistantStatus?: [ 
    {
      cloudAssistantStatus?: string(name='CloudAssistantStatus', description='Indicates whether cloud assistant is installed.'),
      lastInvokedTime?: string(name='LastInvokedTime', description='The time when the last command was run.'),
      cloudAssistantVersion?: string(name='CloudAssistantVersion', description='The version number of the cloud assistant client.'),
      activeTaskCount?: long(name='ActiveTaskCount', description='The number of commands that are being executed.'),
      invocationCount?: long(name='InvocationCount', description='The total number of executed commands.'),
      instanceId?: string(name='InstanceId', description='The ID of the instance.'),
      lastHeartbeatTime?: string(name='LastHeartbeatTime', description='The last heartbeat time of cloud assistant.'),
      OSType?: string(name='OSType', description='The operating system type of the instance. Possible values:

-Windows
-Linux'),
    }
  ](name='InstanceCloudAssistantStatus')
  }(name='InstanceCloudAssistantStatusSet', description='The collection of installation status results of the instance cloud assistant.'),
}

model DescribeCloudAssistantStatusResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeCloudAssistantStatusResponseBody(name='body'),
}

async function describeCloudAssistantStatus(request: DescribeCloudAssistantStatusRequest): DescribeCloudAssistantStatusResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeCloudAssistantStatus', 'POST', 'undefined', 'json', false, 'none', request);
}

model UnassignIpv6AddressesRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='The account name of the resource master account.', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', description='The ID of the resource master account, that is, the UID.', position='Query'),
  regionId?: string(name='RegionId', description='The ID of the region to which the Eni belongs. You can call [DescribeRegions](~~ 25609 ~~) to view the latest region list.', position='Query'),
  ownerId?: long(name='OwnerId', description='The ID of the RAM user.', position='Query'),
  networkInterfaceId?: string(name='NetworkInterfaceId', description='The ID of the Eni.', position='Query'),
  ipv6Address?: [ string ](name='Ipv6Address', description='Specify one or more IPv6 addresses for the Eni. Valid values of N: 1.', position='Query'),
}

model UnassignIpv6AddressesResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.'),
}

model UnassignIpv6AddressesResponse = {
  headers: map[string]string(name='headers'),
  body: UnassignIpv6AddressesResponseBody(name='body'),
}

/**
 * ## API description

When you call this operation, note that:

-The Eni must be in the **Available**(Available) or **attached**(InUse) status.

-The ECS instance associated with the primary Eni must be in the **Running**(Running) or **Stopped**(Stopped) status.

 */
async function unassignIpv6Addresses(request: UnassignIpv6AddressesRequest): UnassignIpv6AddressesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UnassignIpv6Addresses', 'POST', 'undefined', 'json', false, 'none', request);
}

model AttachNetworkInterfaceRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  trunkNetworkInstanceId?: string(name='TrunkNetworkInstanceId', position='Query'),
  waitForNetworkConfigurationReady?: boolean(name='WaitForNetworkConfigurationReady', position='Query'),
  instanceId?: string(name='InstanceId', description='The ID of the instance.', position='Query'),
  networkInterfaceId?: string(name='NetworkInterfaceId', description='The ID of the Eni.', position='Query'),
}

model AttachNetworkInterfaceResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.'),
}

model AttachNetworkInterfaceResponse = {
  headers: map[string]string(name='headers'),
  body: AttachNetworkInterfaceResponseBody(name='body'),
}

/**
 * ## API description

Note the following when you call this operation:

-The Eni must be in the **Available**("Available") state. An Eni can only be attached to one instance at a time.

-The instance must be in the Running (Running) or Stopped (Stopped) state. Some instance types must be in the Stopped (Stopped) state when binding Enis. For more information, for more information, see the ECS instance types to be stopped in [bind an Eni](~~ 58503 ~~).

> If the instance was last started before April 1, 2018 (including but not limited to starting, restarting, and restarting a new instance), you must call the RebootInstance to restart the instance that remains running. Otherwise, you cannot attach an Eni.

-An instance can be attached with multiple Enis at the same time. For more information, see [Enis Overview](~~ 58496 ~~).

-The vSwitch of the instance and the Eni must belong to the same zone and VPC.


 */
async function attachNetworkInterface(request: AttachNetworkInterfaceRequest): AttachNetworkInterfaceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'AttachNetworkInterface', 'POST', 'undefined', 'json', false, 'none', request);
}

model DescribeSecurityGroupAttributeRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  securityGroupId?: string(name='SecurityGroupId', description='The ID of the security group.', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='The account name of the resource master account.', position='Query'),
  direction?: string(name='Direction', description='The authorization direction of the security group rule. Valid values:

-egress: the outbound direction of the security group.
-ingress: The inbound direction of the security group.
-all: do not distinguish directions

Default value: all', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', description='The ID of the resource master account, that is, the UID.', position='Query'),
  nicType?: string(name='NicType', description='The NIC type of the security group rule.

-Valid values of the classic network security group:
-internet (default): Public network
-intranet: intranet
> You can query only one security group rule of the NIC type in a single call. Query all types in two times.
-The value of a VPC-type security group can only be intranet (default), that is, intranet.
> If you specify an internet or a null value, it is converted to intranet by default.', position='Query'),
  regionId?: string(name='RegionId', description='The ID of the region to which the security group belongs. You can call [DescribeRegions](~~ 25609 ~~) to view the latest region list.', position='Query'),
  ownerId?: long(name='OwnerId', description='The ID of the RAM user.', position='Query'),
}

model DescribeSecurityGroupAttributeResponseBody = {
  vpcId?: string(name='VpcId', description='VPC ID. If VPC ID is returned, the network type of the security group is VPC. Otherwise, it indicates a classic network security group.'),
  requestId?: string(name='RequestId', description='The ID of the request.'),
  innerAccessPolicy?: string(name='InnerAccessPolicy', description='The network connection policy in the security group. Possible values:

-Accept: intranet interconnection
-Drop: internal network isolation'),
  description?: string(name='Description', description='The description of the security group.'),
  securityGroupId?: string(name='SecurityGroupId', description='The ID of the Target security group.'),
  securityGroupName?: string(name='SecurityGroupName', description='The name of the Target security group.'),
  regionId?: string(name='RegionId', description='The ID of the region.'),
  permissions?: {
    permission?: [ 
    {
      direction?: string(name='Direction', description='The authorization direction.'),
      sourceGroupId?: string(name='SourceGroupId', description='The source security group used for inbound authorization.'),
      destGroupOwnerAccount?: string(name='DestGroupOwnerAccount', description='The ID of the Alibaba Cloud account to which the destination security group belongs.'),
      destPrefixListId?: string(name='DestPrefixListId', description='The destination Prefix List ID, which is used for outbound authorization.'),
      destPrefixListName?: string(name='DestPrefixListName', description='The name of the destination Prefix List.'),
      sourceCidrIp?: string(name='SourceCidrIp', description='The source IP address segment used for inbound authorization.'),
      ipv6DestCidrIp?: string(name='Ipv6DestCidrIp', description='The Destination IPv6 CIDR block.'),
      createTime?: string(name='CreateTime', description='The creation time in UTC.'),
      ipv6SourceCidrIp?: string(name='Ipv6SourceCidrIp', description='The source IPv6 CIDR block.'),
      destGroupId?: string(name='DestGroupId', description='The destination security group used for outbound authorization.'),
      destCidrIp?: string(name='DestCidrIp', description='The destination IP address segment used for outbound authorization.'),
      ipProtocol?: string(name='IpProtocol', description='The IP protocol.'),
      priority?: string(name='Priority', description='The priority of the rule.'),
      destGroupName?: string(name='DestGroupName', description='The name of the destination security group.'),
      nicType?: string(name='NicType', description='The network type.'),
      policy?: string(name='Policy', description='The authorization policy.'),
      description?: string(name='Description', description='The description of the security group.'),
      portRange?: string(name='PortRange', description='The port range.'),
      sourcePrefixListName?: string(name='SourcePrefixListName', description='The name of the source prefix list.'),
      sourcePrefixListId?: string(name='SourcePrefixListId', description='The source Prefix List ID, which is used for inbound authorization.'),
      sourceGroupOwnerAccount?: string(name='SourceGroupOwnerAccount', description='The ID of the Alibaba Cloud account to which the source Security Group belongs.'),
      sourceGroupName?: string(name='SourceGroupName', description='The name of the source security group.'),
      sourcePortRange?: string(name='SourcePortRange', description='The range of source ports.'),
    }
  ](name='Permission')
  }(name='Permissions', description='The set of Security Group permission rules.'),
}

model DescribeSecurityGroupAttributeResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeSecurityGroupAttributeResponseBody(name='body'),
}

async function describeSecurityGroupAttribute(request: DescribeSecurityGroupAttributeRequest): DescribeSecurityGroupAttributeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeSecurityGroupAttribute', 'POST', 'undefined', 'json', false, 'none', request);
}

model DescribeAutoSnapshotPolicyExRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  tag?: [ 
    {
      key?: string(name='Key', description='快照的标签键。N的取值范围：1~20。一旦传入该值，则不允许为空字符串。最多支持128个字符，不能以aliyun和acs:开头，不能包含http://或者https://。'),
      value?: string(name='Value', description='快照的标签值。N的取值范围：1~20。一旦传入该值，可以为空字符串。最多支持128个字符，不能以acs:开头，不能包含http://或者https://。'),
    }
  ](name='Tag', position='Query'),
  pageNumber?: int32(name='PageNumber', description='The response of an automatic snapshot policy is displayed on multiple pages.

Start value: 1

Default value: 1.', position='Query'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group.', position='Query'),
  autoSnapshotPolicyId?: string(name='AutoSnapshotPolicyId', description='The ID of the automatic snapshot policy.', position='Query'),
  regionId?: string(name='RegionId', description='The ID of the region to which the automatic snapshot policy belongs. You can call [DescribeRegions](~~ 25609 ~~) to view the latest region list.', position='Query'),
  pageSize?: int32(name='PageSize', description='The number of rows per page for the returned automatic snapshot policy.

Maximum Value: 100

Default value: 10', position='Query'),
}

model DescribeAutoSnapshotPolicyExResponseBody = {
  pageSize?: int32(name='PageSize', description='The number of rows per page for the returned automatic snapshot policy.'),
  requestId?: string(name='RequestId', description='The ID of the request.'),
  pageNumber?: int32(name='PageNumber', description='The page number of the automatic snapshot policy list.'),
  totalCount?: int32(name='TotalCount', description='The total number of automatic snapshot policies.'),
  autoSnapshotPolicies?: {
    autoSnapshotPolicy?: [ 
    {
      timePoints?: string(name='TimePoints', description='The time when the automatic snapshot was created.

Use UTC +8. Unit: Hour. From 00:00~23:00 we found 24 time points optional, parameter is 0~23 Digital, such as: 1 dai table in 01:00 point in time. You can select multiple time points.

The passed parameters are in the JSON Array format: "["0", "1", "23"]", with a maximum of 24 time points, separated by commas (,).'),
      creationTime?: string(name='CreationTime', description='The creation time. The time follows the [ISO8601](~~ 25696 ~~) standard and uses UTC time. The format is yyyy-MM-ddTHH:mm:ssZ.'),
      status?: string(name='Status', description='The status of the automatic snapshot policy. Possible values:

-Normal: Normal.
-Expire: the policy cannot be used due to overdue payments.'),
      autoSnapshotPolicyName?: string(name='AutoSnapshotPolicyName', description='The name of the automatic snapshot policy.'),
      targetCopyRegions?: string(name='TargetCopyRegions', description='> This parameter is being invited for testing and is not currently available.'),
      copiedSnapshotsRetentionDays?: int32(name='CopiedSnapshotsRetentionDays', description='> This parameter is being invited for testing and is not currently available.'),
      autoSnapshotPolicyId?: string(name='AutoSnapshotPolicyId', description='The ID of the automatic snapshot policy.'),
      retentionDays?: int32(name='RetentionDays', description='The retention period of automatic snapshots. Unit: days. Possible values:

--1: permanently saved
-1 to 65536: specify the retention period.'),
      regionId?: string(name='RegionId', description='The ID of the region to which the automatic snapshot policy belongs.'),
      diskNums?: int32(name='DiskNums', description='The number of disks that have the policy enabled.'),
      enableCrossRegionCopy?: boolean(name='EnableCrossRegionCopy', description='> This parameter is being invited for testing and is not currently available.'),
      repeatWeekdays?: string(name='RepeatWeekdays', description='Specifies the repetition date of the automatic snapshot. Select the date on which you want to create a snapshot from Monday to Sunday. The value ranges from 1 to 7. For example, 1 indicates Monday. You can select multiple dates.'),
      volumeNums?: int32(name='VolumeNums', description='The number of extended volumes that have enabled the policy.'),
      resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group.'),
      tags?: {
        tag?: [ 
        {
          tagValue?: string(name='TagValue', description='The value of the snapshot tag.'),
          tagKey?: string(name='TagKey', description='The key of the snapshot tag.'),
        }
      ](name='Tag')
      }(name='Tags', description='The key-value set of the snapshot.'),
    }
  ](name='AutoSnapshotPolicy')
  }(name='AutoSnapshotPolicies', description='A collection of automatic snapshot policy details AutoSnapshotPolicy.'),
}

model DescribeAutoSnapshotPolicyExResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeAutoSnapshotPolicyExResponseBody(name='body'),
}

async function describeAutoSnapshotPolicyEx(request: DescribeAutoSnapshotPolicyExRequest): DescribeAutoSnapshotPolicyExResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeAutoSnapshotPolicyEx', 'POST', 'undefined', 'json', false, 'none', request);
}

model CancelCopyImageRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', description='The ID of the resource master account, that is, the UID.', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='The account name of the resource master account.', position='Query'),
  ownerId?: long(name='OwnerId', description='The ID of the RAM user.', position='Query'),
  imageId?: string(name='ImageId', description='The ID of the image being copied.', position='Query'),
  regionId?: string(name='RegionId', description='The ID of the region to which the target image belongs. You can call [DescribeRegions](~~ 25609 ~~) to view the latest region list.', position='Query'),
}

model CancelCopyImageResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.'),
}

model CancelCopyImageResponse = {
  headers: map[string]string(name='headers'),
  body: CancelCopyImageResponseBody(name='body'),
}

/**
 * ## API description

When you call this operation, note that:

-After you cancel the copy, the new image in the target region is automatically deleted and the source image remains unchanged.
-If the image is copied, the operation fails and an error message is returned.
 */
async function cancelCopyImage(request: CancelCopyImageRequest): CancelCopyImageResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CancelCopyImage', 'POST', 'undefined', 'json', false, 'none', request);
}

model DescribeImageSharePermissionRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', description='The ID of the resource master account, that is, the UID.', position='Query'),
  imageId?: string(name='ImageId', description='The ID of the custom image.', position='Query'),
  ownerId?: long(name='OwnerId', description='The ID of the RAM user.', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='The account name of the resource master account.', position='Query'),
  pageNumber?: int32(name='PageNumber', description='The page number of the query result. Start value: 1

Default value: 1.', position='Query'),
  regionId?: string(name='RegionId', description='The ID of the region to which the custom image belongs. You can call [DescribeRegions](~~ 25609 ~~) to view the latest region list.', position='Query'),
  pageSize?: int32(name='PageSize', description='The number of entries per page displayed in the query results. Maximum Value: 100

Default value: 10', position='Query'),
}

model DescribeImageSharePermissionResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.'),
  pageNumber?: int32(name='PageNumber', description='The page number of the query result.'),
  pageSize?: int32(name='PageSize', description='The number of entries per page.'),
  totalCount?: int32(name='TotalCount', description='The total number of records.'),
  imageId?: string(name='ImageId', description='The ID of the custom image.'),
  regionId?: string(name='RegionId', description='Mirror respective geographical ID.'),
  shareGroups?: {
    shareGroup?: [ 
    {
      group?: string(name='Group', description='A shared group.'),
    }
  ](name='ShareGroup')
  }(name='ShareGroups', description='A shared group.'),
  accounts?: {
    account?: [ 
    {
      aliyunId?: string(name='AliyunId', description='The ID of the Alibaba cloud account.'),
    }
  ](name='Account')
  }(name='Accounts', description='Registered users of Alibaba Cloud.'),
}

model DescribeImageSharePermissionResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeImageSharePermissionResponseBody(name='body'),
}

async function describeImageSharePermission(request: DescribeImageSharePermissionRequest): DescribeImageSharePermissionResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeImageSharePermission', 'POST', 'undefined', 'json', false, 'none', request);
}

model CreateDeploymentSetRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  domain?: string(name='Domain', position='Query'),
  granularity?: string(name='Granularity', position='Query'),
  groupCount?: long(name='GroupCount', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  strategy?: string(name='Strategy', description='The deployment policy. You can only set high-availability policies. Value: Availability', position='Query'),
  clientToken?: string(name='ClientToken', description='Ensure the idempotence of the request. Generate a parameter value from your client. Make sure that the value is unique among different requests. **ClientToken** supports only ASCII characters and cannot exceed 64 characters. For more information, see [how to ensure idempotence](~~ 25693 ~~).', position='Query'),
  regionId?: string(name='RegionId', description='The ID of the region to which the deployment set belongs. You can call [DescribeRegions](~~ 25609 ~~) to view the latest region list.', position='Query'),
  ownerId?: long(name='OwnerId', description='The ID of the RAM user.', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', description='The ID of the resource master account, that is, the UID.', position='Query'),
  description?: string(name='Description', description='The description of the deployment set. The description must be 2 to 256 characters in length and cannot start with http:// or https.', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='The account name of the resource master account.', position='Query'),
  onUnableToRedeployFailedInstance?: string(name='OnUnableToRedeployFailedInstance', description='After instances in the deployment set are down and migrated, there is no emergency solution to break up the instance inventory. Valid values:

-CancelMembershipAndStart (default): removes the instance from the deployment set and starts the instance immediately after the instance is down and migrated.
-KeepStopped: maintains the deployment set properties of the instance, and the instance remains stopped.', position='Query'),
  deploymentSetName?: string(name='DeploymentSetName', description='The name of the deployment set. The description must be 2 to 128 characters in length. It must start with a letter and cannot start with http:// or https. It can contain numbers, colons (:), underscores (_), and hyphens (-).', position='Query'),
}

model CreateDeploymentSetResponseBody = {
  deploymentSetId?: string(name='DeploymentSetId', description='The ID of the deployment set.'),
  requestId?: string(name='RequestId', description='The ID of the request.'),
}

model CreateDeploymentSetResponse = {
  headers: map[string]string(name='headers'),
  body: CreateDeploymentSetResponseBody(name='body'),
}

async function createDeploymentSet(request: CreateDeploymentSetRequest): CreateDeploymentSetResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateDeploymentSet', 'POST', 'undefined', 'json', false, 'none', request);
}

model DescribeRegionsRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', description='The ID of the RAM user.', position='Query'),
  resourceType?: string(name='ResourceType', description='The type of the resource. Valid values:
-instance:ECS instance
-disk: disk
-reservedinstance: Reserved Instance
-scu: storage capacity unit package

Default value: instance', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='The account name of the resource master account.', position='Query'),
  instanceChargeType?: string(name='InstanceChargeType', description='The billing method of the instance. For more information, see [billing Overview](~~ 25398 ~~). Valid values:

-PrePaid: subscription. At this point, you must ensure that your account supports balance payment or credit payment. Otherwise, an error InvalidPayMethod is reported.
-PostPaid: pay-as-you-go.

Default value: PostPaid', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', description='The ID of the resource master account, that is, the UID.', position='Query'),
  acceptLanguage?: string(name='AcceptLanguage', description='The returned results are filtered based on Chinese, English, and Japanese. For more information, see [RFC7231](https://tools.ietf.org/html/rfc7231). Valid values:

-zh-CN: Chinese
-en-US: English
-ja: Japanese

Default value: zh-CN', position='Query'),
}

model DescribeRegionsResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.'),
  regions?: {
    region?: [ 
    {
      status?: string(name='Status', description='Indicates whether the cluster is sold out. Possible values:

-available
-soldOut'),
      regionEndpoint?: string(name='RegionEndpoint', description='The Endpoint of the region.'),
      localName?: string(name='LocalName', description='The region name.'),
      regionId?: string(name='RegionId', description='The ID of the region.'),
    }
  ](name='Region')
  }(name='Regions', description='The set of region information.'),
}

model DescribeRegionsResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeRegionsResponseBody(name='body'),
}

/**
 * * * * *
 */
async function describeRegions(request: DescribeRegionsRequest): DescribeRegionsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeRegions', 'POST', 'undefined', 'json', false, 'none', request);
}

model DescribeClassicLinkInstancesRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  ownerId?: long(name='OwnerId', description='The ID of the RAM user.', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='The account name of the resource master account.', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', description='The ID of the resource master account, that is, the UID.', position='Query'),
  vpcId?: string(name='VpcId', description='VPC ID. The ClassicLink feature must be enabled for the target VPC. For more information, see [establish a ClassicLink connection](~~ 65413 ~~).', position='Query'),
  regionId?: string(name='RegionId', description='The ID of the region to which the instance belongs. You can call [DescribeRegions](~~ 25609 ~~) to view the latest region list.', position='Query'),
  instanceId?: string(name='InstanceId', description='The ID of the instance. You can specify a maximum of 100 instance IDs and separate them with commas (,).', position='Query'),
  pageSize?: string(name='PageSize', description='The number of entries to return on each page. Valid values: 1 to 100.

Default value: 10', position='Query'),
  pageNumber?: string(name='PageNumber', description='The current page number. Start value: 1

Default value: 1.', position='Query'),
}

model DescribeClassicLinkInstancesResponseBody = {
  pageSize?: int32(name='PageSize', description='The number of entries to return on each page.'),
  requestId?: string(name='RequestId', description='The ID of the request.'),
  pageNumber?: int32(name='PageNumber', description='The number of the page to return.'),
  totalCount?: int32(name='TotalCount', description='The total number of connections.'),
  links?: {
    link?: [ 
    {
      vpcId?: string(name='VpcId', description='VPC ID.'),
      instanceId?: string(name='InstanceId', description='The ID of the instance.'),
    }
  ](name='Link')
  }(name='Links', description='Returns the connection information of a classic network instance and a VPC.'),
}

model DescribeClassicLinkInstancesResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeClassicLinkInstancesResponseBody(name='body'),
}

/**
 * ## API description

When you call this operation, note that:

-This operation only supports classic network instances.

-A maximum of 100 classic network instances can be queried at a time.

-The "VpcId" and "InstanceId" parameters must be specified.
 */
async function describeClassicLinkInstances(request: DescribeClassicLinkInstancesRequest): DescribeClassicLinkInstancesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeClassicLinkInstances', 'POST', 'undefined', 'json', false, 'none', request);
}

model DescribeAutoSnapshotPolicyRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
}

model DescribeAutoSnapshotPolicyResponseBody = {
  autoSnapshotOccupation?: int32(name='AutoSnapshotOccupation'),
  requestId?: string(name='RequestId'),
  autoSnapshotPolicy?: {
    systemDiskPolicyRetentionDays?: string(name='SystemDiskPolicyRetentionDays'),
    dataDiskPolicyRetentionLastWeek?: string(name='DataDiskPolicyRetentionLastWeek'),
    dataDiskPolicyRetentionDays?: string(name='DataDiskPolicyRetentionDays'),
    systemDiskPolicyTimePeriod?: string(name='SystemDiskPolicyTimePeriod'),
    dataDiskPolicyTimePeriod?: string(name='DataDiskPolicyTimePeriod'),
    systemDiskPolicyEnabled?: string(name='SystemDiskPolicyEnabled'),
    systemDiskPolicyRetentionLastWeek?: string(name='SystemDiskPolicyRetentionLastWeek'),
    dataDiskPolicyEnabled?: string(name='DataDiskPolicyEnabled'),
  }(name='AutoSnapshotPolicy'),
  autoSnapshotExcutionStatus?: {
    systemDiskExcutionStatus?: string(name='SystemDiskExcutionStatus'),
    dataDiskExcutionStatus?: string(name='DataDiskExcutionStatus'),
  }(name='AutoSnapshotExcutionStatus'),
}

model DescribeAutoSnapshotPolicyResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeAutoSnapshotPolicyResponseBody(name='body'),
}

async function describeAutoSnapshotPolicy(request: DescribeAutoSnapshotPolicyRequest): DescribeAutoSnapshotPolicyResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeAutoSnapshotPolicy', 'POST', 'undefined', 'json', false, 'none', request);
}

model DescribeSpotAdviceRequest {
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  networkType?: string(name='NetworkType', position='Query'),
  ioOptimized?: string(name='IoOptimized', position='Query'),
  cores?: int32(name='Cores', description='The number of VCPUs of the instance type. For more information, see [instance type family](~~ 25378 ~~).', position='Query'),
  memory?: float(name='Memory', description='The memory size of the instance type. Unit: GiB. For more information, see [instance type family](~~ 25378 ~~).', position='Query'),
  instanceTypeFamily?: string(name='InstanceTypeFamily', description='The instance type family. For more information, see [instance type family](~~ 25378 ~~).', position='Query'),
  minMemory?: float(name='MinMemory', description='The minimum memory size of the instance type. For more information, see [instance type family](~~ 25378 ~~).', position='Query'),
  instanceFamilyLevel?: string(name='InstanceFamilyLevel', description='The instance type family. Valid values:

-EntryLevel: entry-level.
-EnterpriseLevel: enterprise-level.
-CreditEntryLevel: the entry level of points. For more information, see [burstable instances](~~ 59977 ~~).

Default value: none.', position='Query'),
  instanceTypes?: [ string ](name='InstanceTypes', description='The instance type. Valid values of N: 1 to 10. For more information, see [instance type family](~~ 25378 ~~).', position='Query'),
  minCores?: int32(name='MinCores', description='The minimum number of VCPUs of the instance type. For more information, see [instance type family](~~ 25378 ~~).', position='Query'),
  regionId?: string(name='RegionId', description='The ID of the region. You can call [DescribeRegions](~~ 25609 ~~) to view the latest region list.', position='Query'),
  zoneId?: string(name='ZoneId', description='The ID of the zone.

Default value: none, that query specified geographical lower all the available area.', position='Query'),
  gpuAmount?: int32(name='GpuAmount', description='The number of GPUs corresponding to the GPU instance. For more information, see [GPU compute instance Overview](~~ 108496 ~~).', position='Query'),
  gpuSpec?: string(name='GpuSpec', description='The type of the GPU computing card. Valid values:

-NVIDIA P4
-NVIDIA T4
-NVIDIA P100
-NVIDIA V100
-NVIDIA A100

Default value: none. For more information, see [GPU compute instance Overview](~~ 108496 ~~).', position='Query'),
}

model DescribeSpotAdviceResponseBody = {
  regionId?: string(name='RegionId', description='The ID of the region.'),
  requestId?: string(name='RequestId', description='The ID of the request.'),
  availableSpotZones?: {
    availableSpotZone?: [ 
    {
      zoneId?: string(name='ZoneId', description='The ID of the zone.'),
      availableSpotResources?: {
        availableSpotResource?: [ 
        {
          interruptRateDesc?: string(name='InterruptRateDesc', description='The release rate range of preemptible instances in the last 30 days, corresponding to the "InterruptionRate" return value. Possible values:

-0-3%
-3-5%
-5-10%
-10-100%'),
          averageSpotDiscount?: int32(name='AverageSpotDiscount', description='The discount rate of the average price of preemptible instances in the last 30 days compared to the price of pay-as-you-go instances. Unit:%. Valid values: 1 to 100.

You can calculate the average price of preemptible instances based on the returned value. For example, if the price of a pay-as-you-go instance is 1 and the return value is 20 (20%), the average price of a preemptible instance in the last 30 days is 0.2.'),
          instanceType?: string(name='InstanceType', description='The instance type.'),
          interruptionRate?: float(name='InterruptionRate', description='The average release rate of preemptible instances in the last 30 days. Unit:%'),
        }
      ](name='AvailableSpotResource')
      }(name='AvailableSpotResources', description='An array of the release rate and discount rate of preemptible instances in the last 30 days.'),
    }
  ](name='AvailableSpotZone')
  }(name='AvailableSpotZones', description='An array of zones and their corresponding preemptible instances.

> The Order of returned values is sorted by the historical average discount rate of the instance type.'),
}

model DescribeSpotAdviceResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeSpotAdviceResponseBody(name='body'),
}

/**
 * ## API description

-You can call this operation to query the information about preemptible instances in the last 30 days. This allows you to select the instance types of preemptible instances. You can query the following information:
-Average instance release rate.
-Average instance discount rate.
-Average price calculated by discount rate.

-You can only query preemptible instances of VPCs and I/O optimized instances.

-You can query the information of a preemptible instance in the last 30 days in any of the following ways:
-Set the "Cores" and "memore" parameters or the "MinCores" and "minmemore" parameters to query the instance types that meet the vCPU and memory requirements.
-Set "InstanceTypes. **to query the specified instance types.
-Set the "Cores" and "memore" parameters or the "MinCores" and "minmemore" parameters, and then set the "instancetypefamile" or "InstanceFamilyLevel" parameters to query the instance type family or a certain level, the instance types that meet the vCPU and memory requirements.
 */
async function describeSpotAdvice(request: DescribeSpotAdviceRequest): DescribeSpotAdviceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeSpotAdvice', 'POST', 'undefined', 'json', false, 'none', request);
}

model DeleteNetworkInterfacePermissionRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  networkInterfacePermissionId?: string(name='NetworkInterfacePermissionId', position='Query'),
  force?: boolean(name='Force', position='Query'),
}

model DeleteNetworkInterfacePermissionResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteNetworkInterfacePermissionResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteNetworkInterfacePermissionResponseBody(name='body'),
}

async function deleteNetworkInterfacePermission(request: DeleteNetworkInterfacePermissionRequest): DeleteNetworkInterfacePermissionResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteNetworkInterfacePermission', 'POST', 'undefined', 'json', false, 'none', request);
}

model CancelPhysicalConnectionRequest {
  regionId?: string(name='RegionId', position='Query'),
  physicalConnectionId?: string(name='PhysicalConnectionId', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  clientToken?: string(name='ClientToken', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  userCidr?: string(name='UserCidr', position='Query'),
}

model CancelPhysicalConnectionResponseBody = {
  requestId?: string(name='RequestId'),
}

model CancelPhysicalConnectionResponse = {
  headers: map[string]string(name='headers'),
  body: CancelPhysicalConnectionResponseBody(name='body'),
}

async function cancelPhysicalConnection(request: CancelPhysicalConnectionRequest): CancelPhysicalConnectionResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CancelPhysicalConnection', 'POST', 'undefined', 'json', false, 'none', request);
}

model DescribeLaunchTemplateVersionsRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  detailFlag?: boolean(name='DetailFlag', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='The account name of the resource master account.', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', description='The ID of the resource master account, that is, the UID.', position='Query'),
  minVersion?: long(name='MinVersion', description='Specify the minimum version number of the version by range.', position='Query'),
  maxVersion?: long(name='MaxVersion', description='Specifies the maximum version number of a version by range.', position='Query'),
  regionId?: string(name='RegionId', description='The ID of the region to which the instance launch template belongs.

You can call [DescribeRegions](~~ 25609 ~~) to view the latest region list.', position='Query'),
  ownerId?: long(name='OwnerId', description='The ID of the RAM user.', position='Query'),
  pageSize?: int32(name='PageSize', description='The number of entries to return on each page.

Default value: 10', position='Query'),
  launchTemplateVersion?: [ long ](name='LaunchTemplateVersion', description='One or more instance launch template versions.', position='Query'),
  defaultVersion?: boolean(name='DefaultVersion', description='Specifies whether to query the default version.', position='Query'),
  launchTemplateName?: string(name='LaunchTemplateName', description='The name of the instance launch template.', position='Query'),
  pageNumber?: int32(name='PageNumber', description='The page number of the instance launch template list. Start value: 1

Default value: 1.', position='Query'),
  launchTemplateId?: string(name='LaunchTemplateId', description='The ID of the instance launch template.

You must specify LaunchTemplateId or LaunchTemplateName to determine the template.', position='Query'),
}

model DescribeLaunchTemplateVersionsResponseBody = {
  pageSize?: int32(name='PageSize', description='The number of entries to return on each page.'),
  requestId?: string(name='RequestId', description='The ID of the request.'),
  pageNumber?: int32(name='PageNumber', description='The current page number.'),
  totalCount?: int32(name='TotalCount', description='The total number of instance launch templates.'),
  launchTemplateVersionSets?: {
    launchTemplateVersionSet?: [ 
    {
      launchTemplateName?: string(name='LaunchTemplateName', description='The name of the template.'),
      defaultVersion?: boolean(name='DefaultVersion', description='The default version of the template.'),
      versionNumber?: long(name='VersionNumber', description='Template version number.'),
      modifiedTime?: string(name='ModifiedTime', description='The time when the template was modified.'),
      launchTemplateId?: string(name='LaunchTemplateId', description='The ID of the template.'),
      createTime?: string(name='CreateTime', description='The time when the template was created.'),
      createdBy?: string(name='CreatedBy', description='The creator of the template.'),
      versionDescription?: string(name='VersionDescription', description='The description of the template version.'),
      launchTemplateData?: {
        systemDisk: {
          performanceLevel?: string(name='PerformanceLevel', description='When you create an ESSD as a system disk, set the performance level of the disk. This parameter returns a value when "SystemDisk.Category = cloud_essd. Possible values:

-PL0: The maximum random read/write IOPS per disk is 10,000.
-PL1: The maximum random read/write IOPS per disk is 50,000.
-PL2: The maximum random read/write IOPS per disk is 100,000.
-PL3: The maximum random read/write IOPS per disk is 1 million.'),
          diskName?: string(name='DiskName', description='System disk name.'),
          size?: int32(name='Size', description='The size of the system disk. Unit: GiB.'),
          deleteWithInstance?: boolean(name='DeleteWithInstance', description='Indicates whether the system disk is released with the instance.'),
          category?: string(name='Category', description='System disk species.'),
          description?: string(name='Description', description='System disk description.'),
          iops?: int32(name='Iops', description='The number of I/O operations per second on the system disk.

> This parameter will be discontinued soon. To improve code compatibility, try to use other parameters.'),
        }(name='SystemDisk'),
        deploymentSetId?: string(name='DeploymentSetId', description='The ID of the deployment set.'),
        vpcId?: string(name='VpcId', description='VPC VPC ID.'),
        keyPairName?: string(name='KeyPairName', description='The name of the key pair.'),
        networkType?: string(name='NetworkType', description='The network type.'),
        spotStrategy?: string(name='SpotStrategy', description='The bidding policy of the pay-as-you-go instance.'),
        enableVmOsConfig?: boolean(name='EnableVmOsConfig', description='Specifies whether to enable instance operating system configuration.'),
        description?: string(name='Description', description='The description of the instance.'),
        spotDuration?: int32(name='SpotDuration', description='The retention period of a preemptible instance. Unit: hours. Valid values: 0 to 6.

-The retention period is 2 to 6 and is being invited for testing. If you want to activate the service, submit a ticket.
-If the value is 0, the mode is not protected.'),
        instanceName?: string(name='InstanceName', description='The name of the instance.'),
        securityEnhancementStrategy?: string(name='SecurityEnhancementStrategy', description='Specifies whether to enable security hardening.'),
        userData?: string(name='UserData', description='The user data of the instance, encoded in Base64.'),
        spotPriceLimit?: float(name='SpotPriceLimit', description='Set the maximum hourly price for an instance.'),
        passwordInherit?: boolean(name='PasswordInherit', description='Specifies whether to inherit the username and password set in the original image.'),
        privateIpAddress?: string(name='PrivateIpAddress', description='The private IP address of the instance.'),
        imageId?: string(name='ImageId', description='The ID of the image used by the instance.'),
        autoReleaseTime?: string(name='AutoReleaseTime', description='The automatic release time.'),
        imageOwnerAlias?: string(name='ImageOwnerAlias', description='The source of the image.'),
        hostName?: string(name='HostName', description='The hostname of the instance.'),
        internetMaxBandwidthOut?: int32(name='InternetMaxBandwidthOut', description='The maximum outbound Internet bandwidth.'),
        internetMaxBandwidthIn?: int32(name='InternetMaxBandwidthIn', description='The maximum inbound public bandwidth.'),
        instanceType?: string(name='InstanceType', description='The instance type.'),
        period?: int32(name='Period', description='The duration of the resource purchase.'),
        instanceChargeType?: string(name='InstanceChargeType', description='The billing method of the instance.'),
        ioOptimized?: string(name='IoOptimized', description='Indicates whether the instance is I/O optimized.'),
        ramRoleName?: string(name='RamRoleName', description='The name of the instance RAM role.'),
        vSwitchId?: string(name='VSwitchId', description='The ID of the vSwitch to which the instance belongs.'),
        resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group to which the launch template belongs.'),
        internetChargeType?: string(name='InternetChargeType', description='The billing method of the Internet bandwidth.'),
        zoneId?: string(name='ZoneId', description='The ID of the zone.'),
        dataDisks?: {
          dataDisk?: [ 
          {
            performanceLevel?: string(name='PerformanceLevel', description='When you create an ESSD as a data disk, set the performance level of the disk. This parameter returns a value when "Category = cloud_essd. Possible values:

-PL0: The maximum random read/write IOPS per disk is 10,000.
-PL1: The maximum random read/write IOPS per disk is 50,000.
-PL2: The maximum random read/write IOPS per disk is 100,000.
-PL3: The maximum random read/write IOPS per disk is 1 million.'),
            description?: string(name='Description', description='The description of the data disk.'),
            snapshotId?: string(name='SnapshotId', description='The ID of the snapshot used by the data disk.'),
            device?: string(name='Device', description='The device name of the data disk.

> This parameter will be discontinued soon. We recommend that you do not use this parameter to improve code compatibility.'),
            size?: int32(name='Size', description='The size of the data disk.'),
            diskName?: string(name='DiskName', description='The name of the data disk.'),
            category?: string(name='Category', description='The type of the data disk.'),
            deleteWithInstance?: boolean(name='DeleteWithInstance', description='Indicates whether the data disk is released as the instance is released.'),
            encrypted?: string(name='Encrypted', description='Indicates whether the data disk is encrypted.'),
          }
        ](name='DataDisk')
        }(name='DataDisks', description='The collection of data disks.'),
        networkInterfaces?: {
          networkInterface?: [ 
          {
            networkInterfaceName?: string(name='NetworkInterfaceName', description='The name of the secondary Eni.'),
            vSwitchId?: string(name='VSwitchId', description='The ID of the vSwitch to which the Eni belongs.'),
            description?: string(name='Description', description='The description of the secondary Eni.'),
            primaryIpAddress?: string(name='PrimaryIpAddress', description='The primary private IP address of the secondary Eni.'),
            securityGroupId?: string(name='SecurityGroupId', description='The ID of the security group to which the secondary Eni belongs. Must be a security group in the same VPC.

> SecurityGroupId and SecurityGroupIds do not return values at the same time.'),
          }
        ](name='NetworkInterface')
        }(name='NetworkInterfaces', description='The attribute set of the secondary Eni.'),
        tags?: {
          instanceTag?: [ 
          {
            key?: string(name='Key', description='The tag key of the instance.'),
            value?: string(name='Value', description='The tag value of the instance.'),
          }
        ](name='InstanceTag')
        }(name='Tags', description='The tag of the instance.'),
        securityGroupIds?: {
          securityGroupId?: [ string ](name='SecurityGroupId')
        }(name='SecurityGroupIds'),
      }(name='LaunchTemplateData', description='The template configuration.'),
    }
  ](name='LaunchTemplateVersionSet')
  }(name='LaunchTemplateVersionSets', description='The information about the template version.'),
}

model DescribeLaunchTemplateVersionsResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeLaunchTemplateVersionsResponseBody(name='body'),
}

async function describeLaunchTemplateVersions(request: DescribeLaunchTemplateVersionsRequest): DescribeLaunchTemplateVersionsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeLaunchTemplateVersions', 'POST', 'undefined', 'json', false, 'none', request);
}

model DetachNetworkInterfaceRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  trunkNetworkInstanceId?: string(name='TrunkNetworkInstanceId', position='Query'),
  networkInterfaceId?: string(name='NetworkInterfaceId', description='The ID of the Eni.', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='The account name of the resource master account.', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', description='The ID of the resource master account, that is, the UID.', position='Query'),
  instanceId?: string(name='InstanceId', description='The ID of the instance.', position='Query'),
  ownerId?: long(name='OwnerId', description='The ID of the RAM user.', position='Query'),
  regionId?: string(name='RegionId', description='The region to which the resource belongs. You can call [DescribeRegions](~~ 25609 ~~) to view the latest region list.', position='Query'),
}

model DetachNetworkInterfaceResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.'),
}

model DetachNetworkInterfaceResponse = {
  headers: map[string]string(name='headers'),
  body: DetachNetworkInterfaceResponseBody(name='body'),
}

/**
 * ## Description

When you call this operation, note that:

-The primary ENI of the instance cannot be detached.

-The Eni must be in the Detaching or InUse state.

-The instance must be in the Running (Running) or Stopped (Stopped) state.
 */
async function detachNetworkInterface(request: DetachNetworkInterfaceRequest): DetachNetworkInterfaceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DetachNetworkInterface', 'POST', 'undefined', 'json', false, 'none', request);
}

model ModifyNetworkInterfaceAttributeRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  regionId?: string(name='RegionId', description='The region ID of the Eni. You can call [DescribeRegions](~~ 25609 ~~) to view the latest region list.', position='Query'),
  description?: string(name='Description', description='The description of the Eni. The description must be 2 to 256 characters in length and cannot start with "http:// "or "https.

Default value: Null.', position='Query'),
  networkInterfaceId?: string(name='NetworkInterfaceId', description='The ID of the Eni.', position='Query'),
  queueNumber?: int32(name='QueueNumber', description='The number of Nic queues. Valid values: 1 to 2048.

-You can only modify the number of secondary Nic queues.
-Allows you to modify the number of secondary Nic queues in the available state ("Available") or the number of secondary Nic queues that have been bound ("InUse") to an instance but the instance is in the stopped state ("Stopped").
-The number of secondary Nic queues cannot exceed the maximum number of queues for a single Nic allowed by the instance type, and the cumulative number of queues for all NICs of the instance cannot exceed the total number of queues allowed by the instance type. You can call the [DescribeInstanceTypes](~~ 25620 ~~) operation to query the maximum number of queues and total quotas of an Eni.', position='Query'),
  networkInterfaceName?: string(name='NetworkInterfaceName', description='The name of the Eni. The description must be 2 to 128 characters in length. It must start with a letter and cannot start with "http:// "or "https. It can contain numbers, colons (:), underscores (_), and hyphens (-).

Default value: Null.', position='Query'),
  securityGroupId?: [ string ](name='SecurityGroupId', description='SecurityGroupId the list of security groups to which the Eni belongs, and the Eni is removed from the existing security group. Valid values of N: 1 to 5.
> the modification of the security group takes effect soon with a small latency.', position='Query'),
}

model ModifyNetworkInterfaceAttributeResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.'),
}

model ModifyNetworkInterfaceAttributeResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyNetworkInterfaceAttributeResponseBody(name='body'),
}

async function modifyNetworkInterfaceAttribute(request: ModifyNetworkInterfaceAttributeRequest): ModifyNetworkInterfaceAttributeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyNetworkInterfaceAttribute', 'POST', 'undefined', 'json', false, 'none', request);
}

model AllocateEipAddressRequest {
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  bandwidth?: string(name='Bandwidth', position='Query'),
  ISP?: string(name='ISP', position='Query'),
  internetChargeType?: string(name='InternetChargeType', position='Query'),
  activityId?: long(name='ActivityId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  clientToken?: string(name='ClientToken', position='Query'),
}

model AllocateEipAddressResponseBody = {
  requestId?: string(name='RequestId'),
  allocationId?: string(name='AllocationId'),
  eipAddress?: string(name='EipAddress'),
}

model AllocateEipAddressResponse = {
  headers: map[string]string(name='headers'),
  body: AllocateEipAddressResponseBody(name='body'),
}

async function allocateEipAddress(request: AllocateEipAddressRequest): AllocateEipAddressResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'AllocateEipAddress', 'POST', 'undefined', 'json', false, 'none', request);
}

model DeleteDiskRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', description='The ID of the RAM user.', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='The account name of the resource master account.', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', description='The ID of the resource master account, that is, the UID.', position='Query'),
  diskId?: string(name='DiskId', description='The ID of the cloud disk device to be released.', position='Query'),
}

model DeleteDiskResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.'),
}

model DeleteDiskResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteDiskResponseBody(name='body'),
}

/**
 * ## API description

When you call this operation, note that:

-Manual snapshots of your disks are retained.

-You can use [ModifyDiskAttribute](~~ 25517 ~~) to set whether to retain or release automatic snapshots at the same time. We recommend that you delete unnecessary snapshots in a timely manner to maintain sufficient snapshot quotas for periodic automatic snapshot policies.

-When you release a disk, the disk must be in the Available state.

-If the specified disk ID does not exist, the request is ignored.
 */
async function deleteDisk(request: DeleteDiskRequest): DeleteDiskResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteDisk', 'POST', 'undefined', 'json', false, 'none', request);
}

model DescribeEventsRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  resourceId?: string(name='ResourceId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  eventId?: string(name='EventId', position='Query'),
  eventType?: string(name='EventType', position='Query'),
  status?: string(name='Status', position='Query'),
  planTime?: string(name='PlanTime', position='Query'),
  expireTime?: string(name='ExpireTime', position='Query'),
  pageNumber?: int32(name='PageNumber', position='Query'),
  pageSize?: int32(name='PageSize', position='Query'),
}

model DescribeEventsResponseBody = {
  requestId?: string(name='RequestId'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  totalCount?: int32(name='TotalCount'),
  events?: {
    event?: [ 
    {
      eventId?: string(name='EventId'),
      status?: string(name='Status'),
      eventType?: string(name='EventType'),
      eventCategory?: string(name='EventCategory'),
      expireTime?: string(name='ExpireTime'),
      supportModify?: string(name='SupportModify'),
      planTime?: string(name='PlanTime'),
      resourceId?: string(name='ResourceId'),
    }
  ](name='Event')
  }(name='Events'),
}

model DescribeEventsResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeEventsResponseBody(name='body'),
}

async function describeEvents(request: DescribeEventsRequest): DescribeEventsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeEvents', 'POST', 'undefined', 'json', false, 'none', request);
}

model CreateKeyPairRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  tag?: [ 
    {
      key?: string(name='Key', description='密钥对的标签键。N的取值范围：1~20。一旦传入该值，则不允许为空字符串。最多支持128个字符，不能以aliyun和acs:开头，不能包含http://或者https://。'),
      value?: string(name='Value', description='密钥对的标签值。N的取值范围：1~20。一旦传入该值，允许为空字符串。最多支持128个字符，不能以acs:开头，不能包含http://或者https://。'),
    }
  ](name='Tag', position='Query'),
  ownerId?: long(name='OwnerId', description='The ID of the RAM user.', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='The account name of the resource master account.', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', description='The ID of the resource master account, that is, the UID.', position='Query'),
  regionId?: string(name='RegionId', description='The region ID of the key pair. You can call [DescribeRegions](~~ 25609 ~~) to view the latest region list.', position='Query'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group to which the SSH key pair belongs.', position='Query'),
  keyPairName?: string(name='KeyPairName', description='The name of the key pair. The description must be 2 to 128 characters in length. It must start with a letter and cannot start with http:// or https. It can contain numbers, colons (:), underscores (_), and hyphens (-).', position='Query'),
}

model CreateKeyPairResponseBody = {
  privateKeyBody?: string(name='PrivateKeyBody', description='The private key of the key pair. The private key in the PKCS#8 format encoded by PEM.'),
  keyPairName?: string(name='KeyPairName', description='The name of the key pair.'),
  keyPairId?: string(name='KeyPairId', description='The ID of the SSH key pair.'),
  requestId?: string(name='RequestId', description='The ID of the request.'),
  keyPairFingerPrint?: string(name='KeyPairFingerPrint', description='The fingerprint of the key pair. According to the public key fingerprint format defined in RFC4716, MD5 Information Digest Algorithm is adopted. For more information, see [RFC4716](https://tools.ietf.org/html/rfc4716).'),
}

model CreateKeyPairResponse = {
  headers: map[string]string(name='headers'),
  body: CreateKeyPairResponseBody(name='body'),
}

/**
 * ## API description

In addition to calling the CreateKeyPair to create a key pair, you can also use a third-party tool to create a key pair and upload it ([ImportKeyPair](~~ 51774 ~~) to an Alibaba Cloud region, the usage method is the same as the key pair we created for you.

The maximum number of key pairs in each region is 500. For more information, see [limits](~~ 25412 ~~).
 */
async function createKeyPair(request: CreateKeyPairRequest): CreateKeyPairResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateKeyPair', 'POST', 'undefined', 'json', false, 'none', request);
}

model DescribeDeploymentSetsRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', description='The ID of the RAM user.', position='Query'),
  domain?: string(name='Domain', description='The deployment domain.

> use other parameters to improve compatibility.', position='Query'),
  regionId?: string(name='RegionId', description='The ID of the region to which the deployment set belongs. You can call [DescribeRegions](~~ 25609 ~~) to view the latest region list.', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='The account name of the resource master account.', position='Query'),
  deploymentSetIds?: string(name='DeploymentSetIds', description='The list of deployment set IDs. The value can be a JSON Array consisting of multiple deployment set IDs. A maximum of 100 IDs can be entered. Separate IDs with commas (,).', position='Query'),
  networkType?: string(name='NetworkType', description='The network type of the instance in the deployment set.

> use other parameters to improve compatibility.', position='Query'),
  pageNumber?: int32(name='PageNumber', description='The page number of the deployment set list.

Start value: 1

Default value: 1.', position='Query'),
  pageSize?: int32(name='PageSize', description='The number of entries to return on each page.

Maximum Value: 50

Default value: 10', position='Query'),
  deploymentSetName?: string(name='DeploymentSetName', description='The name of the deployment set.', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', description='The ID of the resource master account, that is, the UID.', position='Query'),
  strategy?: string(name='Strategy', description='The deployment policy. You can only set high-availability policies. Value: Availability

Default value: Null.', position='Query'),
  granularity?: string(name='Granularity', description='The deployment granularity.

> use other parameters to improve compatibility.', position='Query'),
}

model DescribeDeploymentSetsResponseBody = {
  pageSize?: int32(name='PageSize', description='The number of rows per page.'),
  pageNumber?: int32(name='PageNumber', description='The number of pages in the deployment set list.'),
  requestId?: string(name='RequestId', description='The ID of the request.'),
  totalCount?: int32(name='TotalCount', description='The total number of queried deployment sets.'),
  regionId?: string(name='RegionId', description='The region ID of the deployment set.'),
  deploymentSets?: {
    deploymentSet?: [ 
    {
      creationTime?: string(name='CreationTime', description='The time when the deployment set was created.'),
      strategy?: string(name='Strategy', description='The deployment policy.'),
      deploymentSetId?: string(name='DeploymentSetId', description='The ID of the deployment set.'),
      deploymentStrategy?: string(name='DeploymentStrategy', description='The deployment policy. The returned value corresponds to the value of the request parameter "stratege.'),
      deploymentSetDescription?: string(name='DeploymentSetDescription', description='The description of the deployment set.'),
      domain?: string(name='Domain', description='The deployment domain.'),
      groupCount?: int32(name='GroupCount', description='> This parameter is being invited for testing and is not currently available.'),
      granularity?: string(name='Granularity', description='The deployment granularity.'),
      deploymentSetName?: string(name='DeploymentSetName', description='The name of the deployment set.'),
      instanceAmount?: int32(name='InstanceAmount', description='The number of instances in the deployment set.'),
      instanceIds?: {
        instanceId?: [ string ](name='InstanceId')
      }(name='InstanceIds'),
    }
  ](name='DeploymentSet')
  }(name='DeploymentSets', description='Returns the deployment set details in an array of DeploymentSet.'),
}

model DescribeDeploymentSetsResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeDeploymentSetsResponseBody(name='body'),
}

async function describeDeploymentSets(request: DescribeDeploymentSetsRequest): DescribeDeploymentSetsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeDeploymentSets', 'POST', 'undefined', 'json', false, 'none', request);
}

model GetInstanceScreenshotRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  instanceId?: string(name='InstanceId', description='The ID of the instance.', position='Query'),
  regionId?: string(name='RegionId', description='The region ID of the instance. You can call [DescribeRegions](~~ 25609 ~~) to view the latest region list.', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', description='The ID of the resource master account, that is, the UID.', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='The account name of the resource master account.', position='Query'),
  ownerId?: long(name='OwnerId', description='The ID of the RAM user.', position='Query'),
  wakeUp?: boolean(name='WakeUp', description='Indicates whether to wake up the dormant instance.

Default value: false', position='Query'),
}

model GetInstanceScreenshotResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.'),
  instanceId?: string(name='InstanceId', description='The ID of the instance.'),
  screenshot?: string(name='Screenshot', description='A screenshot of an instance in JPG format. The base64-encoded image is returned.'),
}

model GetInstanceScreenshotResponse = {
  headers: map[string]string(name='headers'),
  body: GetInstanceScreenshotResponseBody(name='body'),
}

/**
 * ## API description

After the ECS instance returns a base64-encoded screenshot in JPG format, you need to decode it yourself. You can call this operation when troubleshooting. Note that:

-The instance must be in the Running state.

-[Phased-out instance types](~~ 55263 ~~) cannot obtain screenshot information.

-If you call this operation multiple times in the same instance, the call interval must be at least 10 seconds. Otherwise, the error code "Throttling" is returned ".
 */
async function getInstanceScreenshot(request: GetInstanceScreenshotRequest): GetInstanceScreenshotResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetInstanceScreenshot', 'POST', 'undefined', 'json', false, 'none', request);
}

model DeleteDemandRequest {
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  regionId?: string(name='RegionId', description='The ID of the region to which the reported instance belongs. You can call [DescribeRegions](~~ 25609 ~~) to view the latest region list.', position='Query'),
  clientToken?: string(name='ClientToken', description='Ensure the idempotence of the request. Generate a parameter value from your client. Make sure that the value is unique among different requests. "ClientToken" only supports ASCII characters and cannot exceed 64 characters in length. For more information, see [how to ensure idempotence](~~ 25693 ~~).', position='Query'),
  reason?: string(name='Reason', description='The reason for deleting the report.', position='Query'),
  demandId?: string(name='DemandId', description='The ID of the report.', position='Query'),
}

model DeleteDemandResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.'),
}

model DeleteDemandResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteDemandResponseBody(name='body'),
}

/**
 * > This API is in the beta test and has not been officially launched. We recommend that you do not use this API. Please wait.
 */
async function deleteDemand(request: DeleteDemandRequest): DeleteDemandResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteDemand', 'POST', 'undefined', 'json', false, 'none', request);
}

model InstallCloudAssistantRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  regionId?: string(name='RegionId', description='The region ID of the instance. You can call [DescribeRegions](~~ 25609 ~~) to view the latest region list.', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', description='The ID of the resource master account, that is, the UID.', position='Query'),
  ownerId?: long(name='OwnerId', description='The ID of the RAM user.', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='The account name of the resource master account.', position='Query'),
  instanceId?: [ string ](name='InstanceId', description='The ID of the instance. Valid values of N: 1 to 50.', position='Query'),
}

model InstallCloudAssistantResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.'),
}

model InstallCloudAssistantResponse = {
  headers: map[string]string(name='headers'),
  body: InstallCloudAssistantResponseBody(name='body'),
}

async function installCloudAssistant(request: InstallCloudAssistantRequest): InstallCloudAssistantResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'InstallCloudAssistant', 'POST', 'undefined', 'json', false, 'none', request);
}

model DescribeElasticityAssuranceInstancesRequest {
  privatePoolOptions?: {
    id?: string(name='Id', description='The ID of the elastic protection service.', position=''),
  }(name='PrivatePoolOptions'),
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  packageType?: string(name='PackageType', position='Query'),
  maxResults?: int32(name='MaxResults', description='The number of entries to return on each page.

Maximum Value: 100

Default value: 10', position='Query'),
  regionId?: string(name='RegionId', description='The ID of the region to which the elastic Protection Service belongs. You can call [DescribeRegions](~~ 25609 ~~) to view the latest region list.', position='Query'),
  nextToken?: string(name='NextToken', description='The start flag of the query. This parameter is obtained from the last request.', position='Query'),
}

model DescribeElasticityAssuranceInstancesResponseBody = {
  nextToken?: string(name='NextToken', description='The start flag of the next query.'),
  requestId?: string(name='RequestId', description='The ID of the request.'),
  totalCount?: int32(name='TotalCount', description='The number of records that meet the query criteria.'),
  maxResults?: int32(name='MaxResults', description='The number of entries to return on each page.'),
  elasticityAssuranceItem?: {
    instanceIdSet?: [ 
    {
      instanceId?: string(name='InstanceId', description='The ID of the instance.'),
    }
  ](name='InstanceIdSet')
  }(name='ElasticityAssuranceItem', description='The list of instances that have been matched by the elastic protection service.'),
}

model DescribeElasticityAssuranceInstancesResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeElasticityAssuranceInstancesResponseBody(name='body'),
}

/**
 * ## API description

When the auto guarantee service expires, the matching associated data between the instance and the private pool of the auto guarantee service also becomes invalid. You can call this operation to query invalid services. The return value is null.
 */
async function describeElasticityAssuranceInstances(request: DescribeElasticityAssuranceInstancesRequest): DescribeElasticityAssuranceInstancesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeElasticityAssuranceInstances', 'POST', 'undefined', 'json', false, 'none', request);
}

model JoinSecurityGroupRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  networkInterfaceId?: string(name='NetworkInterfaceId', description='The ID of the Eni.

> When this parameter is specified, "InstanceId" must be empty.', position='Query'),
  regionId?: string(name='RegionId', description='The ID of the region. You can call [DescribeRegions](~~ 25609 ~~) to view the latest region list.

-You can add an instance to a security group without specifying the region ID.
-To add an Eni to a security group, you must specify the region ID of the Eni.', position='Query'),
  ownerId?: long(name='OwnerId', description='The ID of the RAM user.', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='The account name of the resource master account.', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', description='The ID of the resource master account, that is, the UID.', position='Query'),
  instanceId?: string(name='InstanceId', description='The ID of the instance.

> When this parameter is specified, "NetworkInterfaceId" must be empty.', position='Query'),
  securityGroupId?: string(name='SecurityGroupId', description='The ID of the security group. You can call [DescribeSecurityGroups](~~ 25556 ~~) to view the available security groups.', position='Query'),
}

model JoinSecurityGroupResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.'),
}

model JoinSecurityGroupResponse = {
  headers: map[string]string(name='headers'),
  body: JoinSecurityGroupResponseBody(name='body'),
}

/**
 * ## API description

> This API is not recommended. We recommend that you call the [ModifyInstanceAttribute](~~ 25503 ~~) API to add or remove an ECS instance from a security group. Call the [ModifyNetworkInterfaceAttribute](~~ 58513 ~~) API to remove an ENI (ENI) add or remove a security group.

When you call this operation, note that:

-Before joining a security group, the instance must be in the **Stopped**(Stopped) or **Running**(Running) status.

-An instance can join up to five security groups.

-<props = "china"> You can [submit a ticket](https://selfservice.console.aliyun.com/ticket/createIndex.htm) to apply for adding instances to more security groups. A maximum of 16 security groups can be added. </props>

-<props = "intl"> You can [submit a ticket](https://workorder-intl.console.aliyun.com/#/ticket/createIndex) to apply for adding instances to more security groups. A maximum of 16 security groups can be added. </props>

-Each common security group can manage a maximum of 2,000 instances and an Enterprise Security Group can manage a maximum of 65536 instances.

-Your Security Group and instance must belong to the same Alibaba Cloud region.

-Your Security Group and instance must have the same network type. If the network type is VPC, the security group and the instance must belong to the same VPC.

-You cannot add an instance and an Eni to a security group at the same time, that is, the values of the "InstanceId" and "NetworkInterfaceId" parameters cannot be passed at the same time.
 */
async function joinSecurityGroup(request: JoinSecurityGroupRequest): JoinSecurityGroupResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'JoinSecurityGroup', 'POST', 'undefined', 'json', false, 'none', request);
}

model DescribeDedicatedHostTypesRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  supportedInstanceTypeFamily?: string(name='SupportedInstanceTypeFamily', description='The ECS instance type families supported by the dedicated host.', position='Query'),
  dedicatedHostType?: string(name='DedicatedHostType', description='The type of the dedicated host. For more information, see [host specifications](~~ 68564 ~~).', position='Query'),
  regionId?: string(name='RegionId', description='The region ID of the dedicated host. You can call [DescribeRegions](~~ 25609 ~~) to view the latest region list.', position='Query'),
}

model DescribeDedicatedHostTypesResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.'),
  dedicatedHostTypes?: {
    dedicatedHostType?: [ 
    {
      cores?: int32(name='Cores', description='The number of cores per physical CPU.'),
      localStorageCategory?: string(name='LocalStorageCategory', description='The type of the local disk.'),
      GPUSpec?: string(name='GPUSpec', description='The GPU model.'),
      totalVcpus?: int32(name='TotalVcpus', description='The total number of virtual CPU cores.'),
      cpuOverCommitRatioRange?: string(name='CpuOverCommitRatioRange', description='You can set the CPU oversell ratio.'),
      physicalGpus?: int32(name='PhysicalGpus', description='The number of physical GPUs.'),
      memorySize?: float(name='MemorySize', description='The memory capacity. Unit: GiB.'),
      supportCpuOverCommitRatio?: boolean(name='SupportCpuOverCommitRatio', description='Specifies whether to set the CPU oversell ratio.'),
      localStorageCapacity?: long(name='LocalStorageCapacity', description='The capacity of a local disk. Unit: GiB.'),
      dedicatedHostType?: string(name='DedicatedHostType', description='The type of the dedicated host. If you want to use more dedicated host specifications, open a ticket to contact Alibaba Cloud.'),
      localStorageAmount?: int32(name='LocalStorageAmount', description='The number of local disks on the dedicated host.'),
      totalVgpus?: int32(name='TotalVgpus', description='The total number of virtual GPU cores.'),
      sockets?: int32(name='Sockets', description='The number of physical processors.'),
      supportedInstanceTypeFamilies?: {
        supportedInstanceTypeFamily?: [ string ](name='SupportedInstanceTypeFamily')
      }(name='SupportedInstanceTypeFamilies'),
      supportedInstanceTypesList?: {
        supportedInstanceTypesList?: [ string ](name='SupportedInstanceTypesList')
      }(name='SupportedInstanceTypesList'),
    }
  ](name='DedicatedHostType')
  }(name='DedicatedHostTypes', description='Returns the specifications of the dedicated host.'),
}

model DescribeDedicatedHostTypesResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeDedicatedHostTypesResponseBody(name='body'),
}

async function describeDedicatedHostTypes(request: DescribeDedicatedHostTypesRequest): DescribeDedicatedHostTypesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeDedicatedHostTypes', 'POST', 'undefined', 'json', false, 'none', request);
}

model DescribeSnapshotsRequest {
  filter?: [
    {
      key?: string(name='Key', description='The filter key used to query resources. The value must be "CreationStartTime ". Set "Filter.1.Key" and "Filter.1.Value" to query resource information created after a specified time point.', position=''),
      value?: string(name='Value', description='The filter value when you query resources. When you specify this parameter, you must specify the "Filter.1.Key" parameter in the format of "yyyy-MM-ddTHH:mmZ", in UTC +0 time zone.', position=''),
    }
  ](name='Filter'),
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  tag?: [ 
    {
      key?: string(name='key'),
      value?: string(name='Value', description='快照的标签值。N的取值范围：1~20'),
    }
  ](name='Tag', position='Query'),
  pageNumber?: int32(name='PageNumber', description='The page number of the snapshot list. Start value: 1

Default value: 1.', position='Query'),
  regionId?: string(name='RegionId', description='The ID of the region to which the cloud disk belongs. You can call [DescribeRegions](~~ 25609 ~~) to view the latest region list.', position='Query'),
  encrypted?: boolean(name='Encrypted', description='Specifies whether to filter encrypted snapshots. Default value: false', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', description='The ID of the resource master account, that is, the UID.', position='Query'),
  pageSize?: int32(name='PageSize', description='The number of entries to return on each page. Maximum Value: 100

Default value: 10', position='Query'),
  maxResults?: int32(name='MaxResults', description='The number of entries to return on each page. Maximum Value: 100

Default value: 10', position='Query'),
  KMSKeyId?: string(name='KMSKeyId', description='The KMS key ID of the data disk.', position='Query'),
  diskId?: string(name='DiskId', description='The ID of the cloud disk device.', position='Query'),
  usage?: string(name='Usage', description='Specifies whether a snapshot is used to create an image or cloud disk. Valid values:

-image: a custom image is created using a snapshot.
-disk: Creates a disk from a snapshot.
-image_disk: creates a data disk and a custom image from a snapshot.
-none: Not yet.', position='Query'),
  category?: string(name='Category', description='The type of the snapshot. Valid values:
-Standard: normal snapshot
-Flash: local snapshot

The original snapshot is replaced with the snapshot extreme available feature. This parameter is described as follows:
-If you have used a local snapshot before December 14, 2020. You can use this parameter normally.
-If you have not used a local snapshot before December 14, 2020. You cannot use this parameter.

<props = "china"> for more information, see [Alibaba Cloud Snapshot service upgrade and new billing items notice on December 14](https://help.aliyun.com/noticelist/articleid/1060755542.html). </props>

> This parameter will be deprecated soon. We recommend that you use other parameters to improve compatibility.', position='Query'),
  snapshotLinkId?: string(name='SnapshotLinkId', description='The ID of the snapshot chain.', position='Query'),
  instanceId?: string(name='InstanceId', description='The ID of the instance.', position='Query'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group. When you use this parameter to filter resources, the number of resources cannot exceed 1,000.', position='Query'),
  snapshotIds?: string(name='SnapshotIds', description='The ID of the snapshot. The value can be a JSON Array consisting of multiple snapshot IDs. A maximum of 100 IDs can be entered. Separate IDs with commas (,).', position='Query'),
  status?: string(name='Status', description='The status of the snapshot. Valid values:

-progressing: the snapshot is being created.
-accomplished: the snapshot is created.
-failed: the snapshot failed to be created.
-all: the status of all snapshots.', position='Query'),
  nextToken?: string(name='NextToken', description='The start flag of the query. This parameter is obtained from the last request.', position='Query'),
  snapshotName?: string(name='SnapshotName', description='The name of the snapshot.', position='Query'),
  snapshotType?: string(name='SnapshotType', description='The type of the snapshot. Valid values:

-auto: automatically creates snapshots.
-user: manually create a snapshot.
-all (default): all snapshot creation types.', position='Query'),
  sourceDiskType?: string(name='SourceDiskType', description='The disk type of the snapshot source disk. Valid values:

-System: System disk
-Data: Data disk

> The value is case insensitive.', position='Query'),
  dryRun?: boolean(name='DryRun', description='Specifies whether to PreCheck only this request.

-true: sends a check request without querying the resource status. Check whether the AccessKey is valid, whether the RAM user is authorized, and whether required parameters are specified. If the check fails, the corresponding error is returned. If the check succeeds, an error code DryRunOperation is returned.
-false (default): a normal request is sent. After the request passes the check, the status code 2XX is returned and the resource status is directly queried.', position='Query'),
}

model DescribeSnapshotsResponseBody = {
  nextToken?: string(name='NextToken', description='The start flag of the next query.'),
  pageSize?: int32(name='PageSize', description='The number of entries to return on each page.'),
  pageNumber?: int32(name='PageNumber', description='The page number of the snapshot list.'),
  requestId?: string(name='RequestId', description='The ID of the request.'),
  totalCount?: int32(name='TotalCount', description='The total number of snapshots.'),
  snapshots?: {
    snapshot?: [ 
    {
      status?: string(name='Status', description='The status of the snapshot. Possible values:

-progressing
-accomplished
-failed'),
      creationTime?: string(name='CreationTime', description='The creation time. The time follows the [ISO8601](~~ 25696 ~~) standard and uses UTC +0. The format is yyyy-MM-ddTHH:mm:ssZ.'),
      progress?: string(name='Progress', description='The progress of snapshot creation. Unit: percentage.'),
      instantAccess?: boolean(name='InstantAccess', description='Indicates whether the snapshot extreme availability feature is enabled. Possible values:

-true: enabled. Only ESSDS support this feature.
-false: disabled. That is, a snapshot is a normal snapshot that is not enabled.'),
      remainTime?: int32(name='RemainTime', description='The remaining completion time of the snapshot being created. Unit: seconds.'),
      sourceDiskSize?: string(name='SourceDiskSize', description='The capacity of the source disk. Unit: GiB.'),
      retentionDays?: int32(name='RetentionDays', description='The number of days that automatic snapshots are retained.'),
      sourceDiskType?: string(name='SourceDiskType', description='The attributes of the source disk. Possible values:

-system
-data'),
      sourceStorageType?: string(name='SourceStorageType', description='The type of the disk.

> This parameter will be deprecated soon. We recommend that you use other parameters to improve compatibility.'),
      usage?: string(name='Usage', description='Specifies whether a snapshot is used to create an image or cloud disk. Possible values:

-image
-disk
-image_disk
-none'),
      lastModifiedTime?: string(name='LastModifiedTime', description='The last time when the snapshot was changed. The time follows the [ISO8601](~~ 25696 ~~) standard and uses UTC +0. The format is yyyy-MM-ddTHH:mm:ssZ.'),
      encrypted?: boolean(name='Encrypted', description='Specifies whether the snapshot is encrypted.'),
      snapshotType?: string(name='SnapshotType', description='The type of the snapshot. Possible values:

-auto or timer: automatically creates snapshots.
-user: manually create a snapshot.
-all: all snapshot creation types.'),
      sourceDiskId?: string(name='SourceDiskId', description='The ID of the source disk. This field is retained if the source disk of the snapshot is released.'),
      snapshotName?: string(name='SnapshotName', description='The name of the snapshot. If the snapshot display name is specified during creation, the system returns.'),
      instantAccessRetentionDays?: int32(name='InstantAccessRetentionDays', description='Specifies the retention period of the snapshot extreme availability feature. After the retention period expires, the snapshot extreme availability feature is automatically disabled.

The default value is the same as the value of the "RetentionDays" parameter.'),
      description?: string(name='Description', description='The description.'),
      snapshotId?: string(name='SnapshotId', description='The ID of the snapshot.'),
      resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group.'),
      category?: string(name='Category', description='The type of the snapshot.

> This parameter will be deprecated soon. We recommend that you use the "InstantAccess" parameter to improve compatibility ".'),
      KMSKeyId?: string(name='KMSKeyId', description='The KMS key ID of the data disk.'),
      snapshotSN?: string(name='SnapshotSN', description='Snapshot serial number.'),
      productCode?: string(name='ProductCode', description='The product ID inherited from the marketplace.'),
      sourceSnapshotId?: string(name='SourceSnapshotId', description='SOURCE snapshot'),
      sourceRegionId?: string(name='SourceRegionId', description='SOURCE snapshot region'),
      tags?: {
        tag?: [ 
        {
          tagValue?: string(name='TagValue', description='The tag value of the snapshot.'),
          tagKey?: string(name='TagKey', description='The tag key of the snapshot.'),
        }
      ](name='Tag')
      }(name='Tags', description='The tag.'),
    }
  ](name='Snapshot')
  }(name='Snapshots', description='A collection of snapshot details.'),
}

model DescribeSnapshotsResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeSnapshotsResponseBody(name='body'),
}

/**
 * ## API description

"InstanceId", "DiskId", And "SnapshotIds" are not required request parameters, but you can construct a filter logic. The parameters are logically And.

When calling an API through Alibaba Cloud CLI, the request parameter values of different data types must comply with certain format requirements. For more information, see [CLI parameter format description](~~ 110340 ~~).
 */
async function describeSnapshots(request: DescribeSnapshotsRequest): DescribeSnapshotsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeSnapshots', 'POST', 'undefined', 'json', false, 'none', request);
}

model ModifyStorageSetAttributeRequest {
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  clientToken?: string(name='ClientToken', description='Ensure the idempotence of the request. Generate a parameter value from your client. Make sure that the value is unique among different requests. **ClientToken** supports only ASCII characters and cannot exceed 64 characters. For more information, see [how to ensure idempotence](~~ 25693 ~~).', position='Query'),
  storageSetName?: string(name='StorageSetName', description='The name of the storage set. The description must be 2 to 128 characters in length. It must start with a letter and cannot start with http:// or https. It can contain numbers, colons (:), underscores (_), and hyphens (-).', position='Query'),
  regionId?: string(name='RegionId', description='The region to which the bucket belongs. You can call [DescribeRegions](~~ 25609 ~~) to view the latest region list.', position='Query'),
  storageSetId?: string(name='StorageSetId', description='The ID of the storage set.', position='Query'),
  description?: string(name='Description', description='The description of the storage set. The description must be 2 to 256 characters in length and cannot start with http:// or https.', position='Query'),
}

model ModifyStorageSetAttributeResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.'),
}

model ModifyStorageSetAttributeResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyStorageSetAttributeResponseBody(name='body'),
}

async function modifyStorageSetAttribute(request: ModifyStorageSetAttributeRequest): ModifyStorageSetAttributeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyStorageSetAttribute', 'POST', 'undefined', 'json', false, 'none', request);
}

model DescribeImagePipelineExecutionsRequest {
  tag?: [ 
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='Tag', position='Query'),
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  imagePipelineId?: string(name='ImagePipelineId', description='The ID of the image template.', position='Query'),
  regionId?: string(name='RegionId', description='Belongs geo ID. You can call [DescribeRegions](~~ 25609 ~~) to view the latest region list.', position='Query'),
  nextToken?: string(name='NextToken', description='Query the credential (Token). The value is the value of the "NextToken" parameter returned by the last call to the API. You do not need to set this parameter when you call the API for the first time.', position='Query'),
  maxResults?: int32(name='MaxResults', description='The number of entries to return on each page. Valid values: 1 to 500.

Default value: 50.', position='Query'),
  executionId?: string(name='ExecutionId', description='The ID of the image build task.', position='Query'),
  status?: string(name='Status', description='The status of the image build task. You can set multiple values at the same time. Separate values with commas (,). The format is "BUILDING,DISTRIBUTING ". Valid values:

-BUILDING: BUILDING
-DISTRIBUTING: DISTRIBUTING
-RELEASING: resources are being recycled
-SUCCESS: Successful
-FAILED: FAILED.
-CANCELLING: Canceling
-CANCELLED: Canceled

> currently, you cannot query image building tasks in all statuses by default when the parameter value is empty.', position='Query'),
}

model DescribeImagePipelineExecutionsResponseBody = {
  nextToken?: string(name='NextToken', description='The Token returned by this call. For more information, see API description.'),
  requestId?: string(name='RequestId', description='The ID of the request.'),
  totalCount?: int32(name='TotalCount', description='The number of returned image components.'),
  maxResults?: int32(name='MaxResults', description='The number of entries to return on each page.'),
  imagePipelineExecution?: {
    imagePipelineExecutionSet?: [ 
    {
      creationTime?: string(name='CreationTime', description='The creation time of the image build task.'),
      imagePipelineId?: string(name='ImagePipelineId', description='The ID of the image template.'),
      status?: string(name='Status', description='The status of the image build task. Possible values:

-BUILDING: BUILDING
-DISTRIBUTING: DISTRIBUTING
-RELEASING: resources are being recycled
-SUCCESS: Successful
-FAILED: FAILED.
-CANCELLING: Canceling
-CANCELLED: Canceled'),
      modifiedTime?: string(name='ModifiedTime', description='The time when the task was last updated.'),
      resourceGroupId?: string(name='ResourceGroupId', description='The ID of the enterprise resource group.'),
      message?: string(name='Message', description='The execution result.'),
      imageId?: string(name='ImageId', description='The ID of the target image.'),
      executionId?: string(name='ExecutionId', description='The ID of the build task.'),
      tags?: {
        tag?: [ 
        {
          tagValue?: string(name='TagValue', description='The value of the tag.'),
          tagKey?: string(name='TagKey', description='The key of the tag.'),
        }
      ](name='Tag')
      }(name='Tags', description='The list of key-value pairs.'),
    }
  ](name='ImagePipelineExecutionSet')
  }(name='ImagePipelineExecution', description='The list of the details of the image build task.'),
}

model DescribeImagePipelineExecutionsResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeImagePipelineExecutionsResponseBody(name='body'),
}

/**
 * ## API description

-The specified image template ID"ImagePipelineId" cannot be a deleted image template. The deleted image template deletes the corresponding build task simultaneously.
-The image template ID"ImagePipelineId" and build task ID"ExecutionId" cannot be empty at the same time.
-You can set the "NextToken" query Token to the value of the "NextToken" parameter returned by the last call to "DescribeImagePipelineExecutions", and then set the maximum number of entries for a single-page query through "maxresule.
 */
async function describeImagePipelineExecutions(request: DescribeImagePipelineExecutionsRequest): DescribeImagePipelineExecutionsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeImagePipelineExecutions', 'POST', 'undefined', 'json', false, 'none', request);
}

model CreateNatGatewayRequest {
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  vpcId?: string(name='VpcId', position='Query'),
  name?: string(name='Name', position='Query'),
  description?: string(name='Description', position='Query'),
  clientToken?: string(name='ClientToken', position='Query'),
  bandwidthPackage?: [ 
    {
      bandwidth?: int32(name='Bandwidth'),
      zone?: string(name='Zone'),
      ipCount?: int32(name='IpCount'),
    }
  ](name='BandwidthPackage', position='Query'),
}

model CreateNatGatewayResponseBody = {
  natGatewayId?: string(name='NatGatewayId'),
  requestId?: string(name='RequestId'),
  forwardTableIds?: {
    forwardTableId?: [ string ](name='ForwardTableId')
  }(name='ForwardTableIds'),
  bandwidthPackageIds?: {
    bandwidthPackageId?: [ string ](name='BandwidthPackageId')
  }(name='BandwidthPackageIds'),
}

model CreateNatGatewayResponse = {
  headers: map[string]string(name='headers'),
  body: CreateNatGatewayResponseBody(name='body'),
}

async function createNatGateway(request: CreateNatGatewayRequest): CreateNatGatewayResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateNatGateway', 'POST', 'undefined', 'json', false, 'none', request);
}

model DescribeEniMonitorDataRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', description='The ID of the RAM user.', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='The account name of the resource master account.', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', description='The ID of the resource master account, that is, the UID.', position='Query'),
  regionId?: string(name='RegionId', description='The ID of the region. You can call [DescribeRegions](~~ 25609 ~~) to view the latest region list.', position='Query'),
  instanceId?: string(name='InstanceId', description='The ID of the instance to which the secondary Eni is bound.', position='Query'),
  eniId?: string(name='EniId', description='The ID of the secondary Eni. By default, all secondary Enis associated with a specified instance are queried.', position='Query'),
  endTime?: string(name='EndTime', description='The end of the time range to query data. The time follows the [ISO8601](~~ 25696 ~~) standard and uses UTC +0. The format is yyyy-MM-ddTHH:mm:ssZ. If the specified seconds (ss) is not 00, it is automatically converted to the next minute.', position='Query'),
  startTime?: string(name='StartTime', description='The start time of obtaining data. The time follows the [ISO8601](~~ 25696 ~~) standard and uses UTC +0. The format is yyyy-MM-ddTHH:mm:ssZ. If the specified seconds (ss) is not 00, it is automatically converted to the next minute.', position='Query'),
  period?: int32(name='Period', description='The interval between obtaining monitoring data. Unit: seconds. Valid values:
-60
-600
-3600

Default value: 60', position='Query'),
}

model DescribeEniMonitorDataResponseBody = {
  totalCount?: int32(name='TotalCount', description='The number of returned entries.'),
  requestId?: string(name='RequestId', description='The ID of the request.'),
  monitorData?: {
    eniMonitorData?: [ 
    {
      packetRx?: string(name='PacketRx', description='The internal network packets received by the secondary Eni. Unit: packets.'),
      timeStamp?: string(name='TimeStamp', description='The timestamp used to query monitoring information. The time follows the ISO 8601 standard and uses UTC +0. The format is yyyy-MM-ddTHH:mm:ssZ.'),
      dropPacketRx?: string(name='DropPacketRx', description='The secondary Eni receives discarded intranet packets. Unit: packets.'),
      eniId?: string(name='EniId', description='The ID of the secondary Eni.'),
      dropPacketTx?: string(name='DropPacketTx', description='The discarded intranet packets sent by the secondary Eni. Unit: packets.'),
      packetTx?: string(name='PacketTx', description='The internal network packets sent by the secondary Eni. Unit: packets.'),
      intranetTx?: string(name='IntranetTx', description='The internal network traffic sent by the secondary Eni. Unit: kbits.'),
      intranetRx?: string(name='IntranetRx', description='The internal network traffic that the secondary Eni receives. Unit: kbits.'),
    }
  ](name='EniMonitorData')
  }(name='MonitorData', description='A collection of monitoring data EniMonitorDataType of secondary Nic traffic.'),
}

model DescribeEniMonitorDataResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeEniMonitorDataResponseBody(name='body'),
}

/**
 * ## API description

The traffic information of the secondary Eni can be queried, including the number of packets sent and received by the secondary Eni, inbound and outbound traffic over the internal network, and the number of packets lost and received by the secondary Eni. When the returned information is missing, the system may not obtain the corresponding information. For example, if the instance is in the Stopped (Stopped) state or the secondary Eni is not attached to the instance, the instance is in the Available (Available) state, and the corresponding information cannot be obtained. When you call this operation, note that:

-A maximum of 400 monitoring data records can be returned at a time. If the specified parameter (EndTime - StartTime)/Peroid>400, an error is returned.

-You can query the monitoring information in the last 30 days at a time. If the specified parameter StartTime more than 30 days, an error is returned.
 */
async function describeEniMonitorData(request: DescribeEniMonitorDataRequest): DescribeEniMonitorDataResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeEniMonitorData', 'POST', 'undefined', 'json', false, 'none', request);
}

model ExportSnapshotRequest {
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  snapshotId?: string(name='SnapshotId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  ossBucket?: string(name='OssBucket', position='Query'),
  roleName?: string(name='RoleName', position='Query'),
}

model ExportSnapshotResponseBody = {
  taskId?: string(name='TaskId'),
  requestId?: string(name='RequestId'),
}

model ExportSnapshotResponse = {
  headers: map[string]string(name='headers'),
  body: ExportSnapshotResponseBody(name='body'),
}

async function exportSnapshot(request: ExportSnapshotRequest): ExportSnapshotResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ExportSnapshot', 'POST', 'undefined', 'json', false, 'none', request);
}

model PurchaseReservedInstancesOfferingRequest {
  tag?: [ 
    {
      key?: string(name='Key', description='预留实例券的标签键。'),
      value?: string(name='Value', description='预留实例券的标签值。'),
    }
  ](name='Tag', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group.', position='Query'),
  instanceType?: string(name='InstanceType', description='The type of the instance. For more information, see [instance type family](~~ 25378 ~~).', position='Query'),
  instanceAmount?: int32(name='InstanceAmount', description='Reserved Instances can match the number of pay-as-you-go instances of the same specification. Valid values: 1 to 50.

For example, if the instance type is set to ecs.g5.large and the number of reserved instances is set to 3, the reserved instance can match three pay-as-you-go instances of ecs.g5.large at the same time.', position='Query'),
  periodUnit?: string(name='PeriodUnit', description='The unit of the subscription period. Valid values: Year', position='Query'),
  clientToken?: string(name='ClientToken', description='Ensure the idempotence of the request. Generate a parameter value from your client. Make sure that the value is unique among different requests. **ClientToken** supports only ASCII characters and cannot exceed 64 characters. For more information, see [how to ensure idempotence](~~ 25693 ~~).', position='Query'),
  description?: string(name='Description', description='The description of the reserved instance. The description must be 2 to 256 characters in length and cannot start with http:// or https.

Default value: Null.', position='Query'),
  reservedInstanceName?: string(name='ReservedInstanceName', description='The name of the reserved instance. The description must be 2 to 128 characters in length. It must start with a letter and cannot start with http:// or https. It can contain numbers, colons (:), underscores (_), and hyphens (-).', position='Query'),
  offeringType?: string(name='OfferingType', description='The Payment type of the reserved instance. Valid values:

-No Upfront: zero prepaid
-Partial Upfront: Partial prepaid
-All Upfront (default): Full prepaid', position='Query'),
  regionId?: string(name='RegionId', description='The ID of the region to which the instance belongs. You can call [DescribeRegions](~~ 25609 ~~) to view the latest region list.', position='Query'),
  platform?: string(name='Platform', description='The operating system type of the image used by the instance. Valid values:

-Windows:Windows Server-type operating system.
-Linux (default):Linux and Unix-like operating systems.', position='Query'),
  zoneId?: string(name='ZoneId', description='The ID of the zone to which the instance belongs. This parameter is required when "Scope" is "Zone. For more information, see [DescribeZones](~~ 25610 ~~) for a list of zones.', position='Query'),
  period?: int32(name='Period', description='The duration of the reserved instance. Valid values:{1, 3}.

Default value: 1.', position='Query'),
  scope?: string(name='Scope', description='The range of Reserved Instances. Valid values:

-Region: Region
-Zone: Zone

Default value: Region', position='Query'),
}

model PurchaseReservedInstancesOfferingResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.'),
  reservedInstanceIdSets?: {
    reservedInstanceId?: [ string ](name='ReservedInstanceId')
  }(name='ReservedInstanceIdSets'),
}

model PurchaseReservedInstancesOfferingResponse = {
  headers: map[string]string(name='headers'),
  body: PurchaseReservedInstancesOfferingResponseBody(name='body'),
}

/**
 * ## API description

-Make sure that you have fully understood the billing method of Reserved instances before using this operation. For more information, see [billing methods for Reserved Instances](~~ 100371 ~~).

-Before purchasing a reserved instance, you can call [DescribeAvailableResource](~~ 66186 ~~) to query available instance resources.
 */
async function purchaseReservedInstancesOffering(request: PurchaseReservedInstancesOfferingRequest): PurchaseReservedInstancesOfferingResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'PurchaseReservedInstancesOffering', 'POST', 'undefined', 'json', false, 'none', request);
}

model DescribeEipAddressesRequest {
  filter?: [
    {
      key?: string(name='Key', position=''),
      value?: string(name='Value', position=''),
    }
  ](name='Filter'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  status?: string(name='Status', position='Query'),
  eipAddress?: string(name='EipAddress', position='Query'),
  allocationId?: string(name='AllocationId', position='Query'),
  ISP?: string(name='ISP', position='Query'),
  pageNumber?: int32(name='PageNumber', position='Query'),
  pageSize?: int32(name='PageSize', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  lockReason?: string(name='LockReason', position='Query'),
  associatedInstanceType?: string(name='AssociatedInstanceType', position='Query'),
  associatedInstanceId?: string(name='AssociatedInstanceId', position='Query'),
  chargeType?: string(name='ChargeType', position='Query'),
}

model DescribeEipAddressesResponseBody = {
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  pageNumber?: int32(name='PageNumber'),
  totalCount?: int32(name='TotalCount'),
  eipAddresses?: {
    eipAddress?: [ 
    {
      status?: string(name='Status'),
      allocationTime?: string(name='AllocationTime'),
      chargeType?: string(name='ChargeType'),
      instanceId?: string(name='InstanceId'),
      instanceType?: string(name='InstanceType'),
      regionId?: string(name='RegionId'),
      ipAddress?: string(name='IpAddress'),
      bandwidth?: string(name='Bandwidth'),
      expiredTime?: string(name='ExpiredTime'),
      allocationId?: string(name='AllocationId'),
      internetChargeType?: string(name='InternetChargeType'),
      eipBandwidth?: string(name='EipBandwidth'),
      operationLocks?: {
        lockReason?: [ 
        {
          lockReason?: string(name='LockReason'),
        }
      ](name='LockReason')
      }(name='OperationLocks'),
    }
  ](name='EipAddress')
  }(name='EipAddresses'),
}

model DescribeEipAddressesResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeEipAddressesResponseBody(name='body'),
}

async function describeEipAddresses(request: DescribeEipAddressesRequest): DescribeEipAddressesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeEipAddresses', 'POST', 'undefined', 'json', false, 'none', request);
}

model RevokeSecurityGroupEgressRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='The account name of the resource master account.', position='Query'),
  ownerId?: long(name='OwnerId', description='The ID of the RAM user.', position='Query'),
  ipv6DestCidrIp?: string(name='Ipv6DestCidrIp', description='The Destination IPv6 CIDR block to which you want to revoke access permissions. CIDR and IPv6 IP addresses are supported.

> only VPC-type IP addresses are supported.

Default value: None', position='Query'),
  destCidrIp?: string(name='DestCidrIp', description='The Destination IPv4 CIDR block to which you want to revoke access permissions. CIDR and IPv4 IP addresses are supported.

Default value: None', position='Query'),
  ipProtocol?: string(name='IpProtocol', description='The transport layer protocol. Case insensitive. Valid values:

-icmp
-gre
-tcp
-udp
-all: all protocols are supported.', position='Query'),
  securityGroupId?: string(name='SecurityGroupId', description='The ID of the source security group.', position='Query'),
  destGroupOwnerId?: long(name='DestGroupOwnerId', description='The ID of the Alibaba Cloud account to which the destination security group belongs when you delete a security group rule across accounts.

-If "DestGroupOwnerId" and "DestGroupOwnerAccount" are not set, the access permission of other security groups is revoked.
-If you have set the "DestCidrIp" parameter, the "DestGroupOwnerId" parameter is invalid.
', position='Query'),
  destGroupOwnerAccount?: string(name='DestGroupOwnerAccount', description='The Alibaba Cloud account to which the destination security group belongs when you delete a security group rule across accounts.

-If "DestGroupOwnerAccount" and "DestGroupOwnerId" are not set, the access permission of other security groups is revoked.
-If the "DestCidrIp" parameter is set, the "DestGroupOwnerAccount" parameter is invalid.
', position='Query'),
  regionId?: string(name='RegionId', description='The region ID of the source security group. You can call [DescribeRegions](~~ 25609 ~~) to view the latest region list.', position='Query'),
  policy?: string(name='Policy', description='The access permission. Valid values:

-accept: Accepts access.
-drop: denies access and does not send back the deny message.

Default value: accept', position='Query'),
  sourceCidrIp?: string(name='SourceCidrIp', description='The range of source IP addresses. CIDR and IPv4 IP addresses are supported.

Default value: None', position='Query'),
  priority?: string(name='Priority', description='The priority of the security group rule. Valid values: 1 to 100.

Default value: 1.', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', description='The ID of the resource master account, that is, the UID.', position='Query'),
  ipv6SourceCidrIp?: string(name='Ipv6SourceCidrIp', description='The source IPv6 CIDR block. CIDR and IPv6 IP addresses are supported.


Default value: None

> only VPC-type IP addresses are supported.', position='Query'),
  sourcePortRange?: string(name='SourcePortRange', description='The range of ports related to the transport layer protocol opened by the source security group. Valid values:

-TCP/UDP: valid values: 1 to 65535. Use a slash (/) to separate the start port from the end port. Example: 1/200
-ICMP:-1/-1
-GRE protocol:-1/-1
-all:-1/-1', position='Query'),
  clientToken?: string(name='ClientToken', description='Ensure the idempotence of the request. Generate a parameter value from your client. Make sure that the value is unique among different requests. **ClientToken** supports only ASCII characters and cannot exceed 64 characters. For more information, see [how to ensure idempotence](~~ 25693 ~~).', position='Query'),
  portRange?: string(name='PortRange', description='The port range related to the transport layer protocol opened by the destination security group. Valid values:

-TCP/UDP: valid values: 1 to 65535. Use a slash (/) to separate the start port from the end port. Example: 1/200
-ICMP:-1/-1
-GRE protocol:-1/-1
-all:-1/-1', position='Query'),
  nicType?: string(name='NicType', description='The NIC type of the classic network security group rule. Valid values:

-internet: internet Nic
-intranet: intranet Nic

Default value: internet

In the following cases, the parameter NicType can only be set to intranet:
-You do not need to set the Nic type for VPC-type security group rules. The default value is intranet, which can only be intranet.
-When the security group is configured to access each other, that is, only the "DestGroupId" parameter is specified, it can only be intranet.

', position='Query'),
  description?: string(name='Description', description='The description of the security group rule.', position='Query'),
  destPrefixListId?: string(name='DestPrefixListId', description='The list of destination prefixes to be revoked. You can call [DescribePrefixLists](~~ 205046 ~~) to query the list IDs of available prefixes.

Note:

-If the network type of a security group is classic network, the prefix list cannot be set. For more information about security groups and Prefix List restrictions, see [Security Group restrictions](~~ 25412#SecurityGroupQuota1 ~~).
-If you specify one of the "DestCidrIp", "Ipv6DestCidrIp", and "DestGroupId" parameters, this parameter is ignored.', position='Query'),
  destGroupId?: string(name='DestGroupId', description='The ID of the destination security group to which you want to revoke access permissions. Set at least one of the "DestGroupId" or "DestCidrIp" parameters.

-If "DestGroupId" is specified but "DestCidrIp" is not specified, the value of "NicType" can only be intranet.
-If both "DestGroupId" and "DestCidrIp" are specified, the default value is "DestCidrIp.', position='Query'),
}

model RevokeSecurityGroupEgressResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.'),
}

model RevokeSecurityGroupEgressResponse = {
  headers: map[string]string(name='headers'),
  body: RevokeSecurityGroupEgressResponseBody(name='body'),
}

/**
 * ## API description

In the API document of the security group, the initiator of the traffic is the Source and the receiver of the data transmission is the Dest.

-A security group rule can be determined by any of the following parameters. A security group rule cannot be determined by specifying only one parameter.

-Revoke the access permission to a specified CIDR block, such as the following request example: IpProtocol, PortRange, (optional) SourcePortRange, NicType, Policy, (optional) SourceCidrIp, and DestCidrIp.

"""
https://ecs.aliyuncs.com/? Action=RevokeSecurityGroupEgress
&SecurityGroupId=sg-bp67acfmxazb4ph ***
&IpProtocol=tcp
&DestCidrIp=10.0.0.0/8
&PortRange=-22/22
&NicType=intranet
&Policy=accept
& <common request parameters>
"""

-Revoke access permissions to other security groups, such as IpProtocol, PortRange, (optional) SourcePortRange, NicType, Policy, (optional) SourceCidrIp, and DestGroupId.

"""
https://ecs.aliyuncs.com/? Action=RevokeSecurityGroupEgress
&SecurityGroupId=sg-bp67acfmxazb4ph ***
&DestGroupId=sg-bp67acfmxa123b ****
&IpProtocol=tcp
&PortRange=22/22
&NicType=intranet
&Policy=accept
& <common request parameters>
"""
-Revokes security group rules associated with the prefix list. For example, IpProtocol, PortRange, (optional) SourcePortRange, NicType, Policy, (optional) SourceCidrIp, and DestPrefixListId.

"""
https://ecs.aliyuncs.com/? Action=RevokeSecurityGroupEgress
&SecurityGroupId=sg-bp67acfmxazb4ph ***
&IpProtocol=tcp
&DestPrefixListId=pl-x1j1k5ykzqlixdcy ****
&PortRange=-22/22
&NicType=intranet
&Policy=accept
& <common request parameters>
"""

-If the specified security group rule does not exist, the RevokeSecurityGroupEgress is called successfully, but no rules are deleted.
 */
async function revokeSecurityGroupEgress(request: RevokeSecurityGroupEgressRequest): RevokeSecurityGroupEgressResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'RevokeSecurityGroupEgress', 'POST', 'undefined', 'json', false, 'none', request);
}

model ActivateRouterInterfaceRequest {
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  routerInterfaceId?: string(name='RouterInterfaceId', position='Query'),
}

model ActivateRouterInterfaceResponseBody = {
  requestId?: string(name='RequestId'),
}

model ActivateRouterInterfaceResponse = {
  headers: map[string]string(name='headers'),
  body: ActivateRouterInterfaceResponseBody(name='body'),
}

async function activateRouterInterface(request: ActivateRouterInterfaceRequest): ActivateRouterInterfaceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ActivateRouterInterface', 'POST', 'undefined', 'json', false, 'none', request);
}

model CreatePrefixListRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  entry?: [ 
    {
      description?: string(name='Description', description='前缀列表条目的描述信息。长度为2~32个英文或中文字符，不能以`http://`和`https://`开头。N的取值范围：0~200。'),
      cidr?: string(name='Cidr', description='前缀列表条目的CIDR地址块信息。N的取值范围：0~200。注意事项：

- 前缀列表的条目数量不能大于最大条目容量（`MaxEntries`）。
- 条目中的CIDR地址块类型根据地址族决定，一个前缀列表不能同时包含IPv4和IPv6的CIDR地址块。
- 多个条目中的CIDR地址块不能重复。例如，您不能设置两个192.168.1.0/24。
- 支持设置单IP地址，系统会自动转换为CIDR地址块。例如，您设置192.168.1.100，系统会自动转换成192.168.1.100/32。
- 如果使用IPv6 CIDR地址块，系统会自动转换成零压缩表示形式且字母转换为小写。例如，您设置2001:0DB8:0000:0000:0000:0000:0000:0000/32，系统会自动转换成2001:db8::/32。

<props="china">关于CIDR地址块的详细信息，请参见[什么是CIDR](https://help.aliyun.com/knowledge_detail/40637.html#title-gu4-uzk-12r)。</props>

<props="intl">关于CIDR地址块的详细信息，请参见[什么是CIDR](https://www.alibabacloud.com/help/doc-detail/40637.htm#title-gu4-uzk-12r)。</props>

<props="partner">关于CIDR地址块的详细信息，请参见[什么是CIDR](https://partners-intl.aliyun.com/help/doc-detail/40637.htm#title-gu4-uzk-12r)。</props>


默认值：空'),
    }
  ](name='Entry', position='Query'),
  regionId?: string(name='RegionId', description='The ID of the region.', position='Query'),
  addressFamily?: string(name='AddressFamily', description='The address family of the prefix list. Valid values:

-IPv4
-IPv6', position='Query'),
  clientToken?: string(name='ClientToken', description='Ensure the idempotence of the request. Generate a parameter value from your client. Make sure that the value is unique among different requests. "ClientToken" only supports ASCII characters and cannot exceed 64 characters in length. For more information, see [how to ensure idempotence](~~ 25693 ~~).', position='Query'),
  description?: string(name='Description', description='The description of the prefix list. The description must be 2 to 256 characters in length and cannot start with "http:// "or "https.', position='Query'),
  maxEntries?: int32(name='MaxEntries', description='The maximum number of entries supported by the prefix list. Valid values: 1 to 200.', position='Query'),
  prefixListName?: string(name='PrefixListName', description='The name of the prefix list. The description must be 2 to 128 characters in length. It must start with a letter and cannot start with "http:// ", "https://", "com.aliyun", or "com.alibabacloud. It can contain letters, digits, colons (:), underscores (_), periods (.), and hyphens (-).', position='Query'),
}

model CreatePrefixListResponseBody = {
  prefixListId?: string(name='PrefixListId', description='The ID of the prefix list.'),
  requestId?: string(name='RequestId', description='The ID of the request.'),
}

model CreatePrefixListResponse = {
  headers: map[string]string(name='headers'),
  body: CreatePrefixListResponseBody(name='body'),
}

/**
 * ## API description

-The Prefix List is a collection of network prefixes (CIDR block). You can reference the prefix list when configuring network rules for other resources. For more information about the prefix list, see [Prefix List Overview](~~ 206223 ~~).

-Currently, only some regions support the prefix list function.

-When creating a prefix list:

-You must specify an address family (IPv4 or IPv6) for the prefix list. Entries in the same prefix list can only belong to the same address family and cannot be modified after the address family is created.
-You must set the maximum number of entries for the prefix list and cannot modify it after it is created.
-You can specify a number of entries for the prefix list. The entries consist of CIDR blocks and descriptions. The number of entries cannot exceed the maximum number of entries you set.

-For more information about restrictions on prefix lists and other resources, see [limits](~~ 25412 ~~).

-RAM users allow you to avoid sharing Alibaba Cloud account keys with other users and assign minimum permissions to users on demand, thus reducing information security risks. For more information about how to grant permissions related to the prefix list to a RAM user, see [Grant permissions related to the prefix list to a RAM user](~~ 206175 ~~).
 */
async function createPrefixList(request: CreatePrefixListRequest): CreatePrefixListResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreatePrefixList', 'POST', 'undefined', 'json', false, 'none', request);
}

model DescribeSpotPriceHistoryRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='The account name of the resource master account.', position='Query'),
  ownerId?: long(name='OwnerId', description='The ID of the RAM user.', position='Query'),
  instanceType?: string(name='InstanceType', description='The instance type.', position='Query'),
  zoneId?: string(name='ZoneId', description='The ID of the zone.', position='Query'),
  regionId?: string(name='RegionId', description='The ID of the region to which the instance belongs. You can call [DescribeRegions](~~ 25609 ~~) to view the latest region list.', position='Query'),
  networkType?: string(name='NetworkType', description='The network type of the preemptible instance. Valid values:

-classic: indicates that the network type of the preemptible instance is classic.

-vpc: indicates that the network type of the preemptible instance is vpc.', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', description='The ID of the resource master account, that is, the UID.', position='Query'),
  spotDuration?: int32(name='SpotDuration', description='The retention period of a preemptible instance. Unit: hours. Valid values: 0 to 6.

-The retention period is 2 to 6 and is being invited for testing. If you want to activate the service, submit a ticket.
-If the value is 0, the mode is not protected.

Default value: 1.', position='Query'),
  OSType?: string(name='OSType', description='The release platform type of the operating system. Valid values:

-linux
-Windows', position='Query'),
  offset?: int32(name='Offset', description='The start row of the query.

Default value: 0.', position='Query'),
  startTime?: string(name='StartTime', description='The start time for querying the historical price of a preemptible instance. The time follows the [ISO8601](~~ 25696 ~~) standard and uses UTC +0. The format is "yyyy-MM-ddTHH:mm:ssZ ".

Default value: NULL. Null indicates the first 3 hours of the end time. The maximum value cannot exceed 30 days.', position='Query'),
  endTime?: string(name='EndTime', description='Query the end time of the historical price of a preemptible instance. The time follows the [ISO8601](~~ 25696 ~~) standard and uses UTC +0. The format is "yyyy-MM-ddTHH:mm:ssZ ".

Default value: NULL. Null indicates the current time.', position='Query'),
  ioOptimized?: string(name='IoOptimized', description='Indicates whether the instance is I/O optimized. Valid values:

-optimized: indicates that the preemptible instance is an I/O optimized instance.

-none: indicates that the preemptible instance is not I/O optimized.

Default value: none

Default value for other instance families: optimized', position='Query'),
}

model DescribeSpotPriceHistoryResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.'),
  currency?: string(name='Currency', description='The monetary unit of the price.'),
  nextOffset?: int32(name='NextOffset', description='The start line of the next page to query the data on the next page. The value of the "Offset" parameter is specified.'),
  spotPrices?: {
    spotPriceType?: [ 
    {
      ioOptimized?: string(name='IoOptimized', description='Indicates whether the preemptible instance is an I/O optimized instance.'),
      zoneId?: string(name='ZoneId', description='The ID of the zone to which the preemptible instance belongs.'),
      spotPrice?: float(name='SpotPrice', description='The price of a preemptible instance.'),
      timestamp?: string(name='Timestamp', description='The time format is "yyyy-MM-ddTHH:mm:ssZ.'),
      networkType?: string(name='NetworkType', description='The network type of the preemptible instance.'),
      instanceType?: string(name='InstanceType', description='The instance type of the preemptible instance.'),
      originPrice?: float(name='OriginPrice', description='Quantity pay instances section original price.'),
    }
  ](name='SpotPriceType')
  }(name='SpotPrices', description='Preemptible price details.'),
}

model DescribeSpotPriceHistoryResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeSpotPriceHistoryResponseBody(name='body'),
}

async function describeSpotPriceHistory(request: DescribeSpotPriceHistoryRequest): DescribeSpotPriceHistoryResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeSpotPriceHistory', 'POST', 'undefined', 'json', false, 'none', request);
}

model ModifySoftDeletedCoolingTimeRequest {
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  clientToken?: string(name='ClientToken', position='Query'),
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  hours?: long(name='Hours', position='Query'),
}

model ModifySoftDeletedCoolingTimeResponseBody = {
  requestId?: string(name='RequestId', description='Id of the request'),
}

model ModifySoftDeletedCoolingTimeResponse = {
  headers: map[string]string(name='headers'),
  body: ModifySoftDeletedCoolingTimeResponseBody(name='body'),
}

async function modifySoftDeletedCoolingTime(request: ModifySoftDeletedCoolingTimeRequest): ModifySoftDeletedCoolingTimeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifySoftDeletedCoolingTime', 'POST', 'undefined', 'json', false, 'none', request);
}

model RestoreSoftDeletedInstancesRequest {
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  instanceId?: [ string ](name='InstanceId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  clientToken?: string(name='ClientToken', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  ownerId?: long(name='OwnerId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  attemptStartVm?: boolean(name='AttemptStartVm', position='Query'),
}

model RestoreSoftDeletedInstancesResponseBody = {
  requestId?: string(name='RequestId'),
}

model RestoreSoftDeletedInstancesResponse = {
  headers: map[string]string(name='headers'),
  body: RestoreSoftDeletedInstancesResponseBody(name='body'),
}

async function restoreSoftDeletedInstances(request: RestoreSoftDeletedInstancesRequest): RestoreSoftDeletedInstancesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'RestoreSoftDeletedInstances', 'POST', 'undefined', 'json', false, 'none', request);
}

model StopInstanceRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  hibernate?: boolean(name='Hibernate', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', description='The ID of the resource master account, that is, the UID.', position='Query'),
  forceStop?: boolean(name='ForceStop', description='Specifies whether to disable the instance. Valid values:

-true: forced shutdown.
-false: the shutdown process is normal.

Default value: false
', position='Query'),
  stoppedMode?: string(name='StoppedMode', description='The stop mode that you set when you stop a pay-as-you-go ECS instance. Valid values:

-StopCharging: reduces downtime. For more information about the conditions for "StopCharging" to take effect, see The enable conditions section of [pay-as-you-go instance shutdown mode](~~ 63353 ~~).
-KeepCharging: normal shutdown mode. The instance continues to be billed after it is stopped.

default value: if you enable the VPC instance shutdown mode in the ECS console (For more information, see [enable default shutdown mode](~~ 63353#default ~~)), the default value is stopcharging ". Otherwise, the default value is keepcharging ".', position='Query'),
  dryRun?: boolean(name='DryRun', description='Specifies whether to PreCheck only this request. Valid values:

-true: sends a check request and does not stop the instance. Check items include required parameters, request format, business restrictions, and ECS inventory. If the check fails, the corresponding error is returned. If the check succeeds, the error code "DryRunOperation" is returned ".

-false: Sends a normal request and stops the instance after passing the check.

Default value: false', position='Query'),
  instanceId?: string(name='InstanceId', description='The ID of the instance.', position='Query'),
  confirmStop?: boolean(name='ConfirmStop', description='Indicates whether the instance is powered off. This parameter takes effect only for instance families of type i1 and is required for instance families of type i1.

Default value: false', position='Query'),
}

model StopInstanceResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.'),
}

model StopInstanceResponse = {
  headers: map[string]string(name='headers'),
  body: StopInstanceResponseBody(name='body'),
}

/**
 * ## API description

-When the "OperationLocks" parameter of a locked ECS instance contains "LockReason": "security", the instance cannot be stopped. For more information, see [API actions for security lock](~~ 25695 ~~).

-Stop the local SSD instance family:

-For [i1 instance family](~~ 25378#i1 ~~) with [local disk](~~ 63138 ~~), "ConfirmStop" is required, the API call is successful only when the value is "true". Otherwise, an error code is returned.

-After the API is called, the data on the local disk is cleared. You must use data redundancy at the application layer to ensure data availability.

-ECS automatically ignores the "ConfirmStop" request parameters of other instance type families.

-After the VPC instance shutdown mode is enabled, you can enable the normal shutdown mode by setting "StoppedMode = KeepCharging". After the ECS instance is stopped, the billing continues, the ECS instance type inventory and public IP address are retained.
 */
async function stopInstance(request: StopInstanceRequest): StopInstanceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'StopInstance', 'POST', 'undefined', 'json', false, 'none', request);
}

model CreateSnapshotGroupRequest {
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  instanceId?: string(name='InstanceId', description='The ID of the instance.', position='Query'),
  regionId?: string(name='RegionId', description='The ID of the region to which the instance belongs. You can call [DescribeRegions](~~ 25609 ~~) to view the latest region list.', position='Query'),
  instantAccess?: boolean(name='InstantAccess', description='Specifies whether to enable quick snapshot availability. Valid values:

-true: enabled
-false: Disabled

Default value: false', position='Query'),
  name?: string(name='Name', description='The name of the ECS instance snapshot. The description must be 2 to 128 characters in length. It must start with a letter and cannot start with "http:// "or "https://". It can contain numbers and periods (.)., underscores (_), hyphens (-), or colons (:).', position='Query'),
  instantAccessRetentionDays?: int32(name='InstantAccessRetentionDays', description='Set the maximum available time of a snapshot. Unit: Days. Valid values: 1 to 65535.

This parameter takes effect only when "InstantAccess = true. The quick snapshot feature is automatically disabled upon expiration.

Default value: null, indicating that the snapshot release time is the same as that of the snapshot.', position='Query'),
  description?: string(name='Description', description='The description. The description must be 2 to 256 characters in length and cannot start with "http:// "or "https.', position='Query'),
  excludeDiskId?: [ string ](name='ExcludeDiskId', description='The ID of the disk to which you do not need to create snapshots. If the disk ID is specified, the created instance snapshot does not contain the snapshot corresponding to the disk.

Default value: null, indicating that snapshots are created for all cloud disks in the instance.

Valid values of N: 1 to 16.', position='Query'),
}

model CreateSnapshotGroupResponseBody = {
  snapshotGroupId?: string(name='SnapshotGroupId', description='The ID of the instance snapshot.'),
  requestId?: string(name='RequestId', description='The ID of the request.'),
}

model CreateSnapshotGroupResponse = {
  headers: map[string]string(name='headers'),
  body: CreateSnapshotGroupResponseBody(name='body'),
}

/**
 * ## API description

When creating an instance snapshot, note the following:

-The status of the ECS instance is **running**("Running") or **stopped**("Stopped").

-Currently, only ESSD disks are supported and the disk status is **in use** ("in_use").

-A snapshot of an instance can contain up to 10 cloud disks (including system disks and data disks), and the total capacity cannot exceed 32 TiB.

-Snapshots created by you are retained. Delete snapshots that you no longer need on a regular basis to avoid continuous deduction of snapshot capacity.

-You cannot create instance snapshots for disks with multiple mount features enabled. If multiple disks are attached to an instance, you must set the "ExcludeDiskId. **parameter to exclude the disks.

For more information about the features and billing of instance snapshots, see [instance snapshots](~~ 199625 ~~).
 */
async function createSnapshotGroup(request: CreateSnapshotGroupRequest): CreateSnapshotGroupResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateSnapshotGroup', 'POST', 'undefined', 'json', false, 'none', request);
}

model ModifyDiskSpecRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  diskId?: string(name='DiskId', description='The ID of the disk.', position='Query'),
  dryRun?: boolean(name='DryRun', description='Specifies whether to PreCheck only this request. Valid values:

* true: a check request is sent. Check items include required parameters, request format, business restrictions, and ECS inventory. If the check fails, the corresponding error is returned. If the check succeeds, the error code "DryRunOperation" is returned ".

* false: If a normal request is sent, the 2XX HTTP status code is returned after the check, and the cloud disk or ESSD performance level is changed.

Default value: false', position='Query'),
  performanceLevel?: string(name='PerformanceLevel', description='Modifies the performance level of an ESSD. Valid values:

-PL0: The maximum random read/write IOPS per disk is 10,000.
-PL1: The maximum random read/write IOPS per disk is 50,000.
-PL2: The maximum random read/write IOPS per disk is 100,000.
-PL3: The maximum random read/write IOPS per disk is 1 million.

Default value: PL1', position='Query'),
  diskCategory?: string(name='DiskCategory', description='Change the type of a cloud disk. Valid values:

-cloud_essd:ESSD
-cloud_ssd:SSD cloud disk
-cloud_efficiency: Ultra disk

Default value: Null.

> valid values are sorted in descending order of disk performance. If the specified disk is a subscription disk, you cannot downgrade the disk.', position='Query'),
}

model ModifyDiskSpecResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.'),
  taskId?: string(name='TaskId', description='The ID of the task to change the disk configuration.

> This parameter is not returned if you modify the performance level of only one ESSD disk.'),
  orderId?: string(name='OrderId', description='The ID of the generated order.

> The Order ID is returned only when you change or modify a subscription disk.'),
}

model ModifyDiskSpecResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyDiskSpecResponseBody(name='body'),
}

/**
 * ## API description

<props = "china"> make sure that you have fully understood the billing method and [price](https://www.aliyun.com/price/product#/disk/detail) of cloud disks before using this interface. </props>

When you call this operation, note that:

* Modify the performance level of an ESSD:

-You can only upgrade the performance level of a subscription ESSD.

-Pay-as-you-go ESSD supports performance upgrades and downgrades, but cannot be downgraded to pl0.

-ESSD must be in the **in use**(In_Use) or **to be mounted**(Available) state.

-If an ESSD disk is attached to an ECS instance, the instance must be in the **Running**(Running) state or **Stopped**(Stopped) state, the ECS instance cannot be in the expired or overdue status.

-Because the performance level of ESSD is limited by the capacity, if you cannot upgrade the performance level, you can expand ([ResizeDisk](~~ 25522 ~~)) and then re-operate. For more information, see [ESSD](~~ 122389 ~~).

* For more information about how to change the type of a cloud disk, see the limits section in [change the type of a cloud disk](~~ 161980 ~~).

* <props = "china"> cloud disks with multiple mount features cannot be changed. </props>

After you call this operation, the new disk type takes effect immediately. Alibaba Cloud calculates the consumption bill based on the new disk type and the unit price of the disk performance level.

 */
async function modifyDiskSpec(request: ModifyDiskSpecRequest): ModifyDiskSpecResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyDiskSpec', 'POST', 'undefined', 'json', false, 'none', request);
}

model DeletePhysicalConnectionRequest {
  regionId?: string(name='RegionId', position='Query'),
  physicalConnectionId?: string(name='PhysicalConnectionId', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  clientToken?: string(name='ClientToken', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
}

model DeletePhysicalConnectionResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeletePhysicalConnectionResponse = {
  headers: map[string]string(name='headers'),
  body: DeletePhysicalConnectionResponseBody(name='body'),
}

async function deletePhysicalConnection(request: DeletePhysicalConnectionRequest): DeletePhysicalConnectionResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeletePhysicalConnection', 'POST', 'undefined', 'json', false, 'none', request);
}

model ModifyDedicatedHostsChargeTypeRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  dedicatedHostIds?: string(name='DedicatedHostIds', description='The ID of the dedicated host. The value can be a JSON Array consisting of multiple DDH IDs. A maximum of 20 IDs can be entered. Separate IDs with commas (,).', position='Query'),
  periodUnit?: string(name='PeriodUnit', description='The unit of the renewal period. Valid values:
-Week
-Month

Default value: Month', position='Query'),
  clientToken?: string(name='ClientToken', description='Ensure the idempotence of the request. Generate a parameter value from your client. Make sure that the value is unique among different requests. "ClientToken" only supports ASCII characters and cannot exceed 64 characters in length. For more information, see [how to ensure idempotence](~~ 25693 ~~).', position='Query'),
  detailFee?: boolean(name='DetailFee', description='Specifies whether to return the order fee details when the subscription is converted to pay-as-you-go.

Default value: false', position='Query'),
  dedicatedHostChargeType?: string(name='DedicatedHostChargeType', description='The target billing method to be modified for the dedicated host. Valid values:
-PrePaid: converts the pay-as-you-go billing method to subscription.
-PostPaid: convert subscription to pay-as-you-go.

Default value: PrePaid
', position='Query'),
  regionId?: string(name='RegionId', description='The ID of the region to which the dedicated host belongs. You can call [DescribeRegions](~~ 25609 ~~) to view the latest region list.', position='Query'),
  dryRun?: boolean(name='DryRun', description='Specifies whether to PreCheck only this request. Valid values:
-true: sends a check request without querying the resource status. Check whether the AccessKey is valid, whether the RAM user is authorized, and whether required parameters are specified. If the check fails, the corresponding error is returned. If the check succeeds, the error code "DryRunOperation" is returned ".
-false: a normal request is sent. After the request passes the check, the 2XX HTTP status code is returned and the resource status is directly queried.

Default value: false', position='Query'),
  period?: int32(name='Period', description='The subscription duration. Valid values:
-When "PeriodUnit = Week", the valid value of "1" is {1, 2 ,3 ,4}.
-When "$unit = Month", valid values of "$":{1, 2, 3, 4, 5, 6, 7, 8, 9, 12, 24, 36, 48, 60}', position='Query'),
  autoPay?: boolean(name='AutoPay', description='Indicates whether to pay automatically. Valid values:
-true: automatic payment. You must ensure that your account balance is sufficient. If your account balance is insufficient, an abnormal order will be generated and you can only cancel the order.
-false: only generated orders are billed.

Default value: true

> If the balance of your payment method is insufficient, you can set the parameter "AutoPay" to "false". In this case, an unpaid order is generated and you can pay by yourself.

', position='Query'),
}

model ModifyDedicatedHostsChargeTypeResponseBody = {
  orderId?: string(name='OrderId', description='The ID of the generated order.'),
  requestId?: string(name='RequestId', description='The ID of the request.'),
  feeOfInstances?: {
    feeOfInstance?: [ 
    {
      instanceId?: string(name='InstanceId', description='The ID of the dedicated host.'),
      currency?: string(name='Currency', description='The unit of the bill.'),
      fee?: string(name='Fee', description='The value of the fee.'),
    }
  ](name='FeeOfInstance')
  }(name='FeeOfInstances', description='The details of the order fee.'),
}

model ModifyDedicatedHostsChargeTypeResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyDedicatedHostsChargeTypeResponseBody(name='body'),
}

async function modifyDedicatedHostsChargeType(request: ModifyDedicatedHostsChargeTypeRequest): ModifyDedicatedHostsChargeTypeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyDedicatedHostsChargeType', 'POST', 'undefined', 'json', false, 'none', request);
}

model CreateAutoSnapshotPolicyRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  tag?: [ 
    {
      key?: string(name='Key', description='快照的标签键。N的取值范围：1~20。一旦传入该值，则不允许为空字符串。最多支持128个字符，不能以aliyun或acs:开头，不能包含http://或https://。'),
      value?: string(name='Value', description='快照的标签值。N的取值范围：1~20。一旦传入该值，可以为空字符串。最多支持128个字符，不能以acs:开头，不能包含http://或https://。'),
    }
  ](name='Tag', position='Query'),
  autoSnapshotPolicyName?: string(name='autoSnapshotPolicyName', description='The name of the automatic snapshot policy. The description must be 2 to 128 characters in length. It must start with a letter and cannot start with http:// or https. It can contain numbers, colons (:), underscores (_), and hyphens (-).

Default value: Null.', position='Query'),
  enableCrossRegionCopy?: boolean(name='EnableCrossRegionCopy', description='Indicates whether automatic cross-region replication is allowed.
-true: Yes
-false: not allowed', position='Query'),
  timePoints?: string(name='timePoints', description='The time when the automatic snapshot was created. Use UTC +8. Unit: Hour. Valid values: 0 to 23. Valid values: 00:00 to 23:00. For example, 1 indicates 01:00. Format Description:

-The input parameters must remain in the JSON Array format. For example,["1"] indicates that automatic snapshots are created at 01:00.
-If you need to create multiple automatic snapshots in a day, you can specify multiple time points. Separate the time points with commas (,). You can specify a maximum of 24 time points. For example,["1","3", and "5"] indicate that automatic snapshots are created at 01:00, 03:00, and 05:00.', position='Query'),
  regionId?: string(name='regionId', description='The region to which the automatic snapshot policy belongs. You can call [DescribeRegions](~~ 25609 ~~) to view the latest region list.', position='Query'),
  targetCopyRegions?: string(name='TargetCopyRegions', description='Copy the destination region of the snapshot across regions. You can specify a region.', position='Query'),
  copiedSnapshotsRetentionDays?: int32(name='CopiedSnapshotsRetentionDays', description='The retention period of a cross-region snapshot. Unit: days. Valid values:

--1: permanently saved
-1 to 65535: specify the retention period.

Default value:-1', position='Query'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group.', position='Query'),
  retentionDays?: int32(name='retentionDays', description='The retention period of the automatic snapshot. Unit: days. Valid values:

--1: permanently saved
-1 to 65535: specify the retention period.

Default value:-1', position='Query'),
  repeatWeekdays?: string(name='repeatWeekdays', description='The duplicate date of the automatic snapshot. Unit: Day. Cycle: week. Valid values: 1 to 7. For example, 1 indicates Monday. Format Description:

-The input parameters must remain in the JSON Array format. For example,["1"] indicates that automatic snapshots are created every Monday.
-If you need to create multiple automatic snapshots in a week, you can specify multiple time points. Separate the time points with commas (,). A maximum of seven time points can be entered. For example,["1","3","5"] indicates that automatic snapshots are created repeatedly every Monday, Wednesday, and Friday.', position='Query'),
}

model CreateAutoSnapshotPolicyResponseBody = {
  autoSnapshotPolicyId?: string(name='AutoSnapshotPolicyId', description='The ID of the automatic snapshot policy.'),
  requestId?: string(name='RequestId', description='The ID of the request.'),
}

model CreateAutoSnapshotPolicyResponse = {
  headers: map[string]string(name='headers'),
  body: CreateAutoSnapshotPolicyResponseBody(name='body'),
}

/**
 * ## API description

When you call this operation to create an automatic snapshot policy, you can set the automatic snapshot repetition period, retention time, and cross-region backup policies. Meet your diverse data backup requirements. After creating an automatic snapshot policy, you must call [ApplyAutoSnapshotPolicy](~~ 25531 ~~) to apply the policy to the target disk. To adjust the content of an automatic snapshot policy, call [ModifyAutoSnapshotPolicyEx](~~ 25529 ~~).

When you call this operation, note that:

-An Alibaba Cloud account can create up to 100 automatic snapshot policies in a region.

-If the disk data is large and the time interval between two automatic snapshots is exceeded, the next time point is automatically skipped. For example, you have set the automatic snapshot time point to 09:00, 10:00, 11:00, and 12:00. Due to the large amount of disk data, it takes 80 minutes to create a snapshot at 09:00 and create a snapshot at 10:20. The system skips the time point 10:00 and continues to create automatic snapshots for you until 11:00.

-For more information about how to copy snapshots across regions, see the background information section of [copy snapshots](~~ 159441 ~~).
 */
async function createAutoSnapshotPolicy(request: CreateAutoSnapshotPolicyRequest): CreateAutoSnapshotPolicyResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateAutoSnapshotPolicy', 'POST', 'undefined', 'json', false, 'none', request);
}

model DescribeInstancesRequest {
  filter?: [
    {
      value?: string(name='Value', description='The filter value when you query resources. When you specify this parameter, you must specify the "Filter.1.Key" parameter in the format of "yyyy-MM-ddTHH:mmZ", in UTC +0 time zone.', position=''),
      key?: string(name='Key', description='The filter key used to query resources. The value must be "CreationStartTime ". Set "Filter.1.Key" and "Filter.1.Value" to query resource information created after a specified time point.', position=''),
    }
  ](name='Filter'),
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  deviceAvailable?: boolean(name='DeviceAvailable', position='Query'),
  needSaleCycle?: boolean(name='NeedSaleCycle', position='Query'),
  httpPutResponseHopLimit?: int32(name='HttpPutResponseHopLimit', position='Query'),
  tag?: [ 
    {
      key?: string(name='key', description='标签键。

> 为提高兼容性，建议您使用另一个Tag.N.Key参数。'),
      value?: string(name='Value', description='实例的标签值。N的取值范围：1~20'),
    }
  ](name='Tag', position='Query'),
  vpcId?: string(name='VpcId', description='VPC VPC ID.', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', description='The ID of the resource master account, that is, the UID.', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='The account name of the resource master account.', position='Query'),
  vSwitchId?: string(name='VSwitchId', description='The ID of the vSwitch.', position='Query'),
  ownerId?: long(name='OwnerId', description='The ID of the RAM user.', position='Query'),
  instanceIds?: string(name='InstanceIds', description='The ID of the instance. The value can be a JSON Array consisting of multiple instance IDs. A maximum of 100 IDs can be entered. Separate IDs with commas (,).', position='Query'),
  regionId?: string(name='RegionId', description='The ID of the region to which the instance belongs. You can call [DescribeRegions](~~ 25609 ~~) to view the latest region list.', position='Query'),
  zoneId?: string(name='ZoneId', description='The ID of the zone.', position='Query'),
  pageNumber?: int32(name='PageNumber', description='The page number of the instance status list.

Start value: 1

Default value: 1.', position='Query'),
  innerIpAddresses?: string(name='InnerIpAddresses', description='The list of internal IP addresses of classic network instances. This parameter takes effect when "InstanceNetworkType = classic". The value can be a JSON Array consisting of multiple IP addresses. A maximum of 100 IP addresses can be entered. Separate IP addresses with commas (,).', position='Query'),
  instanceNetworkType?: string(name='InstanceNetworkType', description='The network type of the instance. Valid values:

-classic: classic Network
-vpc: VPC', position='Query'),
  maxResults?: int32(name='MaxResults', description='The number of entries to return on each page.

Maximum Value: 100

Default value: 10', position='Query'),
  pageSize?: int32(name='PageSize', description='The number of entries to return on each page.

Maximum Value: 100

Default value: 10', position='Query'),
  nextToken?: string(name='NextToken', description='The Token returned by the last API call.', position='Query'),
  imageId?: string(name='ImageId', description='The ID of the image.', position='Query'),
  instanceTypeFamily?: string(name='InstanceTypeFamily', description='The instance type family.', position='Query'),
  status?: string(name='Status', description='The status of the instance. Valid values:

-Pending: creating
-Running: Running
-Starting: Starting
-Stopping: Stopping
-Stopped: Stopped', position='Query'),
  hpcClusterId?: string(name='HpcClusterId', description='The ID of the HPC cluster to which the instance belongs.', position='Query'),
  securityGroupId?: string(name='SecurityGroupId', description='The security group to which the instance belongs.', position='Query'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group to which the instance belongs. When you use this parameter to filter resources, the number of resources cannot exceed 1,000.', position='Query'),
  instanceType?: string(name='InstanceType', description='The instance type.', position='Query'),
  instanceChargeType?: string(name='InstanceChargeType', description='The billing method of the instance. Valid values:

-PostPaid: pay-as-you-go
-PrePaid: Subscription', position='Query'),
  additionalAttributes?: [ string ](name='AdditionalAttributes', description='Other property values. After you set other properties, the returned value contains the information about this property. Valid values of N: 1 to 20. Valid values:

-META_OPTIONS: instance metadata.
-DDH_CLUSTER: Dedicated host cluster.
-NETWORK_PRIMARY_ENI_IP: the secondary IP address of the primary Eni.', position='Query'),
  publicIpAddresses?: string(name='PublicIpAddresses', description='The list of public IP addresses of the instance. The value can be a JSON Array consisting of multiple IP addresses. A maximum of 100 IP addresses can be entered. Separate IP addresses with commas (,).', position='Query'),
  eipAddresses?: string(name='EipAddresses', description='The list of elastic IP addresses of the instance. This parameter takes effect when "InstanceNetworkType = vpc". The value can be a JSON Array consisting of multiple IP addresses. A maximum of 100 IP addresses can be entered. Separate IP addresses with commas (,).', position='Query'),
  dryRun?: boolean(name='DryRun', description='Specifies whether to PreCheck only this request. Valid values:

-true: sends a check request without querying the resource status. Check whether the AccessKey is valid, whether the RAM user is authorized, and whether required parameters are specified. If the check fails, the corresponding error is returned. If the check succeeds, an error code DryRunOperation is returned.
-false (default): a normal request is sent. After the request passes the check, the 2XX HTTP status code is returned and the resource status is directly queried.', position='Query'),
  instanceName?: string(name='InstanceName', description='The name of the instance. You can use the wildcard * to perform fuzzy search.', position='Query'),
  ioOptimized?: boolean(name='IoOptimized', description='Indicates whether the instance is an I/O optimized instance.', position='Query'),
  privateIpAddresses?: string(name='PrivateIpAddresses', description='The private IP address of the VPC-connected instance. This parameter takes effect when "InstanceNetworkType = vpc". The value can be a JSON Array consisting of multiple IP addresses. A maximum of 100 IP addresses can be entered. Separate IP addresses with commas (,).', position='Query'),
  internetChargeType?: string(name='InternetChargeType', description='The billing method of the Internet bandwidth. Valid values:

-PayByBandwidth: pay-by-bandwidth.
-PayByTraffic: pay by traffic.

> **pay-by-traffic** mode: The peak inbound and outbound bandwidth is the upper limit of the bandwidth and is not used as a service commitment indicator. When a resource scramble occurs, the peak bandwidth may be limited. If your business needs to be guaranteed by bandwidth, use the **pay-by-bandwidth** mode.', position='Query'),
  lockReason?: string(name='LockReason', description='The reason why the resource is locked.', position='Query'),
  keyPairName?: string(name='KeyPairName', description='The name of the SSH key pair used by the instance.', position='Query'),
  httpEndpoint?: string(name='HttpEndpoint', description='Specifies whether to enable the access channel for instance metadata. Valid values:
-enabled: enabled
-disabled: disabled

Default value: enabled
> For more information about instance metadata, see [instance metadata Overview](~~ 49122 ~~).', position='Query'),
  rdmaIpAddresses?: string(name='RdmaIpAddresses', description='The Rdma IP address of the HPC instance.', position='Query'),
  ipv6Address?: [ string ](name='Ipv6Address', description='The IPv6 address of the Eni. N indicates that multiple IPv6 addresses can be set. Valid values of N: 1 to 100.', position='Query'),
  httpTokens?: string(name='HttpTokens', description='Specifies whether to use the enhanced mode (IMDSv2) when accessing instance metadata. Valid values:
-optional: not mandatory.
-required: force use. If this parameter is set, the instance metadata cannot be accessed in normal mode.

Default value: optional.
> For more information about how to access instance metadata, see [instance metadata access mode](~~ 150575 ~~).', position='Query'),
}

model DescribeInstancesResponseBody = {
  nextToken?: string(name='NextToken', description='The query credential value returned by this call.'),
  requestId?: string(name='RequestId', description='The ID of the request.'),
  pageNumber?: int32(name='PageNumber', description='The page number of the instance list.'),
  pageSize?: int32(name='PageSize', description='The number of entries to return on each page.'),
  totalCount?: int32(name='TotalCount', description='The total number of queried instances. If you use the "NextToken" and "maxresule" request parameters for paging query, the returned value is invalid. You can ignore the returned value.'),
  instances?: {
    instance?: [ 
    {
      deploymentSetId?: string(name='DeploymentSetId', description='The ID of the deployment set.'),
      status?: string(name='Status', description='The status of the instance.'),
      serialNumber?: string(name='SerialNumber', description='Instance serial number.'),
      creationTime?: string(name='CreationTime', description='The time when the instance was created. The time follows the ISO 8601 standard and uses UTC +0. The format is yyyy-MM-ddTHH:mmZ. For more information, see [ISO8601](~~ 25696 ~~).'),
      keyPairName?: string(name='KeyPairName', description='The name of the key pair.'),
      saleCycle?: string(name='SaleCycle', description='The billing cycle of the instance.'),
      deviceAvailable?: boolean(name='DeviceAvailable', description='Indicates whether data disks can be attached to the instance.'),
      spotStrategy?: string(name='SpotStrategy', description='The preemptible policy of the preemptible instance. Possible values:

-NoSpot: a pay-as-you-go instance.
-SpotWithPriceLimit: sets the maximum price for preemptible instances.
-SpotAsPriceGo: The system automatically bids at the highest pay-as-you-go price.'),
      localStorageCapacity?: long(name='LocalStorageCapacity', description='The local storage capacity of the instance.'),
      description?: string(name='Description', description='The description of the instance.'),
      instanceName?: string(name='InstanceName', description='The name of the instance.'),
      instanceNetworkType?: string(name='InstanceNetworkType', description='The network type of the instance. Possible values:

-classic
-vpc'),
      spotDuration?: int32(name='SpotDuration', description='The retention period of a preemptible instance. Unit: hours. Valid values: 0 to 6.

-The retention period is 2 to 6 and is being invited for testing. If you want to activate the service, submit a ticket.
-If the value is 0, no protection period is used.'),
      OSNameEn?: string(name='OSNameEn', description='The name of the instance operating system.'),
      memory?: int32(name='Memory', description='The memory size. Unit: MiB.'),
      spotPriceLimit?: float(name='SpotPriceLimit', description='The maximum hourly price of an instance. This parameter takes effect only when "SpotStrategy = spotwithpricelime.'),
      hpcClusterId?: string(name='HpcClusterId', description='The ID of the HPC cluster to which the instance belongs.'),
      OSName?: string(name='OSName', description='The operating system name of the instance.'),
      imageId?: string(name='ImageId', description='The ID of the running image of the instance.'),
      deploymentSetGroupNo?: int32(name='DeploymentSetGroupNo', description='When an ECS instance is deployed in a deployment set, the instance is in the group position of the deployment set.'),
      clusterId?: string(name='ClusterId', description='The ID of the cluster to which the instance belongs.

> This parameter will be deprecated soon. To improve compatibility, try to use other parameters.'),
      vlanId?: string(name='VlanId', description='The VLAN ID of the instance.

> This parameter will be deprecated soon. To improve compatibility, try to use other parameters.'),
      GPUSpec?: string(name='GPUSpec', description='The GPU type that comes with the instance type.'),
      autoReleaseTime?: string(name='AutoReleaseTime', description='The automatic release time of the pay-as-you-go instance.'),
      stoppedMode?: string(name='StoppedMode', description='Specifies whether to continue charging after the instance is stopped. Possible values:

-KeepCharging: normal shutdown mode. You are billed after the instance is stopped.
-StopCharging: reduces downtime. After the instance is stopped, some resources are no longer charged. The details are as follows:
-No fees are charged for computing resources (vCPU and memory).
-The fixed public IP address will be recycled, and the elastic IP address and private IP address will remain.
-Fees for cloud disks (system disks and data disks) continue to be charged.
-Continue charging for elastic IP addresses and bandwidth.
-Whether the instance is restarted depends on whether the inventory resources in the current region are sufficient.
-Not-applicable: This instance does Not support the shutdown mode.'),
      deletionProtection?: boolean(name='DeletionProtection', description='The release protection property of the instance. It specifies whether to release the instance through the console or by using the API(DeleteInstance).

-true: instance release protection is enabled.
-false: instance release protection is disabled.

> This attribute applies only to pay-as-you-go instances and can only restrict manual release operations. This attribute does not take effect for system release operations.'),
      hostName?: string(name='HostName', description='The hostname of the instance.'),
      GPUAmount?: int32(name='GPUAmount', description='The number of GPUs attached to the instance type.'),
      instanceId?: string(name='InstanceId', description='The ID of the instance.'),
      instanceType?: string(name='InstanceType', description='The instance type.'),
      internetMaxBandwidthIn?: int32(name='InternetMaxBandwidthIn', description='The maximum inbound public bandwidth. Unit: Mbit/s.'),
      internetMaxBandwidthOut?: int32(name='InternetMaxBandwidthOut', description='The maximum outbound public bandwidth. Unit: Mbit/s.'),
      regionId?: string(name='RegionId', description='Instance belongs geo ID.'),
      instanceChargeType?: string(name='InstanceChargeType', description='The billing method of the instance. Possible values:

-PrePaid: Subscription
-PostPaid: pay-as-you-go'),
      ioOptimized?: boolean(name='IoOptimized', description='Indicates whether the instance is I/O optimized.'),
      startTime?: string(name='StartTime', description='The last time when the instance was started. The time follows the ISO 8601 standard and uses UTC +0. The format is yyyy-MM-ddTHH:mmZ. For more information, see [ISO8601](~~ 25696 ~~).'),
      cpu?: int32(name='Cpu', description='The number of VCPUs.'),
      expiredTime?: string(name='ExpiredTime', description='The expiration time. The time follows the ISO 8601 standard and uses UTC +0. The format is yyyy-MM-ddTHH:mmZ. For more information, see [ISO8601](~~ 25696 ~~).'),
      localStorageAmount?: int32(name='LocalStorageAmount', description='The number of local disks attached to the instance.'),
      resourceGroupId?: string(name='ResourceGroupId', description='The ID of the enterprise resource group to which the instance belongs.'),
      zoneId?: string(name='ZoneId', description='The zone to which the instance belongs.'),
      internetChargeType?: string(name='InternetChargeType', description='The billing method of the network. Possible values:

-PayByBandwidth: pay-by-bandwidth.
-PayByTraffic: pay by traffic.'),
      recyclable?: boolean(name='Recyclable', description='Indicates whether the instance can be recycled.'),
      instanceTypeFamily?: string(name='InstanceTypeFamily', description='The instance type family.'),
      creditSpecification?: string(name='CreditSpecification', description='Modify the running mode of a burstable instance. Possible values:

-Standard: Standard mode. For more information about instance performance, see the performance constraint mode section in [what is a burstable instance](~~ 59977 ~~).
-Unlimited: The Unlimited Mode. For more information about instance performance, see The Unlimited Mode section in [what is a burstable instance](~~ 59977 ~~).'),
      ISP?: string(name='ISP', description='> This parameter is being invited for testing and is not currently available.'),
      OSType?: string(name='OSType', description='The operating system of the instance. Valid values: Windows Server and Linux. Possible values:

-Windows
-linux'),
      networkInterfaces?: {
        networkInterface?: [ 
        {
          type?: string(name='Type', description='The type of the Eni. Possible values:
-Primary: Primary Eni
-Secondary: Secondary Eni'),
          macAddress?: string(name='MacAddress', description='The MAC address of the Eni.'),
          primaryIpAddress?: string(name='PrimaryIpAddress', description='The primary private IP address of the Eni.'),
          networkInterfaceId?: string(name='NetworkInterfaceId', description='The ID of the Eni.'),
          privateIpSets?: {
            privateIpSet?: [ 
            {
              privateIpAddress?: string(name='PrivateIpAddress', description='The private IP address of the instance.'),
              primary?: boolean(name='Primary', description='Indicates whether the private IP address is the primary IP address.'),
            }
          ](name='PrivateIpSet')
          }(name='PrivateIpSets', description='A collection of PrivateIpSet.'),
          ipv6Sets?: {
            ipv6Set?: [ 
            {
              ipv6Address?: string(name='Ipv6Address', description='The IPv6 address specified for the Eni.'),
            }
          ](name='Ipv6Set')
          }(name='Ipv6Sets', description='The set of IPv6 addresses assigned to the Eni. This parameter is returned only when the value of "AdditionalAttributes. "is "network_primary_eni_ip.'),
        }
      ](name='NetworkInterface')
      }(name='NetworkInterfaces', description='The Enis of the instance.'),
      operationLocks?: {
        lockReason?: [ 
        {
          lockMsg?: string(name='LockMsg', description='The description of the locked instance.'),
          lockReason?: string(name='LockReason', description='The lock type. Possible values:

-financial: locked due to overdue payments.
-security: locked for security reasons.
-Recycling: the status of the preemptible instance to be released.
-dedicatedhostfinancial: the ECS instance is locked because the dedicated host is overdue.
-refunded: the refund is locked.'),
        }
      ](name='LockReason')
      }(name='OperationLocks', description='The reason why the instance is locked.'),
      tags?: {
        tag?: [ 
        {
          tagKey?: string(name='TagKey', description='The tag key of the instance.'),
          tagValue?: string(name='TagValue', description='The tag value of the instance.'),
        }
      ](name='Tag')
      }(name='Tags', description='The tag set of the instance.'),
      rdmaIpAddress?: {
        ipAddress?: [ string ](name='IpAddress')
      }(name='RdmaIpAddress'),
      innerIpAddress?: {
        ipAddress?: [ string ](name='IpAddress')
      }(name='InnerIpAddress'),
      securityGroupIds?: {
        securityGroupId?: [ string ](name='SecurityGroupId')
      }(name='SecurityGroupIds'),
      publicIpAddress?: {
        ipAddress?: [ string ](name='IpAddress')
      }(name='PublicIpAddress'),
      vpcAttributes?: {
        vpcId?: string(name='VpcId', description='VPC VPC ID.'),
        natIpAddress?: string(name='NatIpAddress', description='The IP address of the cloud product, which is used for network communication between VPC cloud products.'),
        vSwitchId?: string(name='VSwitchId', description='The ID of the vSwitch.'),
        privateIpAddress?: {
          ipAddress?: [ string ](name='IpAddress')
        }(name='PrivateIpAddress'),
      }(name='VpcAttributes', description='The attributes of the VPC.'),
      eipAddress?: {
        internetChargeType?: string(name='InternetChargeType', description='The billing method of the elastic IP address.

-PayByBandwidth: pay by bandwidth.

-PayByTraffic: pay by traffic.'),
        isSupportUnassociate?: boolean(name='IsSupportUnassociate', description='Indicates whether the EIP can be unbound.'),
        ipAddress?: string(name='IpAddress', description='The elastic IP address.'),
        bandwidth?: int32(name='Bandwidth', description='The Internet bandwidth limit of the elastic IP address. Unit: Mbit/s.'),
        allocationId?: string(name='AllocationId', description='The ID of the EIP.'),
      }(name='EipAddress', description='The binding information of the elastic IP address.'),
      hibernationOptions?: {
        configured?: boolean(name='Configured', description='> This parameter is being invited for testing and is not currently available.'),
      }(name='HibernationOptions', description='> This parameter is being invited for testing and is not currently available.'),
      dedicatedHostAttribute?: {
        dedicatedHostId?: string(name='DedicatedHostId', description='The ID of the dedicated host.'),
        dedicatedHostName?: string(name='DedicatedHostName', description='The name of the dedicated host.'),
        dedicatedHostClusterId?: string(name='DedicatedHostClusterId', description='The ID of the DDH cluster.'),
      }(name='DedicatedHostAttribute', description='A DDH attribute array consisting of the DDH cluster ID(DedicatedHostClusterId), DDH ID(DedicatedHostId), and name (DedicatedHostName).'),
      ecsCapacityReservationAttr?: {
        capacityReservationId?: string(name='CapacityReservationId', description='The ID of the subscription service.'),
        capacityReservationPreference?: string(name='CapacityReservationPreference', description='The type of the private resource pool generated after the capacity reservation service takes effect. Possible values:

-Open: Open mode.
-Target: The dedicated mode.'),
      }(name='EcsCapacityReservationAttr', description='The capacity of the ECS instance.'),
      dedicatedInstanceAttribute?: {
        affinity?: string(name='Affinity', description='Indicates whether the DDH instance is associated with the DDH. Possible values:

-default: The DDH instance is not associated with the DDH. After an instance is restarted in the Save downtime mode, it may be placed on another dedicated host in the automatic resource deployment pool.

-host: The dedicated host instance is associated with the dedicated host. After the instance is restarted in the shutdown mode, it is still placed on the original dedicated host.'),
        tenancy?: string(name='Tenancy', description='Indicates whether the host type of the instance is dedicated. Possible values:

-default: The host type of the instance is not a dedicated host.

-host: The host type of the instance is dedicated.'),
      }(name='DedicatedInstanceAttribute', description='The attributes of the DDH instance.'),
      cpuOptions?: {
        numa?: string(name='Numa', description='The number of allocated threads. Possible value: 2'),
        coreCount?: int32(name='CoreCount', description='The number of physical CPU cores.'),
        threadsPerCore?: int32(name='ThreadsPerCore', description='The number of CPU threads.'),
      }(name='CpuOptions', description='The CPU configuration details.'),
      metadataOptions?: {
        httpEndpoint?: string(name='HttpEndpoint', description='Specifies whether to enable the access channel for instance metadata. Possible values:
-enabled: enabled
-disabled: disabled'),
        httpPutResponseHopLimit?: int32(name='HttpPutResponseHopLimit', description='This parameter is not available.'),
        httpTokens?: string(name='HttpTokens', description='Specifies whether to use the enhanced mode (IMDSv2) when accessing instance metadata. Possible values:
-optional: not mandatory
-required: Force use'),
      }(name='MetadataOptions', description='A collection of metadata options.'),
    }
  ](name='Instance')
  }(name='Instances', description='An array consisting of Instances.'),
}

model DescribeInstancesResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeInstancesResponseBody(name='body'),
}

/**
 * ## API description

-Request parameters are similar to a filter. The filter is a logical AND (AND) relationship. If a parameter is empty, the filter does not work. However, if the parameter InstanceIds is an empty JSON Array, the filter is considered valid and empty.

-If you are using a RAM user account or RAM role, an empty list is returned if the user or role lacks interface permissions. You can add the "DryRun" parameter to the request to determine whether the list is empty due to permission issues.

-When you call an API through Alibaba Cloud CLI, the request parameter values of different data types must comply with the format requirements. For more information, see [CLI parameter format description](~~ 110340 ~~).

-You can view the returned data in either of the following ways:
-Method 1: Use the NextToken to set the Token. The value is the DescribeInstances parameter value returned NextToken the last call. Then, use the MaxResults to set the maximum number of entries to query on a single page.

> When you call the API for paging query for the first time, you only need to set MaxResults parameters. By default, the API returns 10 pieces of resource data and NextToken parameter values.

-Method 2: Set the number of entries returned on a single page by "PageSize", and then set the page number by "pagenumerber.
You can select either of the preceding methods. If a large number of entries are returned, we recommend that you use method 1. If "NextToken" is set, the request parameters "PageSize" and "pagenumerber" are invalid.

 */
async function describeInstances(request: DescribeInstancesRequest): DescribeInstancesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeInstances', 'POST', 'undefined', 'json', false, 'none', request);
}

model AllocateDedicatedHostsRequest {
  networkAttributes?: {
    slbUdpTimeout?: int32(name='SlbUdpTimeout', description='The UDP session timeout period of the SLB connection. Unit: seconds. Valid values: 15 to 310', position=''),
    udpTimeout?: int32(name='UdpTimeout', description='Set the UDP session timeout period for user access for cloud services running on the DDH. Unit: seconds. Valid values: 15 to 310', position=''),
  }(name='NetworkAttributes'),
  tag?: [ 
    {
      key?: string(name='Key', description='专有宿主机的标签键。N的取值范围：1~20

一旦传入该值，则不允许为空字符串。最多支持128个字符，不能以aliyun或者acs:开头，不能包含`http://`或者`https://`。'),
      value?: string(name='Value', description='专有宿主机的标签值。N的取值范围：1~20

一旦传入该值，可以为空字符串。最多支持128个字符，不能以acs:开头，不能包含`http://`或者`https://`。'),
    }
  ](name='Tag', position='Query'),
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  autoRenew?: boolean(name='AutoRenew', description='Specifies whether to automatically renew the subscription dedicated host.
> When the value of the parameter **ChargeType** PrePaid, The **AutoRenew** parameter takes effect.

Default value: false', position='Query'),
  dedicatedHostType?: string(name='DedicatedHostType', description='The specification of the dedicated host. You can call the [DescribeDedicatedHostTypes](~~ 134240 ~~) API to obtain the latest DDH specifications.', position='Query'),
  description?: string(name='Description', description='The description of the dedicated host. The description must be 2 to 256 characters in length and cannot start with "http:// "or "https.', position='Query'),
  dedicatedHostName?: string(name='DedicatedHostName', description='The name of the dedicated host. The description must be 2 to 128 characters in length. It must start with a letter and cannot start with "http:// "or "https. It can contain numbers, colons (:), underscores (_), and hyphens (-).', position='Query'),
  quantity?: int32(name='Quantity', description='The number of dedicated hosts created this time. Valid values: 1 to 100.

Default value: 1.', position='Query'),
  actionOnMaintenance?: string(name='ActionOnMaintenance', description='When a dedicated host fails or is repaired online, you can configure a migration solution for the host. Valid values:

-Migrate: Migrate the instance to another physical machine and restart the instance.

When proprietary host Mount cloud storage, default: Migrate.

-Stop: Stop the instance on the current DDH. After confirming that the DDH cannot be repaired, migrate the instance to another physical machine and restart the instance.

When a local disk is attached to a dedicated host, the default value is Stop.', position='Query'),
  autoPlacement?: string(name='AutoPlacement', description='Indicates whether the dedicated host is added to the automatic deployment resource pool. When you create an instance on a DDH without specifying **DedicatedHostId**, Alibaba Cloud automatically selects an appropriate DDH from the DDH added to the resource pool to deploy the instance, for more information, see [automatic deployment](~~ 118938 ~~). Valid values:

-on: added to the automatic deployment resource pool.

-off: does not join the automatic deployment resource pool.

Default value: on

> If you do not want a dedicated host to be added to the automatic deployment resource pool, set this parameter to off.', position='Query'),
  autoReleaseTime?: string(name='AutoReleaseTime', description='The automatic release time of the dedicated host. Specify the time in the ISO 8601 standard in UTC +0 format yyyy-MM-ddTHH:mm:ssZ.

>-set the minimum value to half an hour after the current time.
-A maximum of three years after the current time.
-If the seconds (ss) in the parameter value is not 00, it is automatically set to 00.', position='Query'),
  cpuOverCommitRatio?: float(name='CpuOverCommitRatio', description='CPU oversold ratio. You can set the CPU oversell ratio only for g6s, c6s, and r6s specifications. Valid values: 1 to 5.

CPU oversold ratio affects the number of available VCPUs of a DDH. The number of available vCPUs of a DDH = number of physical CPU cores * 2* CPU oversold ratio. For example, the number of physical CPU cores of g6s is 52. If the CPU oversell ratio is set to 4, the total number of VCPUs after the DDH is created is 416. For scenarios where the absolute stability of CPU is not strict or the CPU load is not high, for example, in the development and testing environment, increasing the overselling ratio can increase the number of available vCPU to deploy more ECS instances of the same specification, reduce unit deployment costs.', position='Query'),
  period?: int32(name='Period', description='The subscription duration of a dedicated host. When the value of "ChargeType" is "PrePaid", the "1" parameter takes effect and is required. Valid values:

<props="china">
-PeriodUnit = Week:{1,2,3}
-PeriodUnit = Month:{1,2,3,4,5,6,7,8,9}
-PeriodUnit = Year:{1,2,3,4,5}

</props>

<props="intl">
-PeriodUnit = Month:{1,2,3,4,5,6,7,8,9}
-PeriodUnit = Year:{1,2,3,4,5}

</props>

<props="partner">
-PeriodUnit = Month:{1,2,3,4,5,6,7,8,9}
-PeriodUnit = Year:{1,2,3,4,5}

</props>', position='Query'),
  chargeType?: string(name='ChargeType', description='The billing method of the dedicated host. Valid values:

<props="china">
-PrePaid: subscription. When you select subscription, make sure that your payment method supports balance or credit line payment. Otherwise, you will be prompted to InvalidPayMethod.

-PostPaid (default): Pay-as-you-go.

</props>


<props="intl">
-PrePaid: subscription. When you select subscription, make sure that your payment method supports credit line payment. Otherwise, you will be prompted to InvalidPayMethod.

-PostPaid (default): Pay-as-you-go.

</props>

<props="partner">
-PrePaid: subscription. When you select subscription, make sure that your payment method supports credit line payment. Otherwise, you will be prompted to InvalidPayMethod.

-PostPaid (default): Pay-as-you-go.

</props>
', position='Query'),
  dedicatedHostClusterId?: string(name='DedicatedHostClusterId', description='The ID of the DDH cluster to which the DDH belongs.', position='Query'),
  zoneId?: string(name='ZoneId', description='The ID of the zone to which the dedicated host belongs.

Default value: Null.', position='Query'),
  autoRenewPeriod?: int32(name='AutoRenewPeriod', description='The cycle of an automatic renewal. Unit: month. Valid values:{1,2,3,6,12}.

> If the parameter **AutoRenew** is set to true, the **AutoRenewPeriod** parameter takes effect and is required.', position='Query'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group to which the DDH belongs.', position='Query'),
  regionId?: string(name='RegionId', description='The ID of the region to which the dedicated host belongs. You can call [DescribeRegions](~~ 25609 ~~) to view the latest region list.', position='Query'),
  minQuantity?: int32(name='MinQuantity', description='The minimum number of dedicated hosts. Valid values: 1 to 100.

> When the inventory of a dedicated host is less than the minimum quantity, the creation of a dedicated host fails.', position='Query'),
  clientToken?: string(name='ClientToken', description='Ensure the idempotence of the request. Generate a parameter value from your client. Make sure that the value is unique among different requests. **ClientToken** supports only ASCII characters and cannot exceed 64 characters. For more information, see [how to ensure idempotence](~~ 25693 ~~).', position='Query'),
  periodUnit?: string(name='PeriodUnit', description='The duration of the dedicated host. Unit. Valid values:

<props="china">
-Week
-Month
-Year

</props>

<props="intl">
-Month
-Year

</props>

<props="partner">
-Month
-Year

</props>

Default value: Month', position='Query'),
}

model AllocateDedicatedHostsResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.'),
  dedicatedHostIdSets?: {
    dedicatedHostId?: [ string ](name='DedicatedHostId')
  }(name='DedicatedHostIdSets'),
}

model AllocateDedicatedHostsResponse = {
  headers: map[string]string(name='headers'),
  body: AllocateDedicatedHostsResponseBody(name='body'),
}

/**
 * ## API description

Before creating a dedicated host, you can call [DescribeAvailableResource](~~ 66186 ~~) to view the resource supply in a specified region or zone.

Fees are incurred when you create a dedicated host. We recommend that you know the billing method of resources in advance. For more information, see [billing Overview](~~ 68978 ~~).

-You can create up to 100 subscription or pay-as-you-go dedicated hosts at a time.

-After the DDH is created, you can use the returned DDH ID list as the request parameter and call [DescribeDedicatedHosts](~~ 134242 ~~) to query the status of the new DDH.

-After you submit a request to create a dedicated host, an error is reported if the specified parameter value is not compliant or the inventory is insufficient. For more information, see error codes.

-After creating a dedicated host, you can use [ModifyInstanceDeployment](~~ 134248 ~~) to migrate an ECS instance from a shared host to a dedicated host, you can also adjust the instance deployment on two dedicated hosts.
 */
async function allocateDedicatedHosts(request: AllocateDedicatedHostsRequest): AllocateDedicatedHostsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'AllocateDedicatedHosts', 'POST', 'undefined', 'json', false, 'none', request);
}

model DeleteMaintenancePropertyRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  instanceId?: [ string ](name='InstanceId', position='Query'),
}

model DeleteMaintenancePropertyResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteMaintenancePropertyResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteMaintenancePropertyResponseBody(name='body'),
}

async function deleteMaintenanceProperty(request: DeleteMaintenancePropertyRequest): DeleteMaintenancePropertyResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteMaintenanceProperty', 'POST', 'undefined', 'json', false, 'none', request);
}

model DetachInstanceRamRoleRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  ownerId?: long(name='OwnerId', description='The ID of the RAM user.', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='The account name of the resource master account.', position='Query'),
  instanceIds?: string(name='InstanceIds', description='The ID of the instance to be detached. The value can be a JSON Array consisting of multiple instance IDs. A maximum of 100 IDs can be entered. Separate IDs with commas (,).', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', description='The ID of the resource master account, that is, the UID.', position='Query'),
  regionId?: string(name='RegionId', description='The ID of the region. You can call [DescribeRegions](~~ 25609 ~~) to view the latest region list.', position='Query'),
  ramRoleName?: string(name='RamRoleName', description='Revoke all ECS instances that are assigned the RAM role to an instance. You can use the RAM API [ListRoles](~~ 28713 ~~) to query the created instance RAM role.', position='Query'),
}

model DetachInstanceRamRoleResponseBody = {
  ramRoleName?: string(name='RamRoleName', description='The name of the RAM role.'),
  requestId?: string(name='RequestId', description='The ID of the request.'),
  totalCount?: int32(name='TotalCount', description='The total number of instance RAM roles that are reclaimed.'),
  failCount?: int32(name='FailCount', description='The number of instance RAM roles that failed to be detached.'),
  detachInstanceRamRoleResults?: {
    detachInstanceRamRoleResult?: [ 
    {
      code?: string(name='Code', description='Determines whether the instance RAM role is revoked. A value of 200 indicates that the request is successfully withdrawn. A value other than 200 indicates that the request failed. For more information about the cause of the failure, see error codes.'),
      message?: string(name='Message', description='Determines whether the instance RAM role is revoked. If the return value is Success, it indicates that the Reclaim is successful. If the return value is other, it indicates that the reclaim fails. For more information, see error codes.'),
      instanceId?: string(name='InstanceId', description='The ECS instance to which the instance RAM role is to be revoked.'),
      success?: boolean(name='Success', description='Indicates whether the specified instance role has been reclaimed.'),
      instanceRamRoleSets?: {
        instanceRamRoleSet?: [ 
        {
          ramRoleName?: string(name='RamRoleName', description='The name of the RAM role.'),
          instanceId?: string(name='InstanceId', description='The ID of the instance.'),
        }
      ](name='InstanceRamRoleSet')
      }(name='InstanceRamRoleSets', description='The set of RAM roles for the instance.'),
    }
  ](name='DetachInstanceRamRoleResult')
  }(name='DetachInstanceRamRoleResults', description='The information set of the instance RAM role type (DetachInstanceRamRoleResult).'),
}

model DetachInstanceRamRoleResponse = {
  headers: map[string]string(name='headers'),
  body: DetachInstanceRamRoleResponseBody(name='body'),
}

async function detachInstanceRamRole(request: DetachInstanceRamRoleRequest): DetachInstanceRamRoleResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DetachInstanceRamRole', 'POST', 'undefined', 'json', false, 'none', request);
}

model AllocatePublicIpAddressRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  vlanId?: string(name='VlanId', description='VLAN ID.', position='Query'),
  ipAddress?: string(name='IpAddress', description='The public IP address of the instance. If this parameter is empty, the system randomly assigns IP addresses by default.', position='Query'),
  instanceId?: string(name='InstanceId', description='The ID of the instance to be assigned an IP address.', position='Query'),
  ownerId?: long(name='OwnerId', description='The ID of the RAM user.', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', description='The ID of the resource master account, that is, the UID.', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='The account name of the resource master account.', position='Query'),
}

model AllocatePublicIpAddressResponseBody = {
  ipAddress?: string(name='IpAddress', description='The public IP address of the instance.'),
  requestId?: string(name='RequestId', description='The ID of the request.'),
}

model AllocatePublicIpAddressResponse = {
  headers: map[string]string(name='headers'),
  body: AllocatePublicIpAddressResponseBody(name='body'),
}

/**
 * ## API description

When you call this operation, note that:

-Before assigning a public IP address, the instance must be in the **running**("Running") or **stopped**("Stopped") status.

-When "OperationLocks" is marked with ""LockReason" : "security"" in the instance of [security control](~~ 25695 ~~), public IP addresses cannot be assigned.

-Only one public IP address can be assigned to an instance. If the instance already has a public IP address, an error "allocatedalreade" is returned ".

-After the instance is restarted ([RebootInstance](~~ 25502 ~~)) or the instance is started ([StartInstance](~~ 25500 ~~)), the new public IP address takes effect.

In addition to assigning a public IP address, you can bind an elastic IP address (EIP) to a VPC-type ECS instance. For more information, see [AssociateEipAddress](~~ 36017 ~~).

> After An EIP is bound to a VPC instance, no public IP address can be assigned.
 */
async function allocatePublicIpAddress(request: AllocatePublicIpAddressRequest): AllocatePublicIpAddressResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'AllocatePublicIpAddress', 'POST', 'undefined', 'json', false, 'none', request);
}

model PurchaseStorageCapacityUnitRequest {
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  fromApp?: string(name='FromApp', position='Query'),
  tag?: [ 
    {
      key?: string(name='Key', description='SCU的标签键。N表示可以设置的标签键数量，取值范围：1~20。一旦传入该值，则不允许为空字符串。最多支持128个字符，不能以`aliyun`或`acs:`开头，不能包含`http://`或`https://`。'),
      value?: string(name='Value', description='SCU的标签值。N表示可以设置的标签值数量，且与`Tag.N.Key`的N对应。取值范围：1~20。一旦传入该值，可以为空字符串。最多支持128个字符，不能以`acs:`开头，不能包含`http://`或`https://`。'),
    }
  ](name='Tag', position='Query'),
  capacity?: int32(name='Capacity', description='The capacity of the SCU. Unit: GiB. Value range:{20, 40, 100, 200, 500, 1024, 2048, 5120, 10240, 20480, 51200}', position='Query'),
  regionId?: string(name='RegionId', description='The ID of the region to which the SCU belongs. After the region is determined, SCU can only deduct the pay-as-you-go billing of cloud disks in the region. You can call [DescribeRegions](~~ 25609 ~~) to view the latest region list.', position='Query'),
  clientToken?: string(name='ClientToken', description='Ensure the idempotence of the request. Generate a parameter value from your client. Make sure that the value is unique among different requests. "ClientToken" only supports ASCII characters and cannot exceed 64 characters in length. For more information, see [how to ensure idempotence](~~ 25693 ~~).', position='Query'),
  description?: string(name='Description', description='The description of the SCU. It must be 2 to 256 characters in length and cannot start with "http:// "or "https.', position='Query'),
  startTime?: string(name='StartTime', description='SCU entry into force of the time shall not be earlier than the creation time and later than creation time in six months. The time follows the ISO 8601 standard and uses UTC +0. The format is yyyy-MM-ddTHH:mm:ssZ.

Default value: none, said from the creation time start to take effect.', position='Query'),
  amount?: int32(name='Amount', description='The number of SCUs purchased. Valid values: 1 to 20.

Default value: 1.', position='Query'),
  name?: string(name='Name', description='The name of the SCU. The name must be 2 to 128 characters in length. It must start with a letter and cannot start with "http:// "or "https. It can contain numbers, colons (:), underscores (_), and hyphens (-).
', position='Query'),
  periodUnit?: string(name='PeriodUnit', description='The validity period of the SCU. Unit. Valid values:

-Month: Month
-Year: Year

Default value: Month', position='Query'),
  period?: int32(name='Period', description='The validity period of the SCU. Valid values:

-When PeriodUnit is set to Month, the valid value of the Period parameter is {1, 2, 3, 6}.
-When PeriodUnit = Year, the valid value of the Period parameter is {1, 3, 5}.

Default value: 1.', position='Query'),
}

model PurchaseStorageCapacityUnitResponseBody = {
  orderId?: string(name='OrderId', description='The ID of the order.'),
  requestId?: string(name='RequestId', description='The ID of the request.'),
  storageCapacityUnitIds?: {
    storageCapacityUnitId?: [ string ](name='StorageCapacityUnitId')
  }(name='StorageCapacityUnitIds', description='SCU ID.'),
}

model PurchaseStorageCapacityUnitResponse = {
  headers: map[string]string(name='headers'),
  body: PurchaseStorageCapacityUnitResponseBody(name='body'),
}

/**
 * ## API description

Make sure that you have fully understood the billing methods and prices of SCUs. For more information, see [storage capacity unit package billing method](~~ 137897 ~~).


 */
async function purchaseStorageCapacityUnit(request: PurchaseStorageCapacityUnitRequest): PurchaseStorageCapacityUnitResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'PurchaseStorageCapacityUnit', 'POST', 'undefined', 'json', false, 'none', request);
}

model ModifyDedicatedHostAutoRenewAttributeRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  regionId?: string(name='RegionId', description='The ID of the region to which the dedicated host belongs.', position='Query'),
  dedicatedHostIds?: string(name='DedicatedHostIds', description='The ID of the dedicated host. You can enter up to 100 dedicated host IDs. Separate the IDs with commas (,).', position='Query'),
  autoRenew?: boolean(name='AutoRenew', description='Specifies whether to automatically renew the subscription dedicated host. Valid values:

-true: The dedicated host is automatically renewed.

-false: The dedicated host is not automatically renewed.

Default value: false
', position='Query'),
  duration?: int32(name='Duration', description='The renewal period. Valid values:

-When PeriodUnit is set to Week, the value range of this parameter is {1, 2, 3}.
-If PeriodUnit is set to Month, the value range of this parameter is {1, 2, 3, 6, 12}.', position='Query'),
  periodUnit?: string(name='PeriodUnit', description='The renewal period. Unit. Valid values:

-Week: Week
-Month: Month

Default value: Month', position='Query'),
  autoRenewWithEcs?: string(name='AutoRenewWithEcs', description='Specifies whether to automatically renew the subscription ECS instance on the DDH.

If the billing method of your dedicated host (DDH) is subscription, and auto-renewal is enabled for the subscription ECS instance in the DDH. You can use this parameter to set the DDH to automatically renew with the ECS instance. When an ECS instance in a DDH is automatically renewed, if the expiration time of the DDH is shorter than the expiration time after the ECS instance is renewed, the DDH is also automatically renewed. The following table describes the principles for automatic renewal of DDH with ECS instances:

The DDH automatically determines the expiration time of the corresponding ECS instance after renewal, and then selects the expiration time later than that of the ECS instance when the DDH is automatically renewed, the minimum renewal period of the DDH. For more information about the renewal cycles supported by DDH, see The "Dune" and "Duration" parameters.

For example, if a subscription DDH expires on November 15 of the current year, the subscription ECS instances in the DDH will be extended to expire on November 15 of the current year after auto renewal, the lifecycle of a DDH is 10 months less than that of an ECS instance. In this case, when the DDH is automatically renewed, it is selected to be later than 10 months, and the minimum renewal period that meets the DDH renewal period is 12 months (that is, "PeriodUnit = Month" and "Period = 12"). Renew the instance.

Valid values:

-AutoRenewWithEcs: auto renewal is performed on the subscription ECS instance of the dedicated host.
-StopRenewWithEcs: auto renewal is not followed by subscription ECS instances on the dedicated host.
-NoOperation: the current settings of the DDH are not changed.

> If you set this parameter to AutoRenewWithEcs, make sure that auto-renewal is enabled for the DDH, that is, "AutoRenew = true. Otherwise, this parameter only changes the value of the parameter, and the automatic renewal function of the ECS instance does not take effect.

Default value: NoOperation

', position='Query'),
  renewalStatus?: string(name='RenewalStatus', description='Specifies whether to automatically renew the subscription dedicated host. The "RenewalStatus" parameter takes precedence over "AutoRenew ". Valid values:

-AutoRenewal: auto renewal.

-Normal: to be renewed.

-NotRenewal: no renewal or expiration notification is sent. We will send a non-renewal reminder on the third day before expiration. If you do not renew a dedicated host, you can set it to Normal, and then renew it ([RenewDedicatedHosts](~~ 134250 ~~)) or set it to automatic (AutoRenewal).', position='Query'),
}

model ModifyDedicatedHostAutoRenewAttributeResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.'),
}

model ModifyDedicatedHostAutoRenewAttributeResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyDedicatedHostAutoRenewAttributeResponseBody(name='body'),
}

/**
 * ## API description

-When the auto-renewal feature is enabled for your subscription DDH, the auto-renewal is automatically performed nine days before the subscription expires. The fee is deducted at 08:00:00(UTC +8). If the deduction fails on the previous day, the scheduled execution will continue on the next day. If the fee is deducted successfully or the DDH is locked after expiration nine days later, the automatic fee deduction is stopped. During this period, you must ensure that your payment method is sufficient.

-Subscription dedicated hosts support automatic renewal of subscription ECS instances. For more information, see AutoRenewWithEcs parameters.
 */
async function modifyDedicatedHostAutoRenewAttribute(request: ModifyDedicatedHostAutoRenewAttributeRequest): ModifyDedicatedHostAutoRenewAttributeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyDedicatedHostAutoRenewAttribute', 'POST', 'undefined', 'json', false, 'none', request);
}

model DescribeEipMonitorDataRequest {
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  allocationId?: string(name='AllocationId', position='Query'),
  startTime?: string(name='StartTime', position='Query'),
  endTime?: string(name='EndTime', position='Query'),
  period?: int32(name='Period', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
}

model DescribeEipMonitorDataResponseBody = {
  requestId?: string(name='RequestId'),
  eipMonitorDatas?: {
    eipMonitorData?: [ 
    {
      eipTX?: int32(name='EipTX'),
      eipPackets?: int32(name='EipPackets'),
      eipBandwidth?: int32(name='EipBandwidth'),
      timeStamp?: string(name='TimeStamp'),
      eipFlow?: int32(name='EipFlow'),
      eipRX?: int32(name='EipRX'),
    }
  ](name='EipMonitorData')
  }(name='EipMonitorDatas'),
}

model DescribeEipMonitorDataResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeEipMonitorDataResponseBody(name='body'),
}

async function describeEipMonitorData(request: DescribeEipMonitorDataRequest): DescribeEipMonitorDataResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeEipMonitorData', 'POST', 'undefined', 'json', false, 'none', request);
}

model DescribeDisksFullStatusRequest {
  eventTime?: {
    start?: string(name='Start', description='Query the start time of the event occurrence time.

The time follows the [ISO8601](~~ 25696 ~~) standard and uses UTC +0. The format is "yyyy-MM-ddTHH:mm:ssZ ".', position=''),
    end?: string(name='End', description='Query the end time of the event occurrence time.

The time follows the [ISO8601](~~ 25696 ~~) standard and uses UTC +0. The format is "yyyy-MM-ddTHH:mm:ssZ ".', position=''),
  }(name='EventTime'),
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  regionId?: string(name='RegionId', description='The region ID of the block storage. You can call [DescribeRegions](~~ 25609 ~~) to view the latest region list.', position='Query'),
  diskId?: [ string ](name='DiskId', description='The ID of the block storage. Valid values of N: 1 to 100.', position='Query'),
  healthStatus?: string(name='HealthStatus', description='The health status of the block storage. Valid values:

-Impaired: temporary read/write failure
-Warning: service degradation
-Initializing: Initializing
-InsufficientData: insufficient data
-NotApplicable: not applicable
', position='Query'),
  eventType?: string(name='EventType', description='Specifies the event type of block storage. Valid values:

-Degraded: the performance of block storage is Degraded.
-SeverelyDegraded: the performance of block storage is severely degraded.
-Stalled: block storage performance is severely affected.
-ErrorDetected: The local disk is damaged.', position='Query'),
  ownerId?: long(name='OwnerId', description='The ID of the RAM user.', position='Query'),
  pageNumber?: int32(name='PageNumber', description='The page number of the query result. Value range: positive integer

Default value: 1.', position='Query'),
  pageSize?: int32(name='PageSize', description='The number of entries to return on each page. Valid values: 1 to 100.

Default value: 10', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='The account name of the resource master account.', position='Query'),
  eventId?: [ string ](name='EventId', description='The ID of the event. Valid values of N: 1 to 100.', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', description='The ID of the resource master account, that is, the UID.', position='Query'),
  status?: string(name='Status', description='Specifies the lifecycle status of block storage. For more information, see [disk Status Table](~~ 25689 ~~). Valid values:

-In_use: In use
-Available: to be mounted
-Attaching: Mounting
-Detaching: uninstalling
-Creating: Creating
-ReIniting: initializing
', position='Query'),
}

model DescribeDisksFullStatusResponseBody = {
  pageSize?: int32(name='PageSize', description='The size of each page.'),
  requestId?: string(name='RequestId', description='The ID of the request.'),
  pageNumber?: int32(name='PageNumber', description='The page number.'),
  totalCount?: int32(name='TotalCount', description='The total number of all statuses.'),
  diskFullStatusSet?: {
    diskFullStatusType?: [ 
    {
      diskId?: string(name='DiskId', description='The ID of the block storage.'),
      instanceId?: string(name='InstanceId', description='The ID of the instance.'),
      device?: string(name='Device', description='The name of the device to which block storage is attached to the instance, for example,/dev/xvdb.

This parameter is valid only when the value of the "Status" parameter is "in_us". This parameter is empty when it is in other states.

> This parameter will be discontinued soon. We recommend that you do not use this parameter to improve code compatibility.'),
      diskEventSet?: {
        diskEventType?: [ 
        {
          eventId?: string(name='EventId', description='The ID of the block storage event.'),
          eventEndTime?: string(name='EventEndTime', description='The end time of the event.'),
          eventTime?: string(name='EventTime', description='The time when the event occurred.'),
          impactLevel?: string(name='ImpactLevel', description='The impact level.'),
          eventType?: {
            name?: string(name='Name', description='The name of the event type. Possible values:
-Degraded: the performance of block storage is Degraded.
-SeverelyDegraded: the performance of block storage is severely degraded.
-Stalled: block storage performance is severely affected.
-ErrorDetected: The local disk is damaged.'),
            code?: int32(name='Code', description='The code of the event type.'),
          }(name='EventType', description='The type of the event.'),
        }
      ](name='DiskEventType')
      }(name='DiskEventSet', description='The array of block storage events.'),
      status?: {
        name?: string(name='Name', description='The name of the block storage lifecycle status.'),
        code?: int32(name='Code', description='The lifecycle status code of block storage.'),
      }(name='Status', description='The lifecycle status of block storage.'),
      healthStatus?: {
        name?: string(name='Name', description='The name of the health status of the block storage device.'),
        code?: int32(name='Code', description='The health status code of the block storage.'),
      }(name='HealthStatus', description='The health status of the block storage.'),
    }
  ](name='DiskFullStatusType')
  }(name='DiskFullStatusSet', description='Block storage full-state array.'),
}

model DescribeDisksFullStatusResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeDisksFullStatusResponseBody(name='body'),
}

/**
 * ## API description

-All status information of block storage includes the lifecycle of block storage ("Status"), health status of block storage ("HealthStatus"), and event type of block storage ("EventType").

-Because the release time, scheduled execution time, and actual execution time of block storage related events are the same, if you specify a period of time ("EventTime.Start" ~ "EventTime.End"), you can query all historical events that occurred during this period. Currently, you can query the historical events of the last week at most.
 */
async function describeDisksFullStatus(request: DescribeDisksFullStatusRequest): DescribeDisksFullStatusResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeDisksFullStatus', 'POST', 'undefined', 'json', false, 'none', request);
}

model DeleteImageComponentRequest {
  templateTag?: [ 
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='TemplateTag', position='Query'),
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  regionId?: string(name='RegionId', description='Belongs geo ID. You can call [DescribeRegions](~~ 25609 ~~) to view the latest region list.', position='Query'),
  imageComponentId?: string(name='ImageComponentId', description='The ID of the image component to be deleted.', position='Query'),
}

model DeleteImageComponentResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.'),
}

model DeleteImageComponentResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteImageComponentResponseBody(name='body'),
}

/**
 * ## API description

Currently, you can only delete custom image components that you have created.


 */
async function deleteImageComponent(request: DeleteImageComponentRequest): DeleteImageComponentResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteImageComponent', 'POST', 'undefined', 'json', false, 'none', request);
}

model ModifyInstanceSpecRequest {
  temporary?: {
    startTime?: string(name='StartTime', position=''),
    endTime?: string(name='EndTime', position=''),
    internetMaxBandwidthOut?: int32(name='InternetMaxBandwidthOut', position=''),
  }(name='Temporary'),
  systemDisk?: {
    category?: string(name='Category', description='Change the system disk type. This parameter can only be upgraded from [phased-out instance type](~~ 55263 ~~) to [normal instance type family](~~ 25378 ~~), this parameter is valid when the non-I/O optimized instance type is upgraded to the I/O optimized instance type. Valid values:

-cloud_efficiency: Ultra disk

-cloud_ssd:SSD cloud disk', position=''),
  }(name='SystemDisk'),
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', description='The ID of the RAM user.', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', description='The ID of the resource master account, that is, the UID.', position='Query'),
  instanceType?: string(name='InstanceType', description='The target instance type. For more information, see [instance type family](~~ 25378 ~~), or call [DescribeInstanceTypes](~~ 25620 ~~) to obtain the latest specification.', position='Query'),
  clientToken?: string(name='ClientToken', description='Ensure the idempotence of the request. Generate a parameter value from your client. Make sure that the value is unique among different requests. **ClientToken** supports only ASCII characters and cannot exceed 64 characters. For more information, see [how to ensure idempotence](~~ 25693 ~~).', position='Query'),
  internetMaxBandwidthOut?: int32(name='InternetMaxBandwidthOut', description='The maximum outbound Internet bandwidth. Unit: Mbit/s(Megabit per second). Valid values: 0 to 100.

> **pay-by-traffic** mode: The peak inbound and outbound bandwidth is the upper limit of the bandwidth and is not used as a service commitment indicator. When a resource scramble occurs, the peak bandwidth may be limited. If your business needs to be guaranteed by bandwidth, use the **pay-by-bandwidth** mode.

', position='Query'),
  instanceId?: string(name='InstanceId', description='The ID of the instance.', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='The account name of the resource master account.', position='Query'),
  internetMaxBandwidthIn?: int32(name='InternetMaxBandwidthIn', description='The maximum inbound public bandwidth. Unit: Mbit/s(Megabit per second). Valid values:

-When the purchased internet outbound bandwidth is less than or equal to 10 Mbit/s: 1 to 10, the default value is 10.
-When the purchased public outbound bandwidth is greater than 10 Mbit/s: 1 to "InternetMaxBandwidthOut". The default value is "InternetMaxBandwidthOut.

> **pay-by-traffic** mode: The peak inbound and outbound bandwidth is the upper limit of the bandwidth and is not used as a service commitment indicator. When a resource scramble occurs, the peak bandwidth may be limited. If your business needs to be guaranteed by bandwidth, use the **pay-by-bandwidth** mode.
', position='Query'),
  async?: boolean(name='Async', description='Specifies whether to submit an asynchronous request.

Default value: false', position='Query'),
  allowMigrateAcrossZone?: boolean(name='AllowMigrateAcrossZone', description='Indicates whether the instance type can be upgraded across clusters.

Default value: false

When "AllowMigrateAcrossZone" is set to true, note the following when you upgrade the ECS instance based on the returned information:

Classic network type instance:

* For [phased-out instance types](~~ 55263 ~~), when a non-I/O optimized instance is changed to an I/O optimized instance, the private IP address of the instance, the disk device name and software authorization code change. For Linux instances, basic cloud disks ("cloud") are identified as **xvda** or **xvdb**. Ultra cloud disks ("cloud_efficiency ") and SSD cloud disks ("cloud_ssd") it is identified as **vda** or **vdb.

* For [normal instance type families](~~ 25378 ~~), the private IP address of the instance changes.

VPC instances: for [phased-out instance types](~~ 55263 ~~), when non-I/O optimized instances are changed to I/O optimized instances, the disk device name and software authorization code of the ECS instance change. For Linux instances, basic cloud disks ("cloud") are identified as **xvda** or **xvdb**. Ultra cloud disks ("cloud_efficiency ") and SSD cloud disks ("cloud_ssd") it is identified as **vda** or **vdb.', position='Query'),
}

model ModifyInstanceSpecResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.'),
}

model ModifyInstanceSpecResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyInstanceSpecResponseBody(name='body'),
}

/**
 * ## Description

<props = "china"> make sure that you have fully understood the billing method and product pricing of [ECS](https://www.aliyun.com/price/product#/ecs/detail) before using this interface. </props>

For more information about Python SDK resource change examples, see [query available change resources](~~ 109517 ~~).

When you call this operation, note that:

-The account must be in the no overdue status.

-You can adjust the Internet bandwidth only when the instance status is **running**("Running") or **stopped**("Stopped").

-Before you upgrade or downgrade a pay-as-you-go instance type, you can use [DescribeResourcesModification](~~ 66187 ~~) to query the instance types that can be changed.

-You can change the instance type only when the instance status is **stopped**("Stopped").

-You can only upgrade a single configuration at a time, that is, you can only modify the instance type at a time, or you can only adjust the Internet bandwidth.

-Starting from November 27, 2020, the peak bandwidth of an ECS instance is affected by the account speed limit policy. To increase the peak bandwidth, open a ticket. The specific speed limiting policy is as follows:
-In a single region, the total actual peak bandwidth of all ECS instances billed by traffic cannot exceed 5 Gbit/s.
-In a single region, the total actual peak bandwidth of all ECS instances that are billed by fixed bandwidth cannot exceed 50 Gbit/s.
 */
async function modifyInstanceSpec(request: ModifyInstanceSpecRequest): ModifyInstanceSpecResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyInstanceSpec', 'POST', 'undefined', 'json', false, 'none', request);
}

model AssignPrivateIpAddressesRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  networkInterfaceId?: string(name='NetworkInterfaceId', description='The ID of the Eni.', position='Query'),
  secondaryPrivateIpAddressCount?: int32(name='SecondaryPrivateIpAddressCount', description='Specifies the number of private IP addresses and automatically allocates IP addresses from the idle IP addresses of the vSwitch.

When assigning a secondary private IP address, you cannot specify both "PrivateIpAddress. "and "SecondaryPrivateIpAddressCount".', position='Query'),
  clientToken?: string(name='ClientToken', description='Ensure the idempotence of the request. Generate a parameter value from your client. Make sure that the value is unique among different requests. **ClientToken** supports only ASCII characters and cannot exceed 64 characters. For more information, see [how to ensure idempotence](~~ 25693 ~~).', position='Query'),
  privateIpAddress?: [ string ](name='PrivateIpAddress', description='Select one or more secondary private IP addresses from the idle IP addresses of the vSwitch to which the Eni belongs. Valid values of N:

-The ENI is in the available ("Available") Status: 1 to 10.
-The ENI is in the "InUse" state: the instance type is limited. For more information, see [instance type family](~~ 25378 ~~).

When assigning a secondary private IP address, you cannot specify both "PrivateIpAddress. "and "SecondaryPrivateIpAddressCount".', position='Query'),
}

model AssignPrivateIpAddressesResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.'),
  assignedPrivateIpAddressesSet?: {
    networkInterfaceId?: string(name='NetworkInterfaceId', description='The ID of the Eni.'),
    privateIpSet?: {
      privateIpAddress?: [ string ](name='PrivateIpAddress')
    }(name='PrivateIpSet', description='The assigned private IP address.'),
  }(name='AssignedPrivateIpAddressesSet', description='A collection of Enis that have been assigned secondary private IP addresses.'),
}

model AssignPrivateIpAddressesResponse = {
  headers: map[string]string(name='headers'),
  body: AssignPrivateIpAddressesResponseBody(name='body'),
}

/**
 * ## API description

-Only Enis in the Available (Available) or InUse state are supported.

-When operating the primary Eni, the attached instance must be in the Running (Running) or Stopped (Stopped) state.

-When the Eni is in the Available (Available) state, a maximum of 10 secondary private IP addresses can be assigned. Once attached to an instance, the number of secondary private IP addresses that the NIC can assign is limited by the instance type. For more information, see [instance type family](~~ 25378 ~~).

-After you call this operation, you can obtain the allocated secondary private IP addresses from the returned results.
 */
async function assignPrivateIpAddresses(request: AssignPrivateIpAddressesRequest): AssignPrivateIpAddressesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'AssignPrivateIpAddresses', 'POST', 'undefined', 'json', false, 'none', request);
}

model DeleteSnapshotRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', description='The ID of the RAM user.', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='The account name of the resource master account.', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', description='The ID of the resource master account, that is, the UID.', position='Query'),
  snapshotId?: string(name='SnapshotId', description='The ID of the snapshot.', position='Query'),
  force?: boolean(name='Force', description='Specifies whether to forcibly delete snapshots that have been used to create cloud disks. Valid values:

-true: forced deletion. After the disk is forcibly deleted, it cannot be reinitialized.

-false: does not force deletion.

Default value: false', position='Query'),
}

model DeleteSnapshotResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.'),
}

model DeleteSnapshotResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteSnapshotResponseBody(name='body'),
}

/**
 * ## API description

When you call this operation, note that:

-If the specified snapshot ID does not exist, the request is ignored.

-If a snapshot has been used to create a custom image, you cannot delete it. You must delete the created custom image ([DeleteImage](~~ 25537 ~~)) before deleting the snapshot.

-If a snapshot has been used to create a cloud disk and the "Force" parameter or "Force = false" parameter is not set, the snapshot cannot be deleted. If you want to delete a snapshot, set "Force = true" to force the snapshot to be deleted. After the snapshot is forcibly deleted, the corresponding disk cannot be reinitialized.
 */
async function deleteSnapshot(request: DeleteSnapshotRequest): DeleteSnapshotResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteSnapshot', 'POST', 'undefined', 'json', false, 'none', request);
}

model DeleteKeyPairsRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  ownerId?: long(name='OwnerId', description='The ID of the RAM user.', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', description='The ID of the resource master account, that is, the UID.', position='Query'),
  keyPairNames?: string(name='KeyPairNames', description='The name of the SSH key pair. The value can be a JSON Array consisting of multiple SSH key pair names. A maximum of 100 SSH key pairs can be used. Separate the names with commas (,).', position='Query'),
  regionId?: string(name='RegionId', description='The region of the SSH key pair. You can call [DescribeRegions](~~ 25609 ~~) to view the latest region list.', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='The account name of the resource master account.', position='Query'),
}

model DeleteKeyPairsResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.'),
}

model DeleteKeyPairsResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteKeyPairsResponseBody(name='body'),
}

/**
 * ## API description

After you delete an SSH key pair, note the following:

-The SSH key pair cannot be queried through [DescribeKeyPairs](~~ 51773 ~~).

-If an ECS instance is bound to the SSH key pair:

-Alibaba Cloud no longer saves the SSH key pair for you, but the instance can use the SSH key pair normally.

-When you query instance information ([DescribeInstances](~~ 25506 ~~)), the SSH key pair name (KeyPairName) is displayed, but no other information is displayed.
 */
async function deleteKeyPairs(request: DeleteKeyPairsRequest): DeleteKeyPairsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteKeyPairs', 'POST', 'undefined', 'json', false, 'none', request);
}

model AuthorizeSecurityGroupRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', description='The ID of the RAM user.', position='Query'),
  ipProtocol?: string(name='IpProtocol', description='The transport layer protocol. The value is case sensitive. Valid values:

-tcp
-udp
-icmp
-gre
-all: all protocols are supported.

> The icmp protocol only supports IPv4 addresses.', position='Query'),
  policy?: string(name='Policy', description='Set the access permission. Valid values:

-accept: Accepts access.
-drop: The request is denied. If no request is returned, the request of the initiator times out or the connection cannot be established.', position='Query'),
  regionId?: string(name='RegionId', description='The ID of the region to which the security group belongs. You can call [DescribeRegions](~~ 25609 ~~) to view the latest region list.', position='Query'),
  priority?: string(name='Priority', description='The priority of security group rules. A smaller number indicates a higher priority. Valid values: 1 to 100.

Default value: 1.', position='Query'),
  portRange?: string(name='PortRange', description='The port range related to the transport layer protocol opened by the destination security group. Valid values:

-TCP/UDP: valid values: 1 to 65535. Use a slash (/) to separate the start port from the end port. Example: 1/200
-ICMP:-1/-1
-GRE protocol:-1/-1
The value of-IpProtocol is all:-1/-1.

For more information about Port application scenarios, see [common ports for typical applications](~~ 40724 ~~).', position='Query'),
  ipv6SourceCidrIp?: string(name='Ipv6SourceCidrIp', description='The source IPv6 CIDR block for which you want to set the access permission. CIDR and IPv6 IP addresses are supported.

> only IPv6 addresses of VPC-type ECS instances are supported.

Default value: None', position='Query'),
  sourcePrefixListId?: string(name='SourcePrefixListId', description='The ID of the source prefix that you want to configure. You can call [DescribePrefixLists](~~ 205046 ~~) to query the list IDs of available prefixes.

Note:

-If the network type of a security group is classic network, the prefix list cannot be set. For more information about security groups and Prefix List restrictions, see [Security Group restrictions](~~ 25412#SecurityGroupQuota1 ~~).

-If you specify one of the "SourceCidrIp", "Ipv6SourceCidrIp", or "SourceGroupId" parameters, this parameter is ignored.', position='Query'),
  sourcePortRange?: string(name='SourcePortRange', description='The range of ports related to the transport layer protocol opened by the source security group. Valid values:

-TCP/UDP: valid values: 1 to 65535. Use a slash (/) to separate the start port from the end port. Example: 1/200
-ICMP:-1/-1
-GRE protocol:-1/-1
The value of-IpProtocol is all:-1/-1.', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='The account name of the resource master account.', position='Query'),
  ipv6DestCidrIp?: string(name='Ipv6DestCidrIp', description='The Destination IPv6 CIDR block. CIDR and IPv6 IP addresses are supported.

> only IPv6 addresses of VPC-type ECS instances are supported.

Default value: None
', position='Query'),
  securityGroupId?: string(name='SecurityGroupId', description='The ID of the destination security group.', position='Query'),
  destCidrIp?: string(name='DestCidrIp', description='The Destination IPv4 CIDR block. CIDR and IPv4 IP addresses are supported.

Default value: None', position='Query'),
  sourceCidrIp?: string(name='SourceCidrIp', description='The source IPv4 CIDR block to which you want to configure access permissions. CIDR and IPv4 IP addresses are supported.

Default value: None', position='Query'),
  description?: string(name='Description', description='The description of the security group rule. The description must be 1 to 512 characters in length.', position='Query'),
  sourceGroupOwnerId?: long(name='SourceGroupOwnerId', description='The ID of the Alibaba Cloud account to which the source Security Group belongs.

-If "SourceGroupOwnerId" and "SourceGroupOwnerAccount" are not set, the access permissions of other security groups are set.
-If you have set the "SourceCidrIp" parameter, the "SourceGroupOwnerId" parameter is invalid.', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', description='The ID of the resource master account, that is, the UID.', position='Query'),
  clientToken?: string(name='ClientToken', description='Ensure the idempotence of the request. Generate a parameter value from your client. Make sure that the value is unique among different requests. **ClientToken** supports only ASCII characters and cannot exceed 64 characters. For more information, see [how to ensure idempotence](~~ 25693 ~~).', position='Query'),
  sourceGroupId?: string(name='SourceGroupId', description='The ID of the source security group to which you want to configure access permissions. Set at least one "SourceGroupId" or "SourceCidrIp" parameter.

-If "SourceGroupId" is specified but "SourceCidrIp" is not specified, the value of "NicType" can only be "intranet ".
-If both "SourceGroupId" and "SourceCidrIp" are specified, the default value is "SourceCidrIp.', position='Query'),
  sourceGroupOwnerAccount?: string(name='SourceGroupOwnerAccount', description='The Alibaba Cloud account to which the source Security Group belongs.

-If "SourceGroupOwnerAccount" and "SourceGroupOwnerId" are not set, the access permissions of other security groups are set.
-If the "SourceCidrIp" parameter is set, the "SourceGroupOwnerAccount" parameter is invalid.', position='Query'),
  nicType?: string(name='NicType', description='The NIC type of the classic network security group rule. Valid values:

-internet: The internet Nic.
-intranet: The intranet Nic.
-You do not need to set the Nic type for VPC-type security group rules. The default value is intranet, which can only be intranet.
-If you specify the "SourceGroupId" parameter for mutual access between security groups, the value can only be intranet.

Default value: internet', position='Query'),
}

model AuthorizeSecurityGroupResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.'),
}

model AuthorizeSecurityGroupResponse = {
  headers: map[string]string(name='headers'),
  body: AuthorizeSecurityGroupResponseBody(name='body'),
}

/**
 * ## API description

In the API document of the security group, the initiator of the traffic is the Source and the receiver of the data transmission is the Dest.

When you call this operation, you need to understand the following:

-The total number of outbound and inbound security group rules cannot exceed 200.

-The Priority (Priority) of security group rules can be from 1 to 100. A smaller number indicates a higher priority.

-For security group rules with the same priority, the drop rule takes precedence.

-The source device can be a specified IP address range (SourceCidrIp, Ipv6SourceCidrIp, SourcePrefixListId), or an ECS instance in another security group (SourceGroupId).

-If a matching Security Group rule already exists, the AuthorizeSecurityGroup is called successfully, but the number of rules is not increased.

-A security group rule can be determined by any of the following parameters. A security group rule cannot be determined by specifying only one parameter.

-Set the ACL for the specified CIDR block. In this case, you can set the network card type (NicType) of the classic network security group to internet and intranet. You can only set the network interface (NicType) of a VPC security group to intranet. For example, IpProtocol, PortRange, (optional) SourcePortRange, NicType, Policy, and SourceCidrIp.

"""
https://ecs.aliyuncs.com/? Action=AuthorizeSecurityGroup
&SecurityGroupId=sg-F876FF7**
&SourceCidrIp=10.0.0.0/8
&IpProtocol=tcp
&PortRange=22/22
&NicType=intranet
&Policy=accept
& <common request parameters>
"""

-Set the access permissions of other security groups. In this case, the NIC type (NicType) can only be intranet. When mutual access between classic network security groups, you can set the access permissions of other security groups in the same region to your security group. This security group can belong to you or other Alibaba cloud accounts (SourceGroupOwnerAccount). When a VPC-type security group accesses each other, you can set the access permissions of other security groups in the same VPC to access the security group. For example, IpProtocol, PortRange, (optional) SourcePortRange, NicType, Policy, SourceGroupOwnerAccount, and SourceGroupId.

"""
https://ecs.aliyuncs.com/? Action=AuthorizeSecurityGroup
&SecurityGroupId=sg-F876FF7**
&SourceGroupId=sg-1651FBB**
&SourceGroupOwnerAccount=test@aliyun.com
&IpProtocol=tcp
&PortRange=22/22
&NicType=intranet
&Policy=drop
& <common request parameters>
"""

-Associate a prefix list with a security group rule. In this case, the prefix list only supports security groups whose network type is VPC, and NicType can only be set to intranet. For example, IpProtocol, PortRange, (optional) SourcePortRange, NicType, Policy, and SourcePrefixListId.

"""
https://ecs.aliyuncs.com/? Action=AuthorizeSecurityGroup
&SecurityGroupId=sg-F876FF7**
&SourcePrefixListId=pl-x1j1k5ykzqlixdcy ****
&SourceGroupOwnerAccount=test@aliyun.com
&IpProtocol=tcp
&PortRange=22/22
&NicType=intranet
&Policy=drop
& <common request parameters>
"""

-For more information about how to set security group rules, see [application cases](~~ 25475 ~~) and [Introduction to security group quintuple rules](~~ 97439 ~~).
 */
async function authorizeSecurityGroup(request: AuthorizeSecurityGroupRequest): AuthorizeSecurityGroupResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'AuthorizeSecurityGroup', 'POST', 'undefined', 'json', false, 'none', request);
}

model DeleteSecurityGroupRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', description='The ID of the RAM user.', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='The account name of the resource master account.', position='Query'),
  regionId?: string(name='RegionId', description='The ID of the region. You can call [DescribeRegions](~~ 25609 ~~) to view the latest region list.', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', description='The ID of the resource master account, that is, the UID.', position='Query'),
  securityGroupId?: string(name='SecurityGroupId', description='The ID of the security group.', position='Query'),
}

model DeleteSecurityGroupResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.'),
}

model DeleteSecurityGroupResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteSecurityGroupResponseBody(name='body'),
}

/**
 * ## API description
Before deleting a security group, make sure that no instances exist in the security group and that no other security group has authorization ([DescribeSecurityGroupReferences](~~ 57320 ~~)). Otherwise, DeleteSecurityGroup request fails.
 */
async function deleteSecurityGroup(request: DeleteSecurityGroupRequest): DeleteSecurityGroupResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteSecurityGroup', 'POST', 'undefined', 'json', false, 'none', request);
}

model DescribeSnapshotMonitorDataRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  regionId?: string(name='RegionId', description='The ID of the region. You can call [DescribeRegions](~~ 25609 ~~) to view the latest region list.', position='Query'),
  startTime?: string(name='StartTime', description='The start time of the snapshot capacity change data. The time follows the [ISO8601](~~ 25696 ~~) standard and uses UTC +0. The format is yyyy-MM-ddTHH:mm:ssZ. If the specified seconds (ss) is not 00, it is automatically converted to the next minute.', position='Query'),
  endTime?: string(name='EndTime', description='Obtain the end time of the snapshot capacity change data. The time follows the [ISO8601](~~ 25696 ~~) standard and uses UTC +0. The format is yyyy-MM-ddTHH:mm:ssZ. If the specified seconds (ss) is not 00, it is automatically converted to the next minute.', position='Query'),
  period?: int32(name='Period', description='The interval between snapshot capacity changes. Unit: seconds. Valid values:
-60
-600
-3600

Default value: 60', position='Query'),
  category?: string(name='Category', description='The type of the snapshot. Valid values:
-Standard: normal snapshot
-Flash: local snapshot

Default value: Standard', position='Query'),
}

model DescribeSnapshotMonitorDataResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.'),
  monitorData?: {
    dataPoint?: [ 
    {
      size?: long(name='Size', description='The total size of the snapshot. Unit: bytes.'),
      timeStamp?: string(name='TimeStamp', description='The timestamp corresponding to the size of a snapshot.'),
    }
  ](name='DataPoint')
  }(name='MonitorData', description='The collection of snapshot capacity change data.'),
}

model DescribeSnapshotMonitorDataResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeSnapshotMonitorDataResponseBody(name='body'),
}

/**
 * ## API description

When you call this operation, note that:

-A maximum of 400 monitoring data records can be returned at a time. If the specified parameter "(EndTime-StartTime)/" is greater than 400, an error is returned.

-You can query the monitoring information in the last 30 days at a time. If the specified "StartTime" parameter exceeds 30 days, an error is returned.
 */
async function describeSnapshotMonitorData(request: DescribeSnapshotMonitorDataRequest): DescribeSnapshotMonitorDataResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeSnapshotMonitorData', 'POST', 'undefined', 'json', false, 'none', request);
}

model DeregisterManagedInstanceRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  regionId?: string(name='RegionId', description='The ID of the region. Only China (Hangzhou), China (Beijing), and China (Shanghai) are supported.', position='Query'),
  instanceId?: string(name='InstanceId', description='The ID of the managed instance.', position='Query'),
}

model DeregisterManagedInstanceResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.'),
  instance?: {
    lastInvokedTime?: string(name='LastInvokedTime', description='The time when the cloud assistant task was last executed.'),
    internetIp?: string(name='InternetIp', description='The public IP address of the managed instance.'),
    hostname?: string(name='Hostname', description='The hostname of the managed instance.'),
    instanceId?: string(name='InstanceId', description='The ID of the managed instance.'),
    activationId?: string(name='ActivationId', description='Activation Code ID.'),
    intranetIp?: string(name='IntranetIp', description='The internal IP address of the managed instance.'),
    agentVersion?: string(name='AgentVersion', description='The version number of the cloud assistant client.'),
    registrationTime?: string(name='RegistrationTime', description='The registration time of the managed instance.'),
    instanceName?: string(name='InstanceName', description='The name of the managed instance.'),
    osType?: string(name='OsType', description='The operating system of the managed instance.'),
    osVersion?: string(name='OsVersion', description='The version of the operating system.'),
    invocationCount?: long(name='InvocationCount', description='The number of times that the managed instance performs cloud assistant tasks.'),
    machineId?: string(name='MachineId', description='The machine code of the managed instance.'),
  }(name='Instance', description='A collection of managed instance information.'),
}

model DeregisterManagedInstanceResponse = {
  headers: map[string]string(name='headers'),
  body: DeregisterManagedInstanceResponseBody(name='body'),
}

/**
 * * * * *
 */
async function deregisterManagedInstance(request: DeregisterManagedInstanceRequest): DeregisterManagedInstanceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeregisterManagedInstance', 'POST', 'undefined', 'json', false, 'none', request);
}

model AddIpRangeRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  zoneId?: string(name='ZoneId', position='Query'),
  ipAddress?: string(name='IpAddress', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
}

model AddIpRangeResponseBody = {
  requestId?: string(name='RequestId'),
}

model AddIpRangeResponse = {
  headers: map[string]string(name='headers'),
  body: AddIpRangeResponseBody(name='body'),
}

async function addIpRange(request: AddIpRangeRequest): AddIpRangeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'AddIpRange', 'POST', 'undefined', 'json', false, 'none', request);
}

model GetInstanceConsoleOutputRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='The account name of the resource master account.', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', description='The ID of the resource master account, that is, the UID.', position='Query'),
  regionId?: string(name='RegionId', description='The region ID of the instance. You can call [DescribeRegions](~~ 25609 ~~) to view the latest region list.', position='Query'),
  instanceId?: string(name='InstanceId', description='The ID of the instance.', position='Query'),
  removeSymbols?: boolean(name='RemoveSymbols', description='Specifies whether to remove the typesetting symbols from the returned text. Valid values:
-true: remove
-false: does not remove

Default value: false', position='Query'),
  ownerId?: long(name='OwnerId', description='The ID of the RAM user.', position='Query'),
}

model GetInstanceConsoleOutputResponseBody = {
  lastUpdateTime?: string(name='LastUpdateTime', description='The time when the instance was last started, restarted, or shut down. The time follows the [ISO8601](~~ 25696 ~~) standard and uses UTC time. The format is yyyy-MM-ddTHH:mm:ssZ.'),
  requestId?: string(name='RequestId', description='The ID of the request.'),
  instanceId?: string(name='InstanceId', description='The ID of the instance.'),
  consoleOutput?: string(name='ConsoleOutput', description='The system command output of the instance. The output is Base64-encoded.'),
}

model GetInstanceConsoleOutputResponse = {
  headers: map[string]string(name='headers'),
  body: GetInstanceConsoleOutputResponseBody(name='body'),
}

/**
 * ## API description

-An ECS instance is a virtual cloud service and cannot be connected to a display device or manually captured. However, Alibaba Cloud caches the system command output when the instance was last started, restarted, or shut down. You can call the GetInstanceConsoleOutput to obtain the output.

-[Phased-out instance types](~~ 55263 ~~) cannot obtain system command output.

-Windows instance does not support obtaining system command line output.
 */
async function getInstanceConsoleOutput(request: GetInstanceConsoleOutputRequest): GetInstanceConsoleOutputResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetInstanceConsoleOutput', 'POST', 'undefined', 'json', false, 'none', request);
}

model DeleteDiskReplicaPairRequest {
  ownerId?: long(name='OwnerId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  replicaPairId?: string(name='ReplicaPairId', description='The ID of the replication link. You can call [DescribeDiskReplicaPairs](~~ 209201 ~~) to query the replication relationship ID.', position='Query'),
  regionId?: string(name='RegionId', description='The region of the master disk. You can call [DescribeRegions](~~ 25609 ~~) to view the latest region list.', position='Query'),
}

model DeleteDiskReplicaPairResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.'),
}

model DeleteDiskReplicaPairResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteDiskReplicaPairResponseBody(name='body'),
}

/**
 * You can delete a replication relationship only when it is in the **paused" state. You can call this operation to delete only the replication relationship, but not the primary and secondary disks.

You must delete the replication relationship in the region where the primary disk is located. After the primary disk is deleted, you can mount, read, write, and scale out the secondary disk.
 */
async function deleteDiskReplicaPair(request: DeleteDiskReplicaPairRequest): DeleteDiskReplicaPairResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteDiskReplicaPair', 'POST', 'undefined', 'json', false, 'none', request);
}

model CancelImagePipelineExecutionRequest {
  templateTag?: [ 
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='TemplateTag', position='Query'),
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  regionId?: string(name='RegionId', description='Belongs geo ID. You can call [DescribeRegions](~~ 25609 ~~) to view the latest region list.', position='Query'),
  executionId?: string(name='ExecutionId', description='The ID of the build task.', position='Query'),
}

model CancelImagePipelineExecutionResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.'),
}

model CancelImagePipelineExecutionResponse = {
  headers: map[string]string(name='headers'),
  body: CancelImagePipelineExecutionResponseBody(name='body'),
}

/**
 * ## API description

Before calling this operation, make sure that the image BUILDING task to be canceled is in the BUILDING, DISTRIBUTING, or RELEASING state.
 */
async function cancelImagePipelineExecution(request: CancelImagePipelineExecutionRequest): CancelImagePipelineExecutionResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CancelImagePipelineExecution', 'POST', 'undefined', 'json', false, 'none', request);
}

model CreateCapacityReservationRequest {
  privatePoolOptions?: {
    matchCriteria?: string(name='MatchCriteria', description='The type of the private resource pool generated after the capacity reservation service takes effect. Valid values:

-Open: Open mode.
-Target: The dedicated mode.

Default value: Open', position=''),
    name?: string(name='Name', description='The name of the capacity reservation service. The description must be 2 to 128 characters in length. It must start with a letter and cannot start with "http:// "or "https. It can contain numbers, colons (:), underscores (_), and hyphens (-).', position=''),
  }(name='PrivatePoolOptions'),
  tag?: [ 
    {
      key?: string(name='Key', description='容量预定服务的标签键。N的取值范围：1~20。一旦传入该值，则不允许为空字符串。最多支持128个字符，不能以`aliyun`和`acs:`开头，不能包含`http://`或者`https://`。'),
      value?: string(name='Value', description='容量预定服务的标签值。N的取值范围：1~20。一旦传入该值，允许为空字符串。最多支持128个字符，不能以`acs:`开头，不能包含`http://`或者`https://`。'),
    }
  ](name='Tag', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  chargeType?: string(name='ChargeType', position='Query'),
  period?: int32(name='Period', position='Query'),
  periodUnit?: string(name='PeriodUnit', position='Query'),
  instanceChargeType?: string(name='InstanceChargeType', position='Query'),
  packageType?: string(name='PackageType', position='Query'),
  resourceType?: string(name='ResourceType', position='Query'),
  efficientStatus?: int32(name='EfficientStatus', position='Query'),
  timeSlot?: string(name='TimeSlot', position='Query'),
  instanceAmount?: int32(name='InstanceAmount', description='The total number of instances to be reserved within an instance type.', position='Query'),
  endTimeType?: string(name='EndTimeType', description='The expiration method of the capacity reservation service. Valid values:

-Limited: release at the specified time. You must specify the "EndTime" parameter at the same time.
-Unlimited: manually released. No time limit.', position='Query'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group to which the capacity reservation service belongs.', position='Query'),
  zoneId?: [ string ](name='ZoneId', description='The ID of the zone to which the capacity reservation service belongs. Currently, you can create a capacity reservation service in only one zone.', position='Query'),
  clientToken?: string(name='ClientToken', description='Ensure the idempotence of the request. Generate a parameter value from your client. Make sure that the value is unique among different requests. "ClientToken" only supports ASCII characters and cannot exceed 64 characters in length. For more information, see [how to ensure idempotence](~~ 25693 ~~).', position='Query'),
  regionId?: string(name='RegionId', description='The ID of the region to which the capacity reservation service belongs. You can call [DescribeRegions](~~ 25609 ~~) to view the latest region list.', position='Query'),
  endTime?: string(name='EndTime', description='The expiration time of the subscription service. The time format is ISO 8601 and UTC +0 is required. The format is yyyy-MM-ddTHH:mm:ssZ ". For more information, see [ISO8601](~~ 25696 ~~).', position='Query'),
  instanceType?: string(name='InstanceType', description='The instance type. Currently, you can only set the capacity reservation service for one instance type.', position='Query'),
  platform?: string(name='Platform', description='The operating system type of the image used by the instance. This parameter corresponds to the "Platform" parameter of the regional reserved instance. If the capacity reservation service matches the operating system type of the regional reserved instance, you can use the regional reserved instance to offset the unused capacity bill in the capacity reservation service. Valid values:

-Windows:Windows Server-type operating system.
-Linux:Linux and Unix-like operating systems.

Default value: Linux

> This parameter is not available.', position='Query'),
  startTime?: string(name='StartTime', description='The effective method of the capacity reservation service. You can call this operation to specify a time period that does not take effect immediately or takes effect immediately. You can only set this parameter to take effect immediately.

> If this parameter is not set, it takes effect immediately.', position='Query'),
  description?: string(name='Description', description='The description of the capacity reservation service. The description must be 2 to 256 characters in length and cannot start with "http:// "or "https.

Default value: Null.', position='Query'),
}

model CreateCapacityReservationResponseBody = {
  privatePoolOptionsId?: string(name='PrivatePoolOptionsId', description='The ID of the subscription service.'),
  requestId?: string(name='RequestId', description='The ID of the request.'),
}

model CreateCapacityReservationResponse = {
  headers: map[string]string(name='headers'),
  body: CreateCapacityReservationResponseBody(name='body'),
}

/**
 * ## API description

You can use the capacity reservation service to specify attributes such as zones and instance types. The system reserves resources that match the attributes in a private pool. For more information, see [active capacity reservation Overview](~~ 193633 ~~).

-Currently, only the active mode is supported. After you purchase a subscription service that takes effect immediately, instance types are billed according to the pay-as-you-go standard, regardless of whether a pay-as-you-go instance is actually created, capacity reservation takes effect immediately until you manually release it or the system automatically releases it upon expiration.
-You can use [CreateInstance](~~ 25499 ~~) or [RunInstances](~~ 63440 ~~) to set the private pool capacity option when creating an instance, or use [ModifyInstanceAttachmentAttributes](~~ 190006 ~~) you can call this operation to modify the private pool capacity of an instance. After the instance matches the capacity of the private pool, you are charged for the instance type, cloud disk, Internet bandwidth, and other resources based on your instance configuration.
-If no pay-as-you-go instance is created, only the instance type fee is charged.
-Pay-as-you-go instances and unused capacity bills that take effect immediately. You can use saving plans and regional Reserved Instances to offset hourly bills, hourly bills cannot be deducted from zone-Level Reserved instances. We recommend that you purchase a reserved instance or save plan first, and use the available capacity reservation service to guarantee the availability of resources for free.
 */
async function createCapacityReservation(request: CreateCapacityReservationRequest): CreateCapacityReservationResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateCapacityReservation', 'POST', 'undefined', 'json', false, 'none', request);
}

model ModifyCommandRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  commandContent?: string(name='CommandContent', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='The account name of the resource master account.', position='Query'),
  ownerId?: long(name='OwnerId', description='The ID of the RAM user.', position='Query'),
  name?: string(name='Name', description='The name of the command. The full character set is supported and cannot exceed 128 characters in length.', position='Query'),
  regionId?: string(name='RegionId', description='The ID of the region. You can call [DescribeRegions](~~ 25609 ~~) to view the latest region list.', position='Query'),
  workingDir?: string(name='WorkingDir', description='The execution path.', position='Query'),
  timeout?: long(name='Timeout', description='The maximum timeout period for a command to be executed on an ECS instance. Unit: seconds. When the command you created cannot be run and completed within the specified time, a timeout occurs. After a timeout, the command process is forcibly terminated, that is, the PID of the command is canceled.', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', description='The ID of the resource master account, that is, the UID.', position='Query'),
  commandId?: string(name='CommandId', description='The ID of the command. You can call the [DescribeCommands](~~ 64843 ~~) operation to query all available CommandId.', position='Query'),
  description?: string(name='Description', description='The description of the command. The full character set is supported and cannot exceed 512 characters in length.', position='Query'),
}

model ModifyCommandResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.'),
}

model ModifyCommandResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyCommandResponseBody(name='body'),
}

/**
 * ## API description

You can also modify the command during command execution. After the command is modified, it is executed according to the new command content.

You cannot modify the command type. For example, if the command is a Shell command (RunShellScript), it cannot be changed to a Bat command (RunBatScript).
 */
async function modifyCommand(request: ModifyCommandRequest): ModifyCommandResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyCommand', 'POST', 'undefined', 'json', false, 'none', request);
}

model ModifyPhysicalConnectionAttributeRequest {
  regionId?: string(name='RegionId', position='Query'),
  physicalConnectionId?: string(name='PhysicalConnectionId', position='Query'),
  lineOperator?: string(name='LineOperator', position='Query'),
  bandwidth?: int32(name='bandwidth', position='Query'),
  peerLocation?: string(name='PeerLocation', position='Query'),
  portType?: string(name='PortType', position='Query'),
  redundantPhysicalConnectionId?: string(name='RedundantPhysicalConnectionId', position='Query'),
  description?: string(name='Description', position='Query'),
  name?: string(name='Name', position='Query'),
  clientToken?: string(name='ClientToken', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  userCidr?: string(name='UserCidr', position='Query'),
  circuitCode?: string(name='CircuitCode', position='Query'),
}

model ModifyPhysicalConnectionAttributeResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyPhysicalConnectionAttributeResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyPhysicalConnectionAttributeResponseBody(name='body'),
}

async function modifyPhysicalConnectionAttribute(request: ModifyPhysicalConnectionAttributeRequest): ModifyPhysicalConnectionAttributeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyPhysicalConnectionAttribute', 'POST', 'undefined', 'json', false, 'none', request);
}

model CreateDiskReplicaPairRequest {
  ownerId?: long(name='OwnerId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  diskId?: string(name='DiskId', position='Query'),
  destinationRegionId?: string(name='DestinationRegionId', position='Query'),
  destinationDiskId?: string(name='DestinationDiskId', position='Query'),
  pairName?: string(name='PairName', position='Query'),
  description?: string(name='Description', position='Query'),
  asyncCycle?: int32(name='AsyncCycle', position='Query'),
}

model CreateDiskReplicaPairResponseBody = {
  pairId?: string(name='PairId'),
  requestId?: string(name='RequestId'),
}

model CreateDiskReplicaPairResponse = {
  headers: map[string]string(name='headers'),
  body: CreateDiskReplicaPairResponseBody(name='body'),
}

async function createDiskReplicaPair(request: CreateDiskReplicaPairRequest): CreateDiskReplicaPairResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateDiskReplicaPair', 'POST', 'undefined', 'json', false, 'none', request);
}

model DeleteHaVipRequest {
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  clientToken?: string(name='ClientToken', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  haVipId?: string(name='HaVipId', position='Query'),
}

model DeleteHaVipResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteHaVipResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteHaVipResponseBody(name='body'),
}

async function deleteHaVip(request: DeleteHaVipRequest): DeleteHaVipResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteHaVip', 'POST', 'undefined', 'json', false, 'none', request);
}

model ResizeVolumeRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  volumeId?: string(name='VolumeId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  newSize?: int32(name='NewSize', position='Query'),
  clientToken?: string(name='ClientToken', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
}

model ResizeVolumeResponseBody = {
  requestId?: string(name='RequestId'),
}

model ResizeVolumeResponse = {
  headers: map[string]string(name='headers'),
  body: ResizeVolumeResponseBody(name='body'),
}

async function resizeVolume(request: ResizeVolumeRequest): ResizeVolumeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ResizeVolume', 'POST', 'undefined', 'json', false, 'none', request);
}

model CreateRouteEntryRequest {
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  routeTableId?: string(name='RouteTableId', position='Query'),
  destinationCidrBlock?: string(name='DestinationCidrBlock', position='Query'),
  nextHopId?: string(name='NextHopId', position='Query'),
  clientToken?: string(name='ClientToken', position='Query'),
  nextHopType?: string(name='NextHopType', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  nextHopList?: [ 
    {
      nextHopId?: string(name='NextHopId'),
      nextHopType?: string(name='NextHopType'),
    }
  ](name='NextHopList', position='Query'),
}

model CreateRouteEntryResponseBody = {
  requestId?: string(name='RequestId'),
}

model CreateRouteEntryResponse = {
  headers: map[string]string(name='headers'),
  body: CreateRouteEntryResponseBody(name='body'),
}

async function createRouteEntry(request: CreateRouteEntryRequest): CreateRouteEntryResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateRouteEntry', 'POST', 'undefined', 'json', false, 'none', request);
}

model DeleteAutoProvisioningGroupRequest {
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  autoProvisioningGroupId?: string(name='AutoProvisioningGroupId', description='The ID of the auto provisioning group.', position='Query'),
  terminateInstances?: boolean(name='TerminateInstances', description='Specifies whether to release instances in an auto provisioning group. Valid values:

-true: Releases instances in the group.
-false: instances in the group continue to run.', position='Query'),
  regionId?: string(name='RegionId', description='The ID of the region where the auto provisioning Group is located.', position='Query'),
}

model DeleteAutoProvisioningGroupResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.'),
}

model DeleteAutoProvisioningGroupResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteAutoProvisioningGroupResponseBody(name='body'),
}

async function deleteAutoProvisioningGroup(request: DeleteAutoProvisioningGroupRequest): DeleteAutoProvisioningGroupResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteAutoProvisioningGroup', 'POST', 'undefined', 'json', false, 'none', request);
}

model ModifyVolumeAttributeRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  volumeId?: string(name='VolumeId', position='Query'),
  volumeName?: string(name='VolumeName', position='Query'),
  description?: string(name='Description', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
}

model ModifyVolumeAttributeResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyVolumeAttributeResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyVolumeAttributeResponseBody(name='body'),
}

async function modifyVolumeAttribute(request: ModifyVolumeAttributeRequest): ModifyVolumeAttributeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyVolumeAttribute', 'POST', 'undefined', 'json', false, 'none', request);
}

model StartImagePipelineExecutionRequest {
  templateTag?: [ 
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='TemplateTag', position='Query'),
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  regionId?: string(name='RegionId', description='Belongs geo ID. You can call [DescribeRegions](~~ 25609 ~~) to view the latest region list.', position='Query'),
  imagePipelineId?: string(name='ImagePipelineId', description='The ID of the image template.', position='Query'),
  clientToken?: string(name='ClientToken', description='Ensure the idempotence of the request. Generate a parameter value from your client. Make sure that the value is unique among different requests. **ClientToken** supports only ASCII characters and cannot exceed 64 characters. For more information, see [how to ensure idempotence](~~ 25693 ~~).', position='Query'),
}

model StartImagePipelineExecutionResponseBody = {
  executionId?: string(name='ExecutionId', description='The ID of the build task.'),
  requestId?: string(name='RequestId', description='The ID of the request.'),
}

model StartImagePipelineExecutionResponse = {
  headers: map[string]string(name='headers'),
  body: StartImagePipelineExecutionResponseBody(name='body'),
}

/**
 * ## API description

-After an image template is created, you need to call this operation to build an image. The system builds, distributes, and shares the image based on the parameters set in the image template.
-For the same image template, only one image building task can be performed at a time. You can cancel the image building task (CancelImagePipelineExecution) multiple times at the same time, and cancel the image building task and do not interfere with each other.
 */
async function startImagePipelineExecution(request: StartImagePipelineExecutionRequest): StartImagePipelineExecutionResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'StartImagePipelineExecution', 'POST', 'undefined', 'json', false, 'none', request);
}

model DescribeDiskReplicaPairsRequest {
  ownerId?: long(name='OwnerId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  maxResults?: int32(name='MaxResults', position='Query'),
  nextToken?: string(name='NextToken', position='Query'),
}

model DescribeDiskReplicaPairsResponseBody = {
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
  diskReplicaPairs?: {
    diskReplicaPair?: [ 
    {
      status?: string(name='Status'),
      sourceDiskId?: string(name='SourceDiskId'),
      replicaPairId?: string(name='ReplicaPairId'),
      description?: string(name='Description'),
      destinationRegion?: string(name='DestinationRegion'),
      pairName?: string(name='PairName'),
      sourceRegion?: string(name='SourceRegion'),
      destinationDiskId?: string(name='DestinationDiskId'),
    }
  ](name='DiskReplicaPair')
  }(name='DiskReplicaPairs'),
}

model DescribeDiskReplicaPairsResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeDiskReplicaPairsResponseBody(name='body'),
}

async function describeDiskReplicaPairs(request: DescribeDiskReplicaPairsRequest): DescribeDiskReplicaPairsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeDiskReplicaPairs', 'POST', 'undefined', 'json', false, 'none', request);
}

model ModifyInstanceNetworkSpecRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  internetMaxBandwidthOut?: int32(name='InternetMaxBandwidthOut', description='The maximum outbound Internet bandwidth. Unit: Mbit/s(Megabit per second). Valid values: 0 to 100.', position='Query'),
  internetMaxBandwidthIn?: int32(name='InternetMaxBandwidthIn', description='Set the maximum inbound public bandwidth. Unit: Mbit/s(Megabit per second). Valid values:

-When the purchased internet outbound bandwidth is less than or equal to 10 Mbit/s: 1 to 10, the default value is 10.
-When the purchased public outbound bandwidth is greater than 10 Mbit/s: 1 to "InternetMaxBandwidthOut". The default value is "InternetMaxBandwidthOut.', position='Query'),
  instanceId?: string(name='InstanceId', description='The ID of the instance to which you want to modify the network configuration.', position='Query'),
  networkChargeType?: string(name='NetworkChargeType', description='Change the network billing method. Valid values:

-PayByBandwidth: pay-by-bandwidth.
-PayByTraffic: pay by traffic.

> **pay-by-traffic** mode: The peak inbound and outbound bandwidth is the upper limit of the bandwidth and is not used as a service commitment indicator. When a resource scramble occurs, the peak bandwidth may be limited. If your business needs to be guaranteed by bandwidth, use the **pay-by-bandwidth** mode.

', position='Query'),
  allocatePublicIp?: boolean(name='AllocatePublicIp', description='Specifies whether to assign a public IP address.

Default value: false', position='Query'),
  startTime?: string(name='StartTime', description='The start time of the temporary bandwidth upgrade. The time follows the [ISO8601](~~ 25696 ~~) standard and uses UTC +0. The format is yyyy-MM-ddThh:mmZ. Accurate to **minutes**(mm).', position='Query'),
  clientToken?: string(name='ClientToken', description='Ensure the idempotence of the request. Generate a parameter value from your client. Make sure that the value is unique among different requests. **ClientToken** supports only ASCII characters and cannot exceed 64 characters. For more information, see [how to ensure idempotence](~~ 25693 ~~).', position='Query'),
  endTime?: string(name='EndTime', description='The end time of the temporary bandwidth upgrade. The time follows the [ISO8601](~~ 25696 ~~) standard and uses UTC +0. The format is yyyy-MM-ddThhZ. Accurate to **hour**(hh).

> The interval between the end time and start time of the temporary bandwidth upgrade must be greater than or equal to 3 hours.', position='Query'),
  autoPay?: boolean(name='AutoPay', description='Indicates whether to pay automatically. Valid values:

-true: fees are automatically deducted after the bandwidth configuration is changed. When you set the parameter Autopay to true, you must ensure that the account balance is sufficient. If the account balance is insufficient, an abnormal order is generated. This order cannot be paid in the ECS console and can only be invalidated.
-<props = "china">false: After the bandwidth configuration is changed, only the order is generated without deduction. If the balance of your payment method is insufficient, you can set the Autopay parameter to false to cancel automatic payment. In this case, a normal unpaid order is generated, you can log on to the [ECS console](https://ecs.console.aliyun.com) to pay for this order. </props>
-<props = "intl">false: After the bandwidth configuration is changed, only the order is generated without deduction. If the balance of your payment method is insufficient, you can set the Autopay parameter to false to cancel automatic payment. In this case, a normal unpaid order is generated, you can log on to the [ECS console](https://ecs.console.aliyun.com) to pay for this order. </props>
-<props = "partner">false: After the bandwidth configuration is changed, only the order is generated without deduction. If the balance of your payment method is insufficient, you can set the Autopay parameter to false to cancel automatic payment. In this case, a normal unpaid order is generated, you can log on to the [ECS console](https://partners-intl.console.aliyun.com/#/ecs) to pay for this order. </props>

Default value: true', position='Query'),
}

model ModifyInstanceNetworkSpecResponseBody = {
  orderId?: string(name='OrderId', description='The ID of the generated order.'),
  requestId?: string(name='RequestId', description='The ID of the request.'),
}

model ModifyInstanceNetworkSpecResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyInstanceNetworkSpecResponseBody(name='body'),
}

/**
 * ## API description

When you call this operation, note that:

-Starting from November 27, 2020, the peak bandwidth of an ECS instance is affected by the account speed limit policy. To increase the peak bandwidth, open a ticket. The specific speed limiting policy is as follows:
-In a single region, the total actual peak bandwidth of all ECS instances billed by traffic cannot exceed 5 Gbit/s.
-In a single region, the total actual peak bandwidth of all ECS instances that are billed by fixed bandwidth cannot exceed 50 Gbit/s.

-When you modify the bandwidth configuration of a subscription (PrePaid) instance, a public IP address is automatically allocated when the outbound public bandwidth (InternetMaxBandwidthOut) is upgraded from 0 Mbit/s to a non-zero value.

-When you modify the bandwidth configuration of a pay-as-you-go (PostPaid) instance, the public outbound bandwidth (InternetMaxBandwidthOut) is upgraded from 0 Mbit/s to a non-zero value. You must call [AllocatePublicIpAddress](~~ 25544 ~~) to assign a public IP address to the instance.

-For a Classic network (Classic) instance, when the outbound bandwidth (InternetMaxBandwidthOut) is upgraded from 0 Mbit/s to a non-zero value, the instance must be in the Stopped (Stopped) state.

-After the bandwidth is upgraded, the fee is automatically deducted by default. You must ensure that the balance of the payment method is sufficient. Otherwise, an abnormal order will be generated and the order can only be canceled. If your account balance is insufficient, you can set the AutoPay parameter to false. A normal unpaid order is generated. You can log on to the ECS console to pay for the order.

-The refund of the price difference before and after the bandwidth configuration is modified will be returned to your original payment method, and the used vouchers will not be returned.

 */
async function modifyInstanceNetworkSpec(request: ModifyInstanceNetworkSpecRequest): ModifyInstanceNetworkSpecResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyInstanceNetworkSpec', 'POST', 'undefined', 'json', false, 'none', request);
}

model ModifyInstanceDeploymentRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  deploymentSetGroupNo?: int32(name='DeploymentSetGroupNo', position='Query'),
  regionId?: string(name='RegionId', description='The region ID of the instance. You can call [DescribeRegions](~~ 25609 ~~) to view the latest region list.', position='Query'),
  instanceId?: string(name='InstanceId', description='The ID of the instance.', position='Query'),
  dedicatedHostClusterId?: string(name='DedicatedHostClusterId', description='The ID of the DDH cluster.', position='Query'),
  tenancy?: string(name='Tenancy', description='Indicates whether the instance is deployed on a dedicated host. Set the value to host. Only instances can be deployed on dedicated hosts.', position='Query'),
  deploymentSetId?: string(name='DeploymentSetId', description='The ID of the deployment set.

This parameter is required when you add an ECS instance to a deployment set or adjust the deployment set of the ECS instance.

> When you modify the parameters of a dedicated host ("tenance", "Affinity", and "DedicatedHostId"), you cannot modify the deployment set at the same time.', position='Query'),
  affinity?: string(name='Affinity', description='Indicates whether the instance is associated with a dedicated host. Valid values:

-host: associate. When an instance that has the shutdown saving mode enabled is stopped and started again, it is still deployed on the original dedicated host.

-default: Not Associated. When an instance that has the shutdown saving mode enabled is stopped and started again, if the original DDH resources are insufficient, it can be migrated to another DDH in the automatic deployment resource pool.

When an instance is migrated from a shared host to a dedicated host, the default value is default.', position='Query'),
  dedicatedHostId?: string(name='DedicatedHostId', description='The ID of the dedicated host. Call [DescribeDedicatedHosts](~~ 134242 ~~) to view available dedicated hosts.

When you modify the ECS instance host (that is, migrate the ECS instance from a shared host to a dedicated host, or migrate the ECS instance between different dedicated hosts):
-This parameter must be set if the instance is migrated to the specified DDH.
-If you want to migrate an instance to a dedicated host that is automatically selected by the system, you must set this parameter to null and set the parameter "tenance" to host.

For more information, see [features of dedicated hosts](~~ 118938 ~~).', position='Query'),
  migrationType?: string(name='MigrationType', description='Specifies whether to stop the instance before migrating it to the destination DDH. Valid values:

-reboot: stop the instance before migrating.

-live: directly migrates instances without stopping them. You must specify the parameter DedicatedHostId. You cannot change the instance type when you migrate an ECS instance.

Default value: reboot', position='Query'),
  force?: boolean(name='Force', description='Specifies whether to forcibly change the host of the instance. Valid values:

-true: Yes. You can restart an ECS instance in the Running (Running) or Stopped (Stopped) state. Instances in the stopped state do not include pay-as-you-go instances that have the shutdown mode enabled.
> If the specified ECS instance is equipped with a local disk, the local disk is also allowed to be forcibly replaced, which may cause data loss on the local disk when the host is replaced. Proceed with caution.

-false: this parameter is not allowed. Add a deployment set only to the current host. This may cause the replacement of the deployment set to fail.

Default value: false', position='Query'),
  instanceType?: string(name='InstanceType', description='The type of the target ECS instance to be changed. You can call the [DescribeInstanceTypes](~~ 25620 ~~) operation to obtain the latest instance types.

When you modify the host of an ECS instance, you can change the instance type at the same time. The specification of the target instance must match the specification of the specified DDH. For more information, see [DDH specification](~~ 68564 ~~).
-When you change the instance type, you must specify the DDH ID, that is, the value of the parameter "DedicatedHostId.
-When you use the automatic deployment feature to migrate an ECS instance, you cannot change the instance type.



', position='Query'),
}

model ModifyInstanceDeploymentResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.'),
}

model ModifyInstanceDeploymentResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyInstanceDeploymentResponseBody(name='body'),
}

/**
 * ## API description

When you migrate an ECS instance to a dedicated host or change the ECS instance type at the same time, you must meet the following requirements:

-The ECS instance must be in the **Stopped**(Stopped) state. The instance will restart automatically after migration.

-Only VPC-connected ECS instances are supported.

-The ECS instance and the dedicated host must belong to the same account, region, and zone.

-You can migrate a pay-as-you-go ECS instance to a subscription dedicated host. A subscription ECS instance can only be migrated between subscription dedicated hosts, and the expiration time of the instance cannot exceed the expiration time of the target dedicated host.

-When you migrate an ECS instance from a shared host to a dedicated host, the billing method of the instance can only be pay-as-you-go. Subscription instances and preemptible instances are not supported.

-You can redeploy an ECS instance by specifying a dedicated host cluster.
 */
async function modifyInstanceDeployment(request: ModifyInstanceDeploymentRequest): ModifyInstanceDeploymentResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyInstanceDeployment', 'POST', 'undefined', 'json', false, 'none', request);
}

model CreateVSwitchRequest {
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  zoneId?: string(name='ZoneId', position='Query'),
  cidrBlock?: string(name='CidrBlock', position='Query'),
  vpcId?: string(name='VpcId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  vSwitchName?: string(name='VSwitchName', position='Query'),
  description?: string(name='Description', position='Query'),
  clientToken?: string(name='ClientToken', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
}

model CreateVSwitchResponseBody = {
  vSwitchId?: string(name='VSwitchId'),
  requestId?: string(name='RequestId'),
}

model CreateVSwitchResponse = {
  headers: map[string]string(name='headers'),
  body: CreateVSwitchResponseBody(name='body'),
}

async function createVSwitch(request: CreateVSwitchRequest): CreateVSwitchResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateVSwitch', 'POST', 'undefined', 'json', false, 'none', request);
}

model DescribeElasticityAssurancesRequest {
  privatePoolOptions?: {
    ids?: string(name='Ids', description='The list of elastic protection service IDs. The value can be a JSON Array consisting of multiple ids. A maximum of 100 IDs can be entered. Separate IDs with commas (,).', position=''),
  }(name='PrivatePoolOptions'),
  tag?: [ 
    {
      key?: string(name='Key', description='标签键。N表示可以设置多个标签键进行过滤，N的取值范围：1~20。

使用一个标签过滤资源，查询到该标签下的资源数量不能超过1000个；使用多个标签过滤资源，查询到同时绑定了多个标签的资源数量不能超过1000个。如果资源数量超过1000个，请使用[ListTagResources](~~110425~~)接口进行查询。'),
      value?: string(name='Value', description='标签键。N表示可以设置多个标签键进行过滤，N的取值范围：1~20。'),
    }
  ](name='Tag', position='Query'),
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  platform?: string(name='Platform', position='Query'),
  packageType?: string(name='PackageType', position='Query'),
  nextToken?: string(name='NextToken', description='The start flag of the query. This parameter is obtained from the last request.', position='Query'),
  instanceType?: string(name='InstanceType', description='The instance type.', position='Query'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group.', position='Query'),
  regionId?: string(name='RegionId', description='The ID of the region to which the elastic Protection Service belongs. You can call [DescribeRegions](~~ 25609 ~~) to view the latest region list.', position='Query'),
  instanceChargeType?: string(name='InstanceChargeType', description='The billing method of the instance. Set the value to PostPaid. Currently, only pay-as-you-go is supported.

Default value: PostPaid', position='Query'),
  maxResults?: int32(name='MaxResults', description='The number of entries to return on each page.

Maximum Value: 100

Default value: 10', position='Query'),
  zoneId?: string(name='ZoneId', description='The ID of the zone to which the elastic Protection Service belongs.', position='Query'),
  status?: string(name='Status', description='The status of the elastic protection service. Valid values:

-Preparing: Preparing.
-Active: normal.
-Released: Released.

Default value: Active', position='Query'),
}

model DescribeElasticityAssurancesResponseBody = {
  nextToken?: string(name='NextToken', description='The start flag of the next query.'),
  requestId?: string(name='RequestId', description='The ID of the request.'),
  totalCount?: int32(name='TotalCount', description='The number of records that meet the query criteria.'),
  maxResults?: int32(name='MaxResults', description='The number of rows displayed on each page.'),
  elasticityAssuranceSet?: {
    elasticityAssuranceItem?: [ 
    {
      status?: string(name='Status', description='The status of the elastic protection service. Possible values:

-Preparing: Preparing.
-Active: normal.
-Released: Released.'),
      privatePoolOptionsMatchCriteria?: string(name='PrivatePoolOptionsMatchCriteria', description='The matching mode of the elastic protection service. Possible values:

-Open: the elastic guarantee service in the Open mode.
-Target: the elastic Protection Service of the specified mode.
'),
      privatePoolOptionsId?: string(name='PrivatePoolOptionsId', description='The ID of the elastic protection service.'),
      usedAssuranceTimes?: int32(name='UsedAssuranceTimes', description='> This parameter is not available.'),
      latestStartTime?: string(name='LatestStartTime', description='> This parameter is not available.'),
      privatePoolOptionsName?: string(name='PrivatePoolOptionsName', description='The name of the elastic protection service.'),
      regionId?: string(name='RegionId', description='The ID of the region to which the elastic Protection Service belongs.'),
      endTime?: string(name='EndTime', description='The expiration time of the elastic protection service.'),
      startTime?: string(name='StartTime', description='The effective time of the elastic protection service.'),
      description?: string(name='Description', description='The description of the elastic protection service.'),
      resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group.'),
      totalAssuranceTimes?: string(name='TotalAssuranceTimes', description='The total number of elastic protection services.'),
      allocatedResources?: {
        allocatedResource?: [ 
        {
          usedAmount?: int32(name='UsedAmount', description='The number of used instances.'),
          totalAmount?: int32(name='TotalAmount', description='The total number of instances to be reserved within an instance type.'),
          zoneId?: string(name='zoneId', description='The ID of the zone.'),
          instanceType?: string(name='InstanceType', description='The instance type.'),
        }
      ](name='AllocatedResource')
      }(name='AllocatedResources', description='The resource allocation details.'),
      tags?: {
        tag?: [ 
        {
          tagValue?: string(name='TagValue', description='The value of the tag.'),
          tagKey?: string(name='TagKey', description='The key of the tag.'),
        }
      ](name='Tag')
      }(name='Tags', description='The tag key-value pair associated with the elastic protection service.'),
    }
  ](name='ElasticityAssuranceItem')
  }(name='ElasticityAssuranceSet', description='A collection of details about elastic protection services.'),
}

model DescribeElasticityAssurancesResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeElasticityAssurancesResponseBody(name='body'),
}

async function describeElasticityAssurances(request: DescribeElasticityAssurancesRequest): DescribeElasticityAssurancesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeElasticityAssurances', 'POST', 'undefined', 'json', false, 'none', request);
}

model RemoveTagsRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  tag?: [ 
    {
      key?: string(name='key', description='资源的标签键。

>为提高兼容性，建议您尽量使用Tag.N.Key参数。'),
      value?: string(name='Value', description='资源的标签值。N的取值范围：1~20。一旦传入该值，可以为空字符串。最多支持128个字符，不能以aliyun和acs:开头，不能包含http://或者https://。'),
    }
  ](name='Tag', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='The account name of the resource master account.', position='Query'),
  ownerId?: long(name='OwnerId', description='The ID of the RAM user.', position='Query'),
  resourceId?: string(name='ResourceId', description='The ID of the resource to unbind the tag. For example, if the resource type (ResourceType) is an instance, the resource ID can be considered as the instance ID.', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', description='The ID of the resource master account, that is, the UID.', position='Query'),
  regionId?: string(name='RegionId', description='The region to which the resource belongs. You can call [DescribeRegions](~~ 25609 ~~) to view the latest region list.', position='Query'),
  resourceType?: string(name='ResourceType', description='The type of the resource. Valid values:

-disk
-instance
-image
-securitygroup
-snapshot

The preceding values are all in lowercase.', position='Query'),
}

model RemoveTagsResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.'),
}

model RemoveTagsResponse = {
  headers: map[string]string(name='headers'),
  body: RemoveTagsResponseBody(name='body'),
}

async function removeTags(request: RemoveTagsRequest): RemoveTagsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'RemoveTags', 'POST', 'undefined', 'json', false, 'none', request);
}

model RenewDedicatedHostsRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  dedicatedHostIds?: string(name='DedicatedHostIds', description='The ID of the dedicated host. You can enter up to 100 subscription DDH IDs. The IDs of multiple dedicated hosts are in the same format as "["dh-xxxxxxxxx", "dh-yyyyyyyyy",... "dh-zzzzzzzzz"] "The JSON Array said ID between separate them with commas (,).', position='Query'),
  regionId?: string(name='RegionId', description='The ID of the region to which the dedicated host belongs. You can call [DescribeRegions](~~ 25609 ~~) to view the latest region list.', position='Query'),
  period?: int32(name='Period', description='The renewal period. Valid values: For more information, see the description of the "$dune" parameter.', position='Query'),
  clientToken?: string(name='ClientToken', description='Ensure the idempotence of the request. Generate a parameter value from your client. Make sure that the value is unique among different requests. Only ASCII characters are supported and cannot exceed 64 characters in length. For more information, see [how to ensure idempotence](~~ 25693 ~~).', position='Query'),
  periodUnit?: string(name='PeriodUnit', description='The renewal period. Unit. Valid values:

-Week: Week. The value range of the "1" parameter is {1, 2, 3, 4}.

-Month (default): Month. The value range of the "$" parameter is {1, 2, 3, 4, 5, 6, 7, 8, 9, 12, 24, 36, 48, 60}.
', position='Query'),
}

model RenewDedicatedHostsResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.'),
}

model RenewDedicatedHostsResponse = {
  headers: map[string]string(name='headers'),
  body: RenewDedicatedHostsResponseBody(name='body'),
}

/**
 * ## API description

<props = "china"> when you renew the payment, you must use the deductible voucher first, and your account must support account balance payment or credit payment. </props>

<props = "intl"> when you renew the payment, you must use the deductible voucher first, and your account must support credit payment. </props>

<props = "partner"> when you renew the payment, you must use the deductible voucher first, and your account must support credit payment. </props>

 */
async function renewDedicatedHosts(request: RenewDedicatedHostsRequest): RenewDedicatedHostsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'RenewDedicatedHosts', 'POST', 'undefined', 'json', false, 'none', request);
}

model CancelSimulatedSystemEventsRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', description='The ID of the RAM user.', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='The account name of the resource master account.', position='Query'),
  regionId?: string(name='RegionId', description='The ID of the region. You can call [DescribeRegions](~~ 25609 ~~) to view the latest region list.', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', description='The ID of the resource master account, that is, the UID.', position='Query'),
  eventId?: [ string ](name='EventId', description='The ID of one or more system events. Valid values of N: 1 to 100. Multiple values are in the form of duplicate lists.', position='Query'),
}

model CancelSimulatedSystemEventsResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.'),
}

model CancelSimulatedSystemEventsResponse = {
  headers: map[string]string(name='headers'),
  body: CancelSimulatedSystemEventsResponseBody(name='body'),
}

async function cancelSimulatedSystemEvents(request: CancelSimulatedSystemEventsRequest): CancelSimulatedSystemEventsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CancelSimulatedSystemEvents', 'POST', 'undefined', 'json', false, 'none', request);
}

model DescribeAvailableResourceRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  spotDuration?: int32(name='SpotDuration', position='Query'),
  scope?: string(name='Scope', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='The account name of the resource master account.', position='Query'),
  zoneId?: string(name='ZoneId', description='The ID of the zone.

Default value: None, indicating that the zones in the current region are randomly allocated, and the resources that meet the query criteria in all zones in the region ("RegionId") are returned.', position='Query'),
  ioOptimized?: string(name='IoOptimized', description='Indicates whether the instance is I/O optimized. Valid values:

-none: Non-I/O optimized instance
-optimized:I/O optimized instance


Default value: optimized', position='Query'),
  memory?: float(name='Memory', description='The memory size of the instance type. Unit: GiB. For more information, see [instance type family](~~ 25378 ~~).

Memory is a valid parameter only when the DestinationResource is set to InstanceType.', position='Query'),
  systemDiskCategory?: string(name='SystemDiskCategory', description='The system disk type. Valid values:

-cloud: basic cloud disk
-cloud_efficiency: Ultra disk
-cloud_ssd:SSD cloud disk
-ephemeral_ssd: local SSD
-cloud_essd:ESSD

If the parameter DestinationResource is set to SystemDisk, InstanceType, or DataDisk, the parameter SystemDiskCategory is not required.

Default value: cloud_efficiency', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', description='The ID of the resource master account, that is, the UID.', position='Query'),
  destinationResource?: string(name='DestinationResource', description='The type of the resource to query. Valid values:

-Zone: Zone
-IoOptimized:I/O optimization
-InstanceType: instance type
-SystemDisk: system disk
-DataDisk: data disk
-Network: Network type
-ddh: Dedicated host

For more information about how to DestinationResource parameters, see the preceding operations.', position='Query'),
  regionId?: string(name='RegionId', description='The ID of the destination region. You can call [DescribeRegions](~~ 25609 ~~) to view the latest region list.', position='Query'),
  ownerId?: long(name='OwnerId', description='The ID of the RAM user.', position='Query'),
  dedicatedHostId?: string(name='DedicatedHostId', description='The ID of the dedicated host.', position='Query'),
  instanceType?: string(name='InstanceType', description='The instance type. For more information, see [instance type family](~~ 25378 ~~), or call [DescribeInstanceTypes](~~ 25620 ~~) to obtain the latest specification.

If the parameter DestinationResource is set to SystemDisk or DataDisk, InstanceType is required.', position='Query'),
  spotStrategy?: string(name='SpotStrategy', description='The preemptible policy of the pay-as-you-go instance. Valid values:

-NoSpot: a pay-as-you-go instance.
-SpotWithPriceLimit: sets the maximum price for preemptible instances.
-SpotAsPriceGo: The system automatically bids at the highest pay-as-you-go price.

Default value: NoSpot

The parameter InstanceChargeType is valid only when the parameter PostPaid is set to SpotStrategy.', position='Query'),
  cores?: int32(name='Cores', description='The number of vCPU cores of the instance type. For more information, see [instance type family](~~ 25378 ~~).

This parameter is valid only when the DestinationResource is set to InstanceType.', position='Query'),
  instanceChargeType?: string(name='InstanceChargeType', description='The billing method of the resource. For more information, see [billing Overview](~~ 25398 ~~). Valid values:

-PrePaid: Subscription
-PostPaid: pay-as-you-go

Default value: PostPaid', position='Query'),
  dataDiskCategory?: string(name='DataDiskCategory', description='The data disk type. Valid values:

-cloud: basic cloud disk
-cloud_efficiency: Ultra disk
-cloud_ssd:SSD cloud disk
-ephemeral_ssd: local SSD
-cloud_essd:ESSD', position='Query'),
  networkCategory?: string(name='NetworkCategory', description='The network type. Valid values:

-vpc: vpc
-classic: classic Network
', position='Query'),
  resourceType?: string(name='ResourceType', description='The type of the resource. Valid values:

-instance:ECS instance
-disk: Cloud disk
-reservedinstance: Reserved Instance
-ddh: Dedicated host', position='Query'),
}

model DescribeAvailableResourceResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.'),
  availableZones?: {
    availableZone?: [ 
    {
      zoneId?: string(name='ZoneId', description='The ID of the zone.'),
      status?: string(name='Status', description='The status of the resource. Possible values:

-Available: sufficient resources
-SoldOut: resources are sold out
'),
      statusCategory?: string(name='StatusCategory', description='Resource categories are classified by inventory. Possible values:

-WithStock: the inventory is sufficient.
-ClosedWithStock: the inventory guarantee capability is low. We recommend that you select WithStock product specifications.
-WithoutStock: the inventory is sold out and resources will be replenished. We recommend that you select WithStock product specifications.
-ClosedWithoutStock: the inventory is sold out and no additional resources are available. Select a WithStock product specification.'),
      regionId?: string(name='RegionId', description='The ID of the region.'),
      availableResources?: {
        availableResource?: [ 
        {
          type?: string(name='Type', description='The type of the resource. Possible values:

-Zone: Zone
-IoOptimized:I/O optimization
-InstanceType: instance type
-SystemDisk: system disk
-DataDisk: data disk
-Network: Network type
-ddh: Dedicated host
'),
          supportedResources?: {
            supportedResource?: [ 
            {
              status?: string(name='Status', description='The status of the resource. Possible values:

-Available: sufficient resources
-SoldOut: resources are sold out
'),
              value?: string(name='Value', description='The value of the resource.'),
              max?: int32(name='Max', description='The maximum value of the resource type. If this parameter is empty, no value is returned.'),
              unit?: string(name='Unit', description='The unit of the resource type. If the value of this parameter is null, no return is returned.'),
              statusCategory?: string(name='StatusCategory', description='Resource categories are classified by inventory. Possible values:

-WithStock: the inventory is sufficient.
-ClosedWithStock: the inventory guarantee capability is low. We recommend that you select WithStock product specifications.
-WithoutStock: the inventory is sold out and resources will be replenished. We recommend that you select WithStock product specifications.
-ClosedWithoutStock: the inventory is sold out and no additional resources are available. Select a WithStock product specification.'),
              min?: int32(name='Min', description='The minimum value of the resource type. If this parameter is empty, no value is returned.'),
            }
          ](name='SupportedResource')
          }(name='SupportedResources', description='An array of specific resources that can be created.'),
        }
      ](name='AvailableResource')
      }(name='AvailableResources', description='An array of specific resources that can be created.'),
    }
  ](name='AvailableZone')
  }(name='AvailableZones', description='A collection of inventory information.'),
}

model DescribeAvailableResourceResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeAvailableResourceResponseBody(name='body'),
}

/**
 * ## API description

The value of the "DestinationResource" parameter has different logic and requirements. In the following order list, you need to set more parameters for values with a lower order. You cannot filter resource categories with a lower order.

-Value sequence: "Zone > IoOptimized > InstanceType = Network = ddh > SystemDisk > DataDisk"


-Valid values:

-If the value of "DestinationResource" is "DataDisk", you must specify the "InstanceType" parameter or set the value of "ResourceType" to "disk ".

-If the value of "DestinationResource" is "SystemDisk", you must specify "InstanceType ".

-If the value of "DestinationResource" is "InstanceType", you must specify the parameters "IoOptimized" and "InstanceType ".

-Query the ecs.g5.large inventory of all zones in a specified region: "RegionId = cn-hangzhou & DestinationResource = InstanceType & IoOptimized = optimized & InstanceType = ecs.g5.large ".

-Query the List of zones with ecs.g5.large inventory in a specified region: "RegionId = cn-hangzhou & DestinationResource = Zone & IoOptimized = optimized & InstanceType = ecs.g5.large ".
 */
async function describeAvailableResource(request: DescribeAvailableResourceRequest): DescribeAvailableResourceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeAvailableResource', 'POST', 'undefined', 'json', false, 'none', request);
}

model DescribePrefixListAssociationsRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  regionId?: string(name='RegionId', description='The ID of the region.', position='Query'),
  nextToken?: string(name='NextToken', description='Query the credential (Token). The value is the value of the "NextToken" parameter returned by the last call to the API. You do not need to set this parameter when you call the API for the first time.', position='Query'),
  maxResults?: int32(name='MaxResults', description='The number of entries to return on each page.

Maximum Value: 100

Default value: 10', position='Query'),
  prefixListId?: string(name='PrefixListId', description='The ID of the prefix list.', position='Query'),
}

model DescribePrefixListAssociationsResponseBody = {
  nextToken?: string(name='NextToken', description='The Token returned by this call. If the returned value is null, no more data is returned.'),
  requestId?: string(name='RequestId', description='The ID of the request.'),
  prefixListAssociations?: {
    prefixListAssociation?: [ 
    {
      resourceId?: string(name='ResourceId', description='The ID of the resource.'),
      resourceType?: string(name='ResourceType', description='The type of the resource.'),
    }
  ](name='PrefixListAssociation')
  }(name='PrefixListAssociations', description='An array of associated resources in the prefix list.'),
}

model DescribePrefixListAssociationsResponse = {
  headers: map[string]string(name='headers'),
  body: DescribePrefixListAssociationsResponseBody(name='body'),
}

async function describePrefixListAssociations(request: DescribePrefixListAssociationsRequest): DescribePrefixListAssociationsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribePrefixListAssociations', 'POST', 'undefined', 'json', false, 'none', request);
}

model DescribeDedicatedHostsRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  tag?: [ 
    {
      key?: string(name='Key', description='专有宿主机的标签键。N的取值范围：1~20。一旦传入该值，则不允许为空字符串。最多支持128个字符，不能以`aliyun`和`acs:`开头，不能包含`http://`或`https://`。'),
      value?: string(name='Value', description='专有宿主机的标签值。N的取值范围：1~20。一旦传入该值，可以为空字符串。最多支持128个字符，不能以`aliyun`和`acs:`开头，不能包含`http://`或者`https://`。'),
    }
  ](name='Tag', position='Query'),
  regionId?: string(name='RegionId', description='The ID of the region to which the dedicated host belongs. You can call [DescribeRegions](~~ 25609 ~~) to view the latest region list.', position='Query'),
  zoneId?: string(name='ZoneId', description='The ID of the zone.', position='Query'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group to which the DDH belongs.', position='Query'),
  pageNumber?: int32(name='PageNumber', description='The number of pages to return.

Default value: 1.', position='Query'),
  dedicatedHostClusterId?: string(name='DedicatedHostClusterId', description='The ID of the DDH cluster.', position='Query'),
  status?: string(name='Status', description='The status of the dedicated host. Valid values:

-Available: running. The running status of the dedicated host.

-UnderAssessment: a physical machine is at risk, that is, the latency of a failure. The physical machine is in the available state, but may cause problems with ECS instances on the dedicated host.

-PermanentFailure: fault. The dedicated host is unavailable due to a permanent failure.

Default value: Available', position='Query'),
  pageSize?: int32(name='PageSize', description='The number of rows per page of the response information. Maximum Value: 100

Default value: 10', position='Query'),
  dedicatedHostName?: string(name='DedicatedHostName', description='The name of the dedicated host.', position='Query'),
  dedicatedHostType?: string(name='DedicatedHostType', description='The type of the dedicated host.', position='Query'),
  dedicatedHostIds?: string(name='DedicatedHostIds', description='The ID of the dedicated host. You can specify up to 100 IDs at a time. Separate IDs with commas (,).', position='Query'),
  lockReason?: string(name='LockReason', description='The reason why the dedicated host is locked. Valid values:
-financial: locked due to overdue payments.
-security: locked for security reasons.', position='Query'),
}

model DescribeDedicatedHostsResponseBody = {
  pageSize?: int32(name='PageSize', description='The number of entries to return on each page.'),
  requestId?: string(name='RequestId', description='The ID of the request.'),
  pageNumber?: int32(name='PageNumber', description='The page number of the DDH list.'),
  totalCount?: int32(name='TotalCount', description='The total number of dedicated hosts.'),
  dedicatedHosts?: {
    dedicatedHost?: [ 
    {
      creationTime?: string(name='CreationTime', description='The time when the dedicated host was created. The time follows the [ISO8601](~~ 25696 ~~) standard and uses UTC +0. The format is "yyyy-MM-ddTHH:mmZ ".'),
      status?: string(name='Status', description='The status of the dedicated host. Possible values:

-Available: running. The running status of the dedicated host.

-UnderAssessment: a physical machine is at risk, that is, the latency of a failure. The physical machine is in the available state, but may cause problems with ECS instances on the dedicated host.

-PermanentFailure: fault. The dedicated host is unavailable due to a permanent failure.'),
      cores?: int32(name='Cores', description='The number of cores per CPU.'),
      autoPlacement?: string(name='AutoPlacement', description='Indicates whether the dedicated host is added to the automatic deployment resource pool. Valid values:

-on: added to the automatic deployment resource pool.

-off: does not join the automatic deployment resource pool.

For more information about automatic deployment, see [automatic deployment features](~~ 118938 ~~).'),
      GPUSpec?: string(name='GPUSpec', description='The GPU model.'),
      autoReleaseTime?: string(name='AutoReleaseTime', description='The automatic release time. The time follows the [ISO8601](~~ 25696 ~~) standard and uses UTC +0. The format is "yyyy-MM-ddTHH:mmZ ".'),
      chargeType?: string(name='ChargeType', description='The billing method of the dedicated host.'),
      cpuOverCommitRatio?: float(name='CpuOverCommitRatio', description='CPU oversold ratio.'),
      actionOnMaintenance?: string(name='ActionOnMaintenance', description='When a dedicated host fails or is repaired online, you can configure a migration solution for the host. Valid values:

-Migrate: Migrate the instance to another physical machine and restart the instance.

Default: Migrate (when proprietary host Mount cloud storage)

-Stop: Stop the instance on the current DDH. After confirming that the DDH cannot be repaired, migrate the instance to another physical machine and restart the instance.

Default: Stop (when proprietary host mount local disk storage)'),
      saleCycle?: string(name='SaleCycle', description='Subscription unit. Possible values:
-Month
-Year'),
      physicalGpus?: int32(name='PhysicalGpus', description='The number of physical GPUs.'),
      regionId?: string(name='RegionId', description='The region ID of the dedicated host.'),
      dedicatedHostName?: string(name='DedicatedHostName', description='The name of the dedicated host.'),
      description?: string(name='Description', description='The description of the dedicated host.'),
      dedicatedHostClusterId?: string(name='DedicatedHostClusterId', description='The ID of the DDH cluster to which the DDH belongs.'),
      expiredTime?: string(name='ExpiredTime', description='The expiration time of the dedicated host. The time follows the [ISO8601](~~ 25696 ~~) standard and uses UTC +0. The format is "yyyy-MM-ddTHH:mmZ ".'),
      dedicatedHostType?: string(name='DedicatedHostType', description='The type of the dedicated host.'),
      resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group to which the DDH belongs.'),
      zoneId?: string(name='ZoneId', description='The ID of the zone.'),
      dedicatedHostId?: string(name='DedicatedHostId', description='The ID of the dedicated host.'),
      sockets?: int32(name='Sockets', description='The number of physical processors.'),
      machineId?: string(name='MachineId', description='The machine code of the dedicated host.'),
      instances?: {
        instance?: [ 
        {
          instanceType?: string(name='InstanceType', description='The type of the ECS instance created on the DDH.'),
          instanceId?: string(name='InstanceId', description='The ID of the ECS instance created on the DDH.'),
        }
      ](name='Instance')
      }(name='Instances', description='The ECS instance created on the DDH.'),
      operationLocks?: {
        operationLock?: [ 
        {
          lockReason?: string(name='LockReason', description='The reason why the dedicated host is locked. Possible values:
-financial: locked due to overdue payments.
-security: locked for security reasons.'),
        }
      ](name='OperationLock')
      }(name='OperationLocks', description='The reason why the DDH resource is locked.'),
      tags?: {
        tag?: [ 
        {
          tagValue?: string(name='TagValue', description='The tag value of the dedicated host.'),
          tagKey?: string(name='TagKey', description='The tag key of the dedicated host.'),
        }
      ](name='Tag')
      }(name='Tags', description='The tag of the dedicated host.'),
      supportedInstanceTypeFamilies?: {
        supportedInstanceTypeFamily?: [ string ](name='SupportedInstanceTypeFamily')
      }(name='SupportedInstanceTypeFamilies', description='The ECS instance type families supported by the dedicated host.'),
      supportedCustomInstanceTypeFamilies?: {
        supportedCustomInstanceTypeFamily?: [ string ](name='SupportedCustomInstanceTypeFamily')
      }(name='SupportedCustomInstanceTypeFamilies', description='The custom instance families supported by the dedicated host.'),
      supportedInstanceTypesList?: {
        supportedInstanceTypesList?: [ string ](name='SupportedInstanceTypesList')
      }(name='SupportedInstanceTypesList', description='The ECS instance type supported by the dedicated host.'),
      capacity?: {
        availableMemory?: float(name='AvailableMemory', description='The remaining memory capacity. Unit: GiB.'),
        localStorageCategory?: string(name='LocalStorageCategory', description='The type of the local disk.'),
        totalMemory?: float(name='TotalMemory', description='The total memory capacity. Unit: GiB.'),
        totalLocalStorage?: int32(name='TotalLocalStorage', description='The total capacity of the local disk. Unit: GiB.'),
        totalVcpus?: int32(name='TotalVcpus', description='The total number of vCPU cores.'),
        totalVgpus?: int32(name='TotalVgpus', description='The total number of virtual GPUs.'),
        availableLocalStorage?: int32(name='AvailableLocalStorage', description='The remaining capacity of the local disk. Unit: GiB.'),
        availableVcpus?: int32(name='AvailableVcpus', description='The number of remaining vCPU cores.'),
        availableVgpus?: int32(name='AvailableVgpus', description='The number of available virtual GPUs.'),
      }(name='Capacity', description='The set of dedicated host performance metrics.'),
      networkAttributes?: {
        udpTimeout?: int32(name='UdpTimeout', description='The UDP timeout period.'),
        slbUdpTimeout?: int32(name='SlbUdpTimeout', description='SLB UDP timeout period.'),
      }(name='NetworkAttributes', description='The network attribute value of the DDH.'),
      hostDetailInfo?: {
        serialNumber?: string(name='SerialNumber', description='This parameter will be removed soon. We recommend that you use other parameters to improve compatibility.'),
      }(name='HostDetailInfo', description='This parameter will be removed soon. We recommend that you use other parameters to improve compatibility.'),
    }
  ](name='DedicatedHost')
  }(name='DedicatedHosts', description='The detailed information of the dedicated host.'),
}

model DescribeDedicatedHostsResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeDedicatedHostsResponseBody(name='body'),
}

/**
 * ## API description

You can query the details of one or more dedicated hosts in any of the following ways:

-Specify "DedicatedHostIds" to query the details of a dedicated host.
-Specify "DedicatedHostClusterId" to query the details of dedicated hosts in a dedicated host cluster.
 */
async function describeDedicatedHosts(request: DescribeDedicatedHostsRequest): DescribeDedicatedHostsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeDedicatedHosts', 'POST', 'undefined', 'json', false, 'none', request);
}

model DescribeSoftDeletedCoolingTimeRequest {
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  clientToken?: string(name='ClientToken', position='Query'),
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
}

model DescribeSoftDeletedCoolingTimeResponseBody = {
  requestId?: string(name='RequestId', description='Id of the request'),
  data?: long(name='data'),
}

model DescribeSoftDeletedCoolingTimeResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeSoftDeletedCoolingTimeResponseBody(name='body'),
}

async function describeSoftDeletedCoolingTime(request: DescribeSoftDeletedCoolingTimeRequest): DescribeSoftDeletedCoolingTimeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeSoftDeletedCoolingTime', 'POST', 'undefined', 'json', false, 'none', request);
}

model DescribeFleetInstancesRequest {
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  pageNumber?: int32(name='PageNumber', position='Query'),
  pageSize?: int32(name='PageSize', position='Query'),
  fleetId?: string(name='FleetId', position='Query'),
}

model DescribeFleetInstancesResponseBody = {
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  pageNumber?: int32(name='PageNumber'),
  totalCount?: int32(name='TotalCount'),
  instances?: {
    instance?: [ 
    {
      creationTime?: string(name='CreationTime'),
      status?: string(name='Status'),
      zoneNo?: string(name='ZoneNo'),
      cores?: int32(name='Cores'),
      isSpot?: boolean(name='IsSpot'),
      instanceId?: string(name='InstanceId'),
      networkType?: boolean(name='NetworkType'),
      instanceType?: string(name='InstanceType'),
      regionId?: string(name='RegionId'),
      ioOptimized?: boolean(name='IoOptimized'),
      osType?: boolean(name='OsType'),
      memory?: int32(name='Memory'),
      izNo?: string(name='IzNo'),
    }
  ](name='Instance')
  }(name='Instances'),
}

model DescribeFleetInstancesResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeFleetInstancesResponseBody(name='body'),
}

async function describeFleetInstances(request: DescribeFleetInstancesRequest): DescribeFleetInstancesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeFleetInstances', 'POST', 'undefined', 'json', false, 'none', request);
}

model RebootInstancesRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  instanceId?: [ string ](name='InstanceId', description='The ID of the instance. Valid values of N: 1 to 100.', position='Query'),
  forceReboot?: boolean(name='ForceReboot', description='Indicates whether to forcibly restart the instance. Valid values:

-true: force restart. This is equivalent to a typical power-off operation. All cached data that is not written to the storage device will be lost.

-false: the instance is restarted.

Default value: false', position='Query'),
  regionId?: string(name='RegionId', description='The region of the instance. You can call [DescribeRegions](~~ 25609 ~~) to view the latest region list.', position='Query'),
  dryRun?: boolean(name='DryRun', description='Specifies whether to PreCheck only this request. Valid values:

-true: sends a check request and does not restart the instance. Check items include required parameters, request format, and instance status. If the check fails, the corresponding error is returned. If the check succeeds, "DRYRUN.SUCCESS" is returned ".
> If the "BatchOptimization" parameter is set to "SuccessFirst", only "DryRun. SUCCESS" is returned for the PreCheck result of "DRYRUN = true ".

-false: Sends a normal request and restarts the instance after passing the check.

Default value: false', position='Query'),
  batchOptimization?: string(name='BatchOptimization', description='Set the batch operation mode. Valid values:

-AllTogether: In this mode, if all instances are restarted successfully, a success message is returned. If any instance fails the verification, all instances fail to be restarted and a failure message is returned.

-SuccessFirst: In this mode, each instance is restarted separately. The returned results include the operation results of each instance.

Default value: AllTogether', position='Query'),
}

model RebootInstancesResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.'),
  instanceResponses?: {
    instanceResponse?: [ 
    {
      code?: string(name='Code', description='The error code of the instance operation result. The return value 200 is successful. For more information, see the following error codes.'),
      message?: string(name='Message', description='The error message returned for the instance operation. The Success returned value is successful. For more information, see the following error codes.'),
      instanceId?: string(name='InstanceId', description='The ID of the instance.'),
      currentStatus?: string(name='CurrentStatus', description='The current status of the instance.'),
      previousStatus?: string(name='PreviousStatus', description='The status of the instance before the operation.'),
    }
  ](name='InstanceResponse')
  }(name='InstanceResponses', description='An array consisting of InstanceResposne, which returns the status and result of each instance operation.'),
}

model RebootInstancesResponse = {
  headers: map[string]string(name='headers'),
  body: RebootInstancesResponseBody(name='body'),
}

/**
 * ## API description

-The status of the ECS instance must be **running**("Running").

-Batch operations are supported. You can set the batch operation mode by using the "BatchOptimization" parameter.

-Force restart ("ForceReboot") is supported. Force restart is equivalent to a power-off restart on a traditional server. Data that is not written to block storage in the operating system of an instance may be lost.

-When querying ECS instance information, if the returned data contains "{"OperationLocks": {"LockReason" : "security"}}", all operations are prohibited.
 */
async function rebootInstances(request: RebootInstancesRequest): RebootInstancesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'RebootInstances', 'POST', 'undefined', 'json', false, 'none', request);
}

model DescribeActivationsRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  regionId?: string(name='RegionId', description='The ID of the region. Only China (Hangzhou), China (Beijing), and China (Shanghai) are supported.', position='Query'),
  instanceName?: string(name='InstanceName', description='The default instance name prefix.', position='Query'),
  pageNumber?: long(name='PageNumber', description='The current page number.

Start value: 1

Default value: 1.', position='Query'),
  activationId?: string(name='ActivationId', description='Activation Code ID.', position='Query'),
  pageSize?: long(name='PageSize', description='The number of entries to return on each page.

Maximum Value: 50

Default value: 10', position='Query'),
}

model DescribeActivationsResponseBody = {
  pageSize?: long(name='PageSize', description='The number of entries to return on each page.'),
  requestId?: string(name='RequestId', description='The ID of the request.'),
  pageNumber?: long(name='PageNumber', description='The current page number.'),
  totalCount?: long(name='TotalCount', description='The number of records that meet the query criteria.'),
  activationList?: [ 
    {
      creationTime?: string(name='CreationTime', description='The creation time.'),
      deregisteredCount?: int32(name='DeregisteredCount', description='The number of canceled instances.'),
      instanceCount?: int32(name='InstanceCount', description='The maximum number of times an activation code is used to register a managed instance.'),
      description?: string(name='Description', description='The description of the activation code.'),
      registeredCount?: int32(name='RegisteredCount', description='The number of registered instances.'),
      instanceName?: string(name='InstanceName', description='The default instance name prefix.'),
      disabled?: boolean(name='Disabled', description='Indicates whether the activation code is disabled.'),
      ipAddressRange?: string(name='IpAddressRange', description='The IP address of the host that allows the activation code.'),
      timeToLiveInHours?: long(name='TimeToLiveInHours', description='The validity period of the activation code. Unit: Hour'),
      activationId?: string(name='ActivationId', description='Activation Code ID.'),
    }
  ](name='ActivationList', description='A collection of activation codes and usage information.'),
}

model DescribeActivationsResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeActivationsResponseBody(name='body'),
}

/**
 * * * * *
 */
async function describeActivations(request: DescribeActivationsRequest): DescribeActivationsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeActivations', 'POST', 'undefined', 'json', false, 'none', request);
}

model DetachClassicLinkVpcRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  resourceOwnerId?: long(name='ResourceOwnerId', description='The ID of the resource master account, that is, the UID.', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='The account name of the resource master account.', position='Query'),
  ownerId?: long(name='OwnerId', description='The ID of the RAM user.', position='Query'),
  instanceId?: string(name='InstanceId', description='The ID of the classic network instance.', position='Query'),
  regionId?: string(name='RegionId', description='The ID of the region to which the instance belongs. You can call [DescribeRegions](~~ 25609 ~~) to view the latest region list.', position='Query'),
  vpcId?: string(name='VpcId', description='The VPC ID of the instance connection.', position='Query'),
}

model DetachClassicLinkVpcResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.'),
}

model DetachClassicLinkVpcResponse = {
  headers: map[string]string(name='headers'),
  body: DetachClassicLinkVpcResponseBody(name='body'),
}

async function detachClassicLinkVpc(request: DetachClassicLinkVpcRequest): DetachClassicLinkVpcResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DetachClassicLinkVpc', 'POST', 'undefined', 'json', false, 'none', request);
}

model ModifyRouterInterfaceSpecRequest {
  regionId?: string(name='RegionId', position='Query'),
  routerInterfaceId?: string(name='RouterInterfaceId', position='Query'),
  spec?: string(name='Spec', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  clientToken?: string(name='ClientToken', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  userCidr?: string(name='UserCidr', position='Query'),
}

model ModifyRouterInterfaceSpecResponseBody = {
  spec?: string(name='Spec'),
  requestId?: string(name='RequestId'),
}

model ModifyRouterInterfaceSpecResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyRouterInterfaceSpecResponseBody(name='body'),
}

async function modifyRouterInterfaceSpec(request: ModifyRouterInterfaceSpecRequest): ModifyRouterInterfaceSpecResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyRouterInterfaceSpec', 'POST', 'undefined', 'json', false, 'none', request);
}

model DescribeDiskMonitorDataRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  diskId?: string(name='DiskId', description='The ID of the disk.', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='The account name of the resource master account.', position='Query'),
  startTime?: string(name='StartTime', description='The start time of the data. The time follows the [ISO8601](~~ 25696 ~~) standard and uses UTC +0. The format is yyyy-MM-ddTHH:mm:ssZ. If the seconds (ss) is not 00, it is automatically set to the start of the next minute.', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', description='The ID of the resource master account, that is, the UID.', position='Query'),
  ownerId?: long(name='OwnerId', description='The ID of the RAM user.', position='Query'),
  period?: int32(name='Period', description='The precision of the data. Unit: seconds. Valid values:

-60
-600
-3600

Default value: 60', position='Query'),
  endTime?: string(name='EndTime', description='The end time of the data. The time follows the [ISO8601](~~ 25696 ~~) standard and uses UTC +0. The format is yyyy-MM-ddTHH:mm:ssZ. If the seconds (ss) is not 00, it is automatically set to the start of the next minute.', position='Query'),
}

model DescribeDiskMonitorDataResponseBody = {
  totalCount?: int32(name='TotalCount', description='The number of entries returned for the disk usage information.'),
  requestId?: string(name='RequestId', description='The ID of the request.'),
  monitorData?: {
    diskMonitorData?: [ 
    {
      BPSRead?: int32(name='BPSRead', description='The read bandwidth of the system disk. Unit: Byte/s.'),
      IOPSRead?: int32(name='IOPSRead', description='System disk I/O read operations. Unit: Times/s.'),
      latencyRead?: int32(name='LatencyRead', description='Disk read latency. Unit: μs (microseconds).'),
      BPSTotal?: int32(name='BPSTotal', description='The total read/write bandwidth of the system disk. Unit: Byte/s.'),
      IOPSTotal?: int32(name='IOPSTotal', description='The total number of I/O read/write operations on the system disk. Unit: Times/s.'),
      timeStamp?: string(name='TimeStamp', description='The timestamp used to query monitoring information. The time follows the [ISO8601](~~ 25696 ~~) standard and uses UTC +0. The format is yyyy-MM-ddTHH:mm:ssZ.'),
      latencyWrite?: int32(name='LatencyWrite', description='Disk write latency. Unit: μs (microseconds).'),
      IOPSWrite?: int32(name='IOPSWrite', description='System disk I/O write operations. Unit: Times/s.'),
      diskId?: string(name='DiskId', description='The ID of the disk.'),
      BPSWrite?: int32(name='BPSWrite', description='The write bandwidth of the system disk. Unit: Byte/s.'),
    }
  ](name='DiskMonitorData')
  }(name='MonitorData', description='The collection of monitoring data of the cloud disk.'),
}

model DescribeDiskMonitorDataResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeDiskMonitorDataResponseBody(name='body'),
}

/**
 * ## API description

You can query the read IOPS, write IOPS, read bandwidth (B/s), write bandwidth (B/s), and read latency (μs) of a cloud disk. And write latency (μs).

When you call this operation, note that:

-You can only query the disk usage information in the "in_use" status. For more information, see [basic disk Status Table](~~ 25689 ~~).

> If the content in the queried information is missing, the usage information for this period of time cannot be obtained, that is, the disk status is not in use ("in_use").

-A maximum of 400 data entries can be returned at a time, that is, the specified "( EndTime-StartTime)/""" cannot exceed 400.

-You can query the monitoring information in the last 30 days at a time. That is, the specified "StartTime" parameter cannot exceed 30 days.
 */
async function describeDiskMonitorData(request: DescribeDiskMonitorDataRequest): DescribeDiskMonitorDataResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeDiskMonitorData', 'POST', 'undefined', 'json', false, 'none', request);
}

model ModifyElasticityAssuranceRequest {
  privatePoolOptions?: {
    id?: string(name='Id', description='The ID of the elastic protection service.', position=''),
    name?: string(name='Name', description='The name of the elastic protection service. The description must be 2 to 128 characters in length. It must start with a letter and cannot start with http:// or https. It can contain numbers, colons (:), underscores (_), and hyphens (-).', position=''),
  }(name='PrivatePoolOptions'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  packageType?: string(name='PackageType', position='Query'),
  description?: string(name='Description', description='The description of the elastic protection service. The description must be 2 to 256 characters in length and cannot start with "http:// "or "https.', position='Query'),
  regionId?: string(name='RegionId', description='The ID of the region to which the elastic Protection Service belongs. You can call [DescribeRegions](~~ 25609 ~~) to view the latest region list.', position='Query'),
}

model ModifyElasticityAssuranceResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.'),
}

model ModifyElasticityAssuranceResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyElasticityAssuranceResponseBody(name='body'),
}

async function modifyElasticityAssurance(request: ModifyElasticityAssuranceRequest): ModifyElasticityAssuranceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyElasticityAssurance', 'POST', 'undefined', 'json', false, 'none', request);
}

model ModifyDeploymentSetAttributeRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  regionId?: string(name='RegionId', description='The ID of the region to which the deployment set belongs. You can call [DescribeRegions](~~ 25609 ~~) to view the latest region list.', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', description='The ID of the resource master account, that is, the UID.', position='Query'),
  description?: string(name='Description', description='The description of the new deployment set. The description must be 2 to 256 characters in length and cannot start with http:// or https.', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='The account name of the resource master account.', position='Query'),
  ownerId?: long(name='OwnerId', description='The ID of the RAM user.', position='Query'),
  deploymentSetId?: string(name='DeploymentSetId', description='The ID of the deployment set.', position='Query'),
  deploymentSetName?: string(name='DeploymentSetName', description='The name of the new deployment set. The description must be 2 to 128 characters in length. It must start with a letter and cannot start with http:// or https. It can contain numbers, colons (:), underscores (_), and hyphens (-).', position='Query'),
}

model ModifyDeploymentSetAttributeResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.'),
}

model ModifyDeploymentSetAttributeResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyDeploymentSetAttributeResponseBody(name='body'),
}

async function modifyDeploymentSetAttribute(request: ModifyDeploymentSetAttributeRequest): ModifyDeploymentSetAttributeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyDeploymentSetAttribute', 'POST', 'undefined', 'json', false, 'none', request);
}

model StartInstanceRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', description='The ID of the resource master account, that is, the UID.', position='Query'),
  initLocalDisk?: boolean(name='InitLocalDisk', description='This parameter is applicable to instances that contain local disks, such as d1, i1, or i2. When the local disk of d1, i1, or i2 fails, you can use this parameter to specify whether to restore the instance to its original health status when the instance is started. Valid values:

-true: restore the instance to its original health status, and the data in the original local disk of the instance will be lost.
-false (default): no processing is performed to maintain the status quo.', position='Query'),
  ownerId?: long(name='OwnerId', description='The ID of the RAM user.', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='The account name of the resource master account.', position='Query'),
  instanceId?: string(name='InstanceId', description='The ID of the instance to be started.', position='Query'),
  dryRun?: boolean(name='DryRun', description='Indicates whether to PreCheck only this request. Valid values:

-true: only this request is checked and the instance is not started. Check whether the AccessKey is valid, whether the RAM user is authorized, and whether required parameters are specified. If the check fails, the corresponding error is returned. If the check succeeds, an error code DryRunOperation is returned.
-false: a normal request is sent. After the request passes the check, the status code 2XX is returned and the instance is started.', position='Query'),
}

model StartInstanceResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.'),
}

model StartInstanceResponse = {
  headers: map[string]string(name='headers'),
  body: StartInstanceResponseBody(name='body'),
}

/**
 * ## API description

When you call this operation, note that:

-The status of the ECS instance must be **stopped**("Stopped").

-When the instance "OperationLocks" of the [security control](~~ 25695 ~~) is marked as "LockReason ": "Security", the instance cannot be started.
 */
async function startInstance(request: StartInstanceRequest): StartInstanceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'StartInstance', 'POST', 'undefined', 'json', false, 'none', request);
}

model DescribeAutoProvisioningGroupInstancesRequest {
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  autoProvisioningGroupId?: string(name='AutoProvisioningGroupId', description='The ID of the auto provisioning group.', position='Query'),
  pageSize?: int32(name='PageSize', description='The number of entries to return on each page.

Maximum Value: 100

Default value: 10', position='Query'),
  regionId?: string(name='RegionId', description='The ID of the region where the auto provisioning Group is located. You can call [DescribeRegions](~~ 25609 ~~) to view the latest region list.', position='Query'),
  pageNumber?: int32(name='PageNumber', description='The number of the page to return.

Start value: 1

Default value: 1.', position='Query'),
}

model DescribeAutoProvisioningGroupInstancesResponseBody = {
  pageSize?: int32(name='PageSize', description='The number of rows per page.'),
  requestId?: string(name='RequestId', description='The ID of the request.'),
  pageNumber?: int32(name='PageNumber', description='The page number.'),
  totalCount?: int32(name='TotalCount', description='The number of instances in the auto provisioning group.'),
  instances?: {
    instance?: [ 
    {
      status?: string(name='Status', description='The status of the instance.'),
      creationTime?: string(name='CreationTime', description='The time when the instance was created.'),
      isSpot?: boolean(name='IsSpot', description='Indicates whether the instance is a preemptible instance.'),
      CPU?: int32(name='CPU', description='The number of vCPU cores of the instance.'),
      instanceId?: string(name='InstanceId', description='The ID of the instance.
'),
      networkType?: string(name='NetworkType', description='The network type of the instance. Valid values:

-vpc: vpc
-classic: classic Network'),
      instanceType?: string(name='InstanceType', description='The instance type.'),
      regionId?: string(name='RegionId', description='The ID of the region to which the instance belongs.'),
      ioOptimized?: boolean(name='IoOptimized', description='Indicates whether the instance is I/O optimized.'),
      osType?: string(name='OsType', description='The operating system type of the instance. Valid values:

-windows: The operating system type is Windows.
-linux: the operating system is Linux.'),
      zoneId?: string(name='ZoneId', description='The zone to which the instance belongs.'),
      memory?: int32(name='Memory', description='The memory size. Unit: MiB.'),
    }
  ](name='Instance')
  }(name='Instances', description='The information of all instances in the auto provisioning group.'),
}

model DescribeAutoProvisioningGroupInstancesResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeAutoProvisioningGroupInstancesResponseBody(name='body'),
}

async function describeAutoProvisioningGroupInstances(request: DescribeAutoProvisioningGroupInstancesRequest): DescribeAutoProvisioningGroupInstancesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeAutoProvisioningGroupInstances', 'POST', 'undefined', 'json', false, 'none', request);
}

model ModifyCapacityReservationRequest {
  privatePoolOptions?: {
    name?: string(name='Name', description='The name of the capacity reservation service. The description must be 2 to 128 characters in length. It must start with a letter and cannot start with http:// or https. It can contain numbers, colons (:), underscores (_), and hyphens (-).', position=''),
    id?: string(name='Id', description='The ID of the subscription service.', position=''),
  }(name='PrivatePoolOptions'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  packageType?: string(name='PackageType', position='Query'),
  platform?: string(name='Platform', description='The operating system type of the image used by the instance. Valid values:

-Windows:Windows Server-type operating system.
-Linux:Linux and Unix-like operating systems.

> This parameter is not available.', position='Query'),
  regionId?: string(name='RegionId', description='The ID of the region to which the capacity reservation service belongs. You can call [DescribeRegions](~~ 25609 ~~) to view the latest region list.', position='Query'),
  description?: string(name='Description', description='The description of the capacity reservation service. The description must be 2 to 256 characters in length and cannot start with "http:// "or "https.', position='Query'),
  startTime?: string(name='StartTime', description='The effective method of the capacity reservation service. You can only set this parameter to take effect immediately.

> If this parameter is not set, it takes effect immediately.', position='Query'),
  endTime?: string(name='EndTime', description='The expiration time of the subscription service. This parameter takes effect only when "EndTimeType = Limited. The time format is ISO 8601 and UTC +0 is required. The format is yyyy-MM-ddTHH:mm:ssZ ". For more information, see [ISO8601](~~ 25696 ~~).', position='Query'),
  endTimeType?: string(name='EndTimeType', description='The expiration method of the capacity reservation service. Valid values:

-Limited: release at the specified time. You must specify the "EndTime" parameter at the same time.
-Unlimited: manually released. No time limit.', position='Query'),
  instanceAmount?: int32(name='InstanceAmount', description='The total number of instances to be reserved for the capacity reservation service. Valid values: number of used instances to 1000

> When the total number of instances is expanded, the expansion may fail due to insufficient inventory.', position='Query'),
}

model ModifyCapacityReservationResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.'),
}

model ModifyCapacityReservationResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyCapacityReservationResponseBody(name='body'),
}

async function modifyCapacityReservation(request: ModifyCapacityReservationRequest): ModifyCapacityReservationResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyCapacityReservation', 'POST', 'undefined', 'json', false, 'none', request);
}

model DescribeSnapshotPackageRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  pageSize?: int32(name='PageSize', description='The number of entries to return on each page. Maximum Value: 100

Default value: 10', position='Query'),
  ownerId?: long(name='OwnerId', description='The ID of the RAM user.', position='Query'),
  regionId?: string(name='RegionId', description='The ID of the region to which the snapshot belongs. You can call [DescribeRegions](~~ 25609 ~~) to view the latest region list.', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', description='The ID of the resource master account, that is, the UID.', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='The account name of the resource master account.', position='Query'),
  pageNumber?: int32(name='PageNumber', description='The page number of the OSS package list. Start value: 1

Default value: 1.', position='Query'),
}

model DescribeSnapshotPackageResponseBody = {
  pageSize?: int32(name='PageSize', description='The number of entries to return on each page.'),
  requestId?: string(name='RequestId', description='The ID of the request.'),
  pageNumber?: int32(name='PageNumber', description='The page number of the OSS package list.'),
  totalCount?: int32(name='TotalCount', description='The total number of returned OSS storage packages.'),
  snapshotPackages?: {
    snapshotPackage?: [ 
    {
      displayName?: string(name='DisplayName', description='The name of the storage package.'),
      endTime?: string(name='EndTime', description='The expiration time of the storage package. The time follows the [ISO8601](~~ 25696 ~~) standard and uses UTC +0. The format is yyyy-MM-ddTHH:mm:ssZ.'),
      startTime?: string(name='StartTime', description='The time when the storage package was purchased. The time follows the [ISO8601](~~ 25696 ~~) standard and uses UTC +0. The format is yyyy-MM-ddTHH:mm:ssZ.'),
      initCapacity?: long(name='InitCapacity', description='The maximum capacity of the storage package.'),
    }
  ](name='SnapshotPackage')
  }(name='SnapshotPackages', description='A collection of storage package information.'),
}

model DescribeSnapshotPackageResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeSnapshotPackageResponseBody(name='body'),
}

async function describeSnapshotPackage(request: DescribeSnapshotPackageRequest): DescribeSnapshotPackageResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeSnapshotPackage', 'POST', 'undefined', 'json', false, 'none', request);
}

model ReInitVolumeRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  volumeId?: string(name='VolumeId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  password?: string(name='Password', position='Query'),
}

model ReInitVolumeResponseBody = {
  requestId?: string(name='RequestId'),
}

model ReInitVolumeResponse = {
  headers: map[string]string(name='headers'),
  body: ReInitVolumeResponseBody(name='body'),
}

async function reInitVolume(request: ReInitVolumeRequest): ReInitVolumeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ReInitVolume', 'POST', 'undefined', 'json', false, 'none', request);
}

model DeleteImagePipelineRequest {
  templateTag?: [ 
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='TemplateTag', position='Query'),
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  regionId?: string(name='RegionId', description='Belongs geo ID. You can call [DescribeRegions](~~ 25609 ~~) to view the latest region list.', position='Query'),
  imagePipelineId?: string(name='ImagePipelineId', description='The ID of the image template.', position='Query'),
}

model DeleteImagePipelineResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.'),
}

model DeleteImagePipelineResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteImagePipelineResponseBody(name='body'),
}

/**
 * ## API description

If a build task is being built (BUILDING), DISTRIBUTING (DISTRIBUTING), recycling (RELEASING), or canceling (CANCELLING), you cannot delete the template directly, wait until the build task is successful (SUCCESS), FAILED (FAILED), or canceled (CANCELLED). For more information about a build task, see DescribeImagePipelineExecutions.
 */
async function deleteImagePipeline(request: DeleteImagePipelineRequest): DeleteImagePipelineResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteImagePipeline', 'POST', 'undefined', 'json', false, 'none', request);
}

model BindIpRangeRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  instanceId?: string(name='InstanceId', position='Query'),
  ipAddress?: string(name='IpAddress', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
}

model BindIpRangeResponseBody = {
  requestId?: string(name='RequestId'),
}

model BindIpRangeResponse = {
  headers: map[string]string(name='headers'),
  body: BindIpRangeResponseBody(name='body'),
}

async function bindIpRange(request: BindIpRangeRequest): BindIpRangeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'BindIpRange', 'POST', 'undefined', 'json', false, 'none', request);
}

model ModifyUserBusinessBehaviorRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  statusKey?: string(name='statusKey', position='Query'),
  statusValue?: string(name='statusValue', position='Query'),
}

model ModifyUserBusinessBehaviorResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyUserBusinessBehaviorResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyUserBusinessBehaviorResponseBody(name='body'),
}

async function modifyUserBusinessBehavior(request: ModifyUserBusinessBehaviorRequest): ModifyUserBusinessBehaviorResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyUserBusinessBehavior', 'POST', 'undefined', 'json', false, 'none', request);
}

model CreateElasticityAssuranceRequest {
  privatePoolOptions?: {
    name?: string(name='Name', description='The name of the elastic protection service. The description must be 2 to 128 characters in length. It must start with a letter and cannot start with "http:// "or "https. It can contain numbers, colons (:), underscores (_), and hyphens (-).', position=''),
    matchCriteria?: string(name='MatchCriteria', description='The matching mode of the elastic protection service. Valid values:

-Open: the elastic guarantee service in the Open mode.
-Target: the elastic Protection Service of the specified mode.

Default value: Open', position=''),
  }(name='PrivatePoolOptions'),
  tag?: [ 
    {
      key?: string(name='Key', description='弹性保障服务的标签键。N的取值范围：1~20。一旦传入该值，则不允许为空字符串。最多支持128个字符，不能以`aliyun`和`acs:`开头，不能包含`http://`或者`https://`。'),
      value?: string(name='Value', description='弹性保障服务的标签值。N的取值范围：1~20。一旦传入该值，允许为空字符串。最多支持128个字符，不能以`acs:`开头，不能包含`http://`或者`https://`。'),
    }
  ](name='Tag', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  chargeType?: string(name='ChargeType', position='Query'),
  instanceCpuCoreCount?: int32(name='InstanceCpuCoreCount', position='Query'),
  instanceChargeType?: string(name='InstanceChargeType', position='Query'),
  platform?: string(name='Platform', position='Query'),
  packageType?: string(name='PackageType', position='Query'),
  resourceType?: string(name='ResourceType', position='Query'),
  instanceAmount?: int32(name='InstanceAmount', description='The total number of instances to be reserved within an instance type.', position='Query'),
  instanceType?: [ string ](name='InstanceType', description='The instance type. Currently, you can set the auto guarantee service for only one instance type.', position='Query'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group to which the elastic security service belongs.', position='Query'),
  assuranceTimes?: string(name='AssuranceTimes', description='The total number of elastic guarantees. Set the value to Unlimited. Currently, the Unlimited mode is supported only when the service takes effect.

Default value: Unlimited', position='Query'),
  periodUnit?: string(name='PeriodUnit', description='The unit of the duration. Valid values:

-Month: Month
-Year: Year

Default value: Year', position='Query'),
  startTime?: string(name='StartTime', description='The effective time of the elastic protection service. The time when the service is created. The time format is ISO 8601 and UTC +0 is required. The format is yyyy-MM-ddTHH:mm:ssZ ". For more information, see [ISO8601](~~ 25696 ~~).', position='Query'),
  clientToken?: string(name='ClientToken', description='Ensure the idempotence of the request. Generate a parameter value from your client. Make sure that the value is unique among different requests. "ClientToken" only supports ASCII characters and cannot exceed 64 characters in length. For more information, see [how to ensure idempotence](~~ 25693 ~~).', position='Query'),
  zoneId?: [ string ](name='ZoneId', description='The ID of the zone to which the elastic Protection Service belongs. Currently, you can create elastic protection services in only one zone.', position='Query'),
  period?: int32(name='Period', description='The duration of the subscription. The duration is determined by the "$dune" parameter. Valid values:

-When the value of "Dune" is "Month", the value of this parameter is {"1", "2", "3", "4", "5", "6", "7", "8", "9"}.
-When the value of "Dune" is "Year", the value of this parameter is {"1", "2", "3", "4", "5"}.

Default value: 1.', position='Query'),
  description?: string(name='Description', description='The description of the elastic protection service. The description must be 2 to 256 characters in length and cannot start with "http:// "or "https.

Default value: Null.', position='Query'),
  regionId?: string(name='RegionId', description='The ID of the region to which the elastic Protection Service belongs. You can call [DescribeRegions](~~ 25609 ~~) to view the latest region list.', position='Query'),
}

model CreateElasticityAssuranceResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.'),
  privatePoolOptionsId?: string(name='PrivatePoolOptionsId', description='The ID of the elastic protection service.'),
  orderId?: string(name='OrderId', description='The ID of the generated order.'),
}

model CreateElasticityAssuranceResponse = {
  headers: map[string]string(name='headers'),
  body: CreateElasticityAssuranceResponseBody(name='body'),
}

/**
 * ## API description
Elastic security service provides a new way to purchase and use resources with both flexibility and certainty. It is a pay-as-you-go ECS instance that can be billed, provides guaranteed resource reservation services. For more information, see [Overview](~~ 193630 ~~).

-Refund is not supported after you purchase the elastic protection service.
-Only pay-as-you-go ECS instances can be created.
-Currently, the auto guarantee mode is only available for unlimited times, that is, the "ancesttimes" parameter can only be set to "Unlimited ". The auto guarantee service in unlimited mode starts automatically after the guarantee takes effect.
 */
async function createElasticityAssurance(request: CreateElasticityAssuranceRequest): CreateElasticityAssuranceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateElasticityAssurance', 'POST', 'undefined', 'json', false, 'none', request);
}

model DeleteForwardEntryRequest {
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  forwardTableId?: string(name='ForwardTableId', position='Query'),
  forwardEntryId?: string(name='ForwardEntryId', position='Query'),
}

model DeleteForwardEntryResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteForwardEntryResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteForwardEntryResponseBody(name='body'),
}

async function deleteForwardEntry(request: DeleteForwardEntryRequest): DeleteForwardEntryResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteForwardEntry', 'POST', 'undefined', 'json', false, 'none', request);
}

model CancelAgreementRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  agreementType?: string(name='AgreementType', position='Query'),
}

model CancelAgreementResponseBody = {
  requestId?: string(name='RequestId'),
}

model CancelAgreementResponse = {
  headers: map[string]string(name='headers'),
  body: CancelAgreementResponseBody(name='body'),
}

async function cancelAgreement(request: CancelAgreementRequest): CancelAgreementResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CancelAgreement', 'POST', 'undefined', 'json', false, 'none', request);
}

model ConvertClassicPublicIpToEipRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  instanceId?: string(name='InstanceId', position='Query'),
  dryRun?: boolean(name='DryRun', position='Query'),
}

model ConvertClassicPublicIpToEipResponseBody = {
  requestId?: string(name='RequestId'),
}

model ConvertClassicPublicIpToEipResponse = {
  headers: map[string]string(name='headers'),
  body: ConvertClassicPublicIpToEipResponseBody(name='body'),
}

async function convertClassicPublicIpToEip(request: ConvertClassicPublicIpToEipRequest): ConvertClassicPublicIpToEipResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ConvertClassicPublicIpToEip', 'POST', 'undefined', 'json', false, 'none', request);
}

model ModifyInstanceChargeTypeRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', description='The ID of the RAM user.', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', description='The ID of the resource master account, that is, the UID.', position='Query'),
  instanceIds?: string(name='InstanceIds', description='The ID of the instance. The value can be a JSON Array consisting of multiple instance IDs. A maximum of 20 IDs can be entered. Separate IDs with commas (,).', position='Query'),
  periodUnit?: string(name='PeriodUnit', description='The unit of the renewal period. Valid values:

-<props="china">Week</props>
-Month (default)', position='Query'),
  regionId?: string(name='RegionId', description='The ID of the region to which the instance belongs. You can call [DescribeRegions](~~ 25609 ~~) to view the latest region list.', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='The account name of the resource master account.', position='Query'),
  dryRun?: boolean(name='DryRun', description='Specifies whether to PreCheck only this request. Valid values:

-true: sends a check request without querying the resource status. Check whether the AccessKey is valid, whether the RAM user is authorized, and whether required parameters are specified. If the check fails, the corresponding error is returned. If the check succeeds, the error code "DryRunOperation" is returned ".

-false (default): a normal request is sent. After the request passes the check, the status code 2XX is returned and the resource status is directly queried.', position='Query'),
  includeDataDisks?: boolean(name='IncludeDataDisks', description='Specifies whether to convert all pay-as-you-go data disks attached to the instance to subscription data disks.

Default value: false', position='Query'),
  autoPay?: boolean(name='AutoPay', description='Indicates whether to pay automatically. Valid values:

-true (default): automatic payment. You must ensure that your account balance is sufficient. If your account balance is insufficient, an abnormal order will be generated and you can only cancel the order.

-false: only generated orders are billed.

> If the balance of your payment method is insufficient, you can set the AutoPay parameter to false. In this case, an unpaid order is generated. You can log on to the ECS console to pay by yourself.', position='Query'),
  period?: int32(name='Period', description='The subscription duration. If the DDH of the ECS instance is a dedicated host, the value range cannot exceed the subscription period of the dedicated host. Valid values:

-<props = "china">"periodunit = Week", the value of "1" is {"1", "2", "3", "4"}</props>

-When "PeriodUnit = Month", the value of "1" is {"1", "2", "3", "4", "5", "6", "7", "8", "9", "12", "24", "36", "48", "60"}
', position='Query'),
  clientToken?: string(name='ClientToken', description='Ensure the idempotence of the request. Generate a parameter value from your client. Make sure that the value is unique among different requests. **ClientToken** supports only ASCII characters and cannot exceed 64 characters. For more information, see [how to ensure idempotence](~~ 25693 ~~).', position='Query'),
  instanceChargeType?: string(name='InstanceChargeType', description='The target billing method of the instance. Valid values:

-PrePaid (default): converts a pay-as-you-go instance to a subscription instance.

-PostPaid: converts a subscription instance to a pay-as-you-go instance.', position='Query'),
  isDetailFee?: boolean(name='IsDetailFee', description='Specifies whether to return the order fee details when the subscription is converted to pay-as-you-go.

Default value: false', position='Query'),
}

model ModifyInstanceChargeTypeResponseBody = {
  orderId?: string(name='OrderId', description='The ID of the generated order.'),
  requestId?: string(name='RequestId', description='The ID of the request.'),
  feeOfInstances?: {
    feeOfInstance?: [ 
    {
      instanceId?: string(name='InstanceId', description='The ID of the instance.'),
      currency?: string(name='Currency', description='The unit of the bill.'),
      fee?: string(name='Fee', description='The value of the fee.'),
    }
  ](name='FeeOfInstance')
  }(name='FeeOfInstances', description='The details of the order fee.'),
}

model ModifyInstanceChargeTypeResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyInstanceChargeTypeResponseBody(name='body'),
}

/**
 * ## API description

<props = "china"> make sure that you have fully understood the billing method and product pricing of [ECS](https://www.aliyun.com/price/product#/ecs/detail) before using this interface. </props>

<props = "intl"> make sure that you have fully understood the billing method and product pricing of [ECS](https://www.alibabacloud.com/product/ecs#pricing) before using this interface. </props>

<props = "partner"> make sure that you have fully understood the billing method and product pricing of ECS before using this interface. </props>

When you call this operation, note that:

-The billing method can only be changed if the status of the target instance is **running**("Running") or **stopped**("Stopped") and there is no overdue payment.

-<props = "china"> fees are automatically deducted by default after the billing method is changed. You must ensure that your account balance is sufficient. Otherwise, an abnormal order will be generated. In this case, you can only cancel the order. If your account balance is insufficient, you can set the parameter "AutoPay" to "false" to generate a normal unpaid order. You can log on to the [ECS console](https://ecs.console.aliyun.com/) to pay. </props>

-<props = "intl"> fees are automatically deducted by default after the billing method is changed. You must ensure that your account balance is sufficient. Otherwise, an abnormal order will be generated. In this case, you can only cancel the order. If your account balance is insufficient, you can set the parameter "AutoPay" to "false" to generate a normal unpaid order. You can log on to the [ECS console](https://ecs.console.aliyun.com/) to pay. </props>

-**Switch from subscription to pay-as-you-go * *:

-Whether the subscription to pay-as-you-go feature is supported depends on your ECS usage.

-When a subscription instance is converted to a pay-as-you-go instance, the new billing method will cover the entire lifecycle of the instance. You will receive a refund for the price difference of the instance before and after the modification. The refund will be returned to your original payment channel. The used vouchers will not be returned.

-**Refund rules**: the refund amount that you can freely operate within a month is limited and does not accumulate. After the refund amount is used up, you can only wait for the next month to change the billing method. The formula for the refund amount consumed by one conversion is **Number of VCPUs * (refund days * 24 ± floating hours) * *.

-**Switch from pay-as-you-go to subscription * *:

-You can convert all pay-as-you-go data disks attached to an instance to subscription data disks at the same time.

-You cannot call this operation if you have set the release time for a pay-as-you-go instance.

 */
async function modifyInstanceChargeType(request: ModifyInstanceChargeTypeRequest): ModifyInstanceChargeTypeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyInstanceChargeType', 'POST', 'undefined', 'json', false, 'none', request);
}

model ModifyDedicatedHostAutoReleaseTimeRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  regionId?: string(name='RegionId', description='The ID of the region to which the dedicated host belongs. You can call [DescribeRegions](~~ 25609 ~~) to view the latest region list.', position='Query'),
  dedicatedHostId?: string(name='DedicatedHostId', description='The ID of the DDH to be automatically released.', position='Query'),
  autoReleaseTime?: string(name='AutoReleaseTime', description='The automatic release time of the dedicated host. The time follows the ISO 8601 standard and uses UTC +0. The format is yyyy-MM-ddTHH:mm:ssZ.

-Must be later than half an hour or later than the current time.
-Must be three years or earlier than the current time.
-If the seconds (ss) in the parameter value is not 00, it is automatically set to 00.
-If you do not enter the "AutoReleaseTime" parameter, auto release is canceled and the dedicated host is no longer automatically released at the scheduled time.', position='Query'),
}

model ModifyDedicatedHostAutoReleaseTimeResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.'),
}

model ModifyDedicatedHostAutoReleaseTimeResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyDedicatedHostAutoReleaseTimeResponseBody(name='body'),
}

/**
 * ## API description
The pay-as-you-go DDH is automatically released after the specified automatic release time is reached. Make sure that you no longer use the host and have backed up application data as needed.
 */
async function modifyDedicatedHostAutoReleaseTime(request: ModifyDedicatedHostAutoReleaseTimeRequest): ModifyDedicatedHostAutoReleaseTimeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyDedicatedHostAutoReleaseTime', 'POST', 'undefined', 'json', false, 'none', request);
}

model ReleaseDedicatedHostRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  regionId?: string(name='RegionId', description='The ID of the region to which the dedicated host belongs. You can call [DescribeRegions](~~ 25609 ~~) to view the latest region list.', position='Query'),
  dedicatedHostId?: string(name='DedicatedHostId', description='The ID of the dedicated host.', position='Query'),
}

model ReleaseDedicatedHostResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.'),
}

model ReleaseDedicatedHostResponse = {
  headers: map[string]string(name='headers'),
  body: ReleaseDedicatedHostResponseBody(name='body'),
}

/**
 * ## API description

Before releasing a pay-as-you-go dedicated host, make sure that no ECS instances exist on the host.
 */
async function releaseDedicatedHost(request: ReleaseDedicatedHostRequest): ReleaseDedicatedHostResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ReleaseDedicatedHost', 'POST', 'undefined', 'json', false, 'none', request);
}

model AddTagsRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  tag?: [ 
    {
      key?: string(name='key', description='资源的标签键。

>为提高兼容性，建议您尽量使用Tag.N.Key参数。'),
      value?: string(name='Value', description='资源的标签值。N的取值范围：1~20。一旦传入该值，可以为空字符串。最多支持128个字符，不能以aliyun和acs:开头，不能包含http://或者https:// 。'),
    }
  ](name='Tag', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='The account name of the resource master account.', position='Query'),
  ownerId?: long(name='OwnerId', description='The ID of the RAM user.', position='Query'),
  resourceId?: string(name='ResourceId', description='The ID of the resource to bind tags. For example, if the resource type (ResourceType) is an instance, the resource ID can be considered as the instance ID.', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', description='The ID of the resource master account, that is, the UID.', position='Query'),
  resourceType?: string(name='ResourceType', description='The type of the resource. Valid values:

-disk
-instance
-image
-securitygroup
-snapshot

The preceding values are all in lowercase.', position='Query'),
  regionId?: string(name='RegionId', description='The region of the resource. You can call [DescribeRegions](~~ 25609 ~~) to view the latest region list.', position='Query'),
}

model AddTagsResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.'),
}

model AddTagsResponse = {
  headers: map[string]string(name='headers'),
  body: AddTagsResponseBody(name='body'),
}

/**
 * ## API description

When you call this operation, note that:

-You can add up to 20 tags to a single ECS resource.

-The tag key ("Tag.N.Key") must match the tag value ("Tag.N.Value").

-If the tag key ("Tag.N.Key") already exists on the specified resource, the new tag value ("Tag.N.Value") is used to automatically overwrite the original tag value.
 */
async function addTags(request: AddTagsRequest): AddTagsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'AddTags', 'POST', 'undefined', 'json', false, 'none', request);
}

model CancelUserEventRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  resourceId?: string(name='ResourceId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  eventId?: string(name='EventId', position='Query'),
}

model CancelUserEventResponseBody = {
  eventId?: string(name='EventId'),
  requestId?: string(name='RequestId'),
}

model CancelUserEventResponse = {
  headers: map[string]string(name='headers'),
  body: CancelUserEventResponseBody(name='body'),
}

async function cancelUserEvent(request: CancelUserEventRequest): CancelUserEventResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CancelUserEvent', 'POST', 'undefined', 'json', false, 'none', request);
}

model CreateHpcClusterRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='The account name of the resource master account.', position='Query'),
  ownerId?: long(name='OwnerId', description='The ID of the RAM user.', position='Query'),
  description?: string(name='Description', description='The description of the HPC cluster. The description must be 2 to 256 characters in length and cannot start with "http:// "or "https.

Default value: Null.', position='Query'),
  name?: string(name='Name', description='The name of the HPC cluster. The description must be 2 to 128 characters in length. It must start with a letter and cannot start with "http:// "or "https. It can contain numbers, periods (.), underscores (_), and hyphens (-).', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', description='The ID of the resource master account, that is, the UID.', position='Query'),
  ownerAccount?: string(name='OwnerAccount', description='The logon name of the RAM user.', position='Query'),
  regionId?: string(name='RegionId', description='The region ID of the HPC cluster. You can call [DescribeRegions](~~ 25609 ~~) to view the latest region list.', position='Query'),
  clientToken?: string(name='ClientToken', description='Ensure the idempotence of the request. Generate a parameter value from your client. Make sure that the value is unique among different requests. **ClientToken** supports only ASCII characters and cannot exceed 64 characters. For more information, see [how to ensure idempotence](~~ 25693 ~~).', position='Query'),
}

model CreateHpcClusterResponseBody = {
  hpcClusterId?: string(name='HpcClusterId', description='The ID of the cluster.'),
  requestId?: string(name='RequestId', description='The ID of the request.'),
}

model CreateHpcClusterResponse = {
  headers: map[string]string(name='headers'),
  body: CreateHpcClusterResponseBody(name='body'),
}

async function createHpcCluster(request: CreateHpcClusterRequest): CreateHpcClusterResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateHpcCluster', 'POST', 'undefined', 'json', false, 'none', request);
}

model DescribeUserBusinessBehaviorRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  statusKey?: string(name='statusKey', position='Query'),
}

model DescribeUserBusinessBehaviorResponseBody = {
  statusValue?: string(name='StatusValue'),
  requestId?: string(name='RequestId'),
}

model DescribeUserBusinessBehaviorResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeUserBusinessBehaviorResponseBody(name='body'),
}

async function describeUserBusinessBehavior(request: DescribeUserBusinessBehaviorRequest): DescribeUserBusinessBehaviorResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeUserBusinessBehavior', 'POST', 'undefined', 'json', false, 'none', request);
}

model DescribeNetworkInterfaceAttributeRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  tag?: [ 
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='Tag', position='Query'),
  networkInterfaceId?: string(name='NetworkInterfaceId', position='Query'),
  attribute?: string(name='Attribute', position='Query'),
}

model DescribeNetworkInterfaceAttributeResponseBody = {
  creationTime?: string(name='CreationTime'),
  vpcId?: string(name='VpcId'),
  type?: string(name='Type'),
  status?: string(name='Status'),
  networkInterfaceTrafficMode?: string(name='NetworkInterfaceTrafficMode'),
  networkInterfaceName?: string(name='NetworkInterfaceName'),
  macAddress?: string(name='MacAddress'),
  queuePairNumber?: int32(name='QueuePairNumber'),
  networkInterfaceId?: string(name='NetworkInterfaceId'),
  serviceID?: long(name='ServiceID'),
  instanceId?: string(name='InstanceId'),
  ownerId?: string(name='OwnerId'),
  serviceManaged?: boolean(name='ServiceManaged'),
  vSwitchId?: string(name='VSwitchId'),
  requestId?: string(name='RequestId'),
  description?: string(name='Description'),
  resourceGroupId?: string(name='ResourceGroupId'),
  zoneId?: string(name='ZoneId'),
  privateIpAddress?: string(name='PrivateIpAddress'),
  queueNumber?: int32(name='QueueNumber'),
  securityGroupIds?: {
    securityGroupId?: [ string ](name='SecurityGroupId')
  }(name='SecurityGroupIds'),
  associatedPublicIp?: {
    publicIpAddress?: string(name='PublicIpAddress'),
    allocationId?: string(name='AllocationId'),
  }(name='AssociatedPublicIp'),
  attachment?: {
    deviceIndex?: int32(name='DeviceIndex'),
    instanceId?: string(name='InstanceId'),
    trunkNetworkInterfaceId?: string(name='TrunkNetworkInterfaceId'),
    memberNetworkInterfaceIds?: {
      memberNetworkInterfaceId?: [ string ](name='MemberNetworkInterfaceId')
    }(name='MemberNetworkInterfaceIds'),
  }(name='Attachment'),
  privateIpSets?: {
    privateIpSet?: [ 
    {
      privateIpAddress?: string(name='PrivateIpAddress'),
      primary?: boolean(name='Primary'),
    }
  ](name='PrivateIpSet')
  }(name='PrivateIpSets'),
  ipv6Sets?: {
    ipv6Set?: [ 
    {
      ipv6Address?: string(name='Ipv6Address'),
    }
  ](name='Ipv6Set')
  }(name='Ipv6Sets'),
  tags?: {
    tag?: [ 
    {
      tagValue?: string(name='TagValue'),
      tagKey?: string(name='TagKey'),
    }
  ](name='Tag')
  }(name='Tags'),
  bondInterfaceSpecification?: {
    bondMode?: string(name='BondMode'),
  }(name='BondInterfaceSpecification'),
  slaveInterfaceSpecification?: {
    slaveNetworkInterfaceId?: string(name='SlaveNetworkInterfaceId'),
    workState?: string(name='WorkState'),
    bondNetworkInterfaceId?: string(name='BondNetworkInterfaceId'),
  }(name='SlaveInterfaceSpecification'),
}

model DescribeNetworkInterfaceAttributeResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeNetworkInterfaceAttributeResponseBody(name='body'),
}

async function describeNetworkInterfaceAttribute(request: DescribeNetworkInterfaceAttributeRequest): DescribeNetworkInterfaceAttributeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeNetworkInterfaceAttribute', 'POST', 'undefined', 'json', false, 'none', request);
}

model DescribeNetworkInterfacePermissionsRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  regionId?: string(name='RegionId', description='The region of the Eni. You can call [DescribeRegions](~~ 25609 ~~) to view the latest region list.', position='Query'),
  networkInterfaceId?: string(name='NetworkInterfaceId', description='The ID of the Eni. You must specify "NetworkInterfaceId" or "NetworkInterfacePermissionId.... to determine the query range.', position='Query'),
  pageSize?: int32(name='PageSize', description='The number of entries to return on each page.

Maximum Value: 100

Default value: 10', position='Query'),
  pageNumber?: int32(name='PageNumber', description='The page number of the Eni permission list.

Start value: 1

Default value: 1.', position='Query'),
  networkInterfacePermissionId?: [ string ](name='NetworkInterfacePermissionId', description='The ID of the Eni permission. Valid values of N: 1 to 100.', position='Query'),
}

model DescribeNetworkInterfacePermissionsResponseBody = {
  pageSize?: int32(name='PageSize', description='The number of entries to return on each page.'),
  requestId?: string(name='RequestId', description='The ID of the request.'),
  pageNumber?: int32(name='PageNumber', description='The page number of the list.'),
  totalCount?: int32(name='TotalCount', description='The total number of entries queried.'),
  networkInterfacePermissions?: {
    networkInterfacePermission?: [ 
    {
      permission?: string(name='Permission', description='The Eni permission.'),
      networkInterfaceId?: string(name='NetworkInterfaceId', description='The ID of the Eni.'),
      accountId?: long(name='AccountId', description='The account ID or individual user ID of the Alibaba Cloud Partner (Certified ISV).'),
      networkInterfacePermissionId?: string(name='NetworkInterfacePermissionId', description='The ID of the Eni permission.'),
      serviceName?: string(name='ServiceName', description='The name of the Alibaba Cloud service.'),
      permissionState?: string(name='PermissionState', description='The status of the Eni permission. Possible values:

-Pending: authorization in progress
-Granted: Authorized
-Revoking: the authorization is being revoked.
-Revoked: the authorization has been Revoked.'),
    }
  ](name='NetworkInterfacePermission')
  }(name='NetworkInterfacePermissions', description='The list of Eni permissions.'),
}

model DescribeNetworkInterfacePermissionsResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeNetworkInterfacePermissionsResponseBody(name='body'),
}

async function describeNetworkInterfacePermissions(request: DescribeNetworkInterfacePermissionsRequest): DescribeNetworkInterfacePermissionsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeNetworkInterfacePermissions', 'POST', 'undefined', 'json', false, 'none', request);
}

model DescribeDisksRequest {
  filter?: [
    {
      value?: string(name='Value', description='The filter value when you query resources. When you specify this parameter, you must specify the "Filter.1.Key" parameter in the format of "yyyy-MM-ddTHH:mmZ", in UTC +0 time zone.', position=''),
      key?: string(name='Key', description='The filter key used to query resources. The value must be "CreationStartTime ". Set "Filter.1.Key" and "Filter.1.Value" to query resource information created after a specified time point.', position=''),
    }
  ](name='Filter'),
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  tag?: [ 
    {
      key?: string(name='key', description='云盘或本地盘的标签键。

>为提高代码兼容性，请尽量使用Tag.N.Key参数。'),
      value?: string(name='Value', description='云盘或本地盘的标签值。N的取值范围：1~20'),
    }
  ](name='Tag', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='The account name of the resource master account.', position='Query'),
  instanceId?: string(name='InstanceId', description='The ID of the instance to which the cloud disk or local disk is attached.', position='Query'),
  pageSize?: int32(name='PageSize', description='The number of entries to return on each page.

Maximum Value: 100

Default value: 10', position='Query'),
  diskIds?: string(name='DiskIds', description='The ID of the cloud disk or local disk. A JSON Array with a maximum of 100 IDs. Separate multiple IDs with commas (,).', position='Query'),
  enableAutoSnapshot?: boolean(name='EnableAutoSnapshot', description='Specifies whether to enable automatic snapshot policies for disks.

-true: enabled
-false: Disabled

> by default, the automatic snapshot policy function is enabled for the created Cloud Disk. You only need to bind an automatic snapshot policy to the cloud disk to use it.', position='Query'),
  enableAutomatedSnapshotPolicy?: boolean(name='EnableAutomatedSnapshotPolicy', description='Indicates whether the automatic snapshot policy is set for the disk.
-true: set
-false: not set

Default value: false', position='Query'),
  deleteWithInstance?: boolean(name='DeleteWithInstance', description='Indicates whether the disk is released with the instance. Valid values:

-true: the disk is released along with the instance.
-false: The disk is retained but not released. It is converted to a pay-as-you-go data disk.

Default value: false', position='Query'),
  diskChargeType?: string(name='DiskChargeType', description='The billing method of the cloud disk or local disk. Valid values:

-PrePaid: Subscription
-PostPaid: pay-as-you-go', position='Query'),
  status?: string(name='Status', description='The status of the disk. For more information, see [disk status](~~ 25689 ~~). Valid values:

-In_use
-Available
-Attaching
-Detaching
-Creating
-ReIniting
-All

Default value: All', position='Query'),
  zoneId?: string(name='ZoneId', description='The ID of the zone.', position='Query'),
  category?: string(name='Category', description='The type of the cloud disk or local disk. Valid values:

-all: all cloud disks and local disks
-cloud: basic cloud disk
-cloud_efficiency: Ultra disk
-cloud_ssd:SSD
-cloud_essd:ESSD
-local_ssd_pro:I/O-intensive local disks
-local_hdd_pro: Throughput-intensive local disks
-ephemeral:(discontinued) local disk
-ephemeral_ssd:(phased out) local SSD

Default value: all', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', description='The ID of the resource master account, that is, the UID.', position='Query'),
  encrypted?: boolean(name='Encrypted', description='Specifies whether to filter out only encrypted disks.

Default value: false', position='Query'),
  ownerId?: long(name='OwnerId', description='The ID of the RAM user.', position='Query'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the enterprise resource group to which the cloud disk or local disk belongs. When you use this parameter to filter resources, the number of resources cannot exceed 1,000.', position='Query'),
  multiAttach?: string(name='MultiAttach', description='Indicates whether the multi-Mount feature is enabled. Valid values:

-Disabled: Disabled
-Enabled: Enabled
-LegacyShared: used to query shared block storage

<props = "china"> the multi-Mount feature is being invited for testing. To use this feature, [submit a ticket](https://selfservice.console.aliyun.com/ticket/createIndex). </props>

<props = "intl"> the multi-Mount feature is being invited for testing. To use this feature, [submit a ticket](https://workorder-intl.console.aliyun.com/console.htm#/ticket/list). </props>

<props = "partner"> the multi-Mount feature is being invited for testing. If you need to use this feature, submit a ticket. </props>', position='Query'),
  dryRun?: boolean(name='DryRun', description='Specifies whether to PreCheck only this request. Valid values:

-true: sends a check request without querying the resource status. Check whether the AccessKey is valid, whether the RAM user is authorized, and whether required parameters are specified. If the check fails, the corresponding error is returned. If the check succeeds, the error code "DryRunOperation" is returned ".
-false: a normal request is sent. After the request passes the check, the 2XX HTTP status code is returned and the resource status is directly queried.

Default value: false', position='Query'),
  pageNumber?: int32(name='PageNumber', description='The page number of the status list of the cloud disk or local disk.

Start value: 1

Default value: 1.', position='Query'),
  regionId?: string(name='RegionId', description='The ID of the region to which the block storage belongs. You can call [DescribeRegions](~~ 25609 ~~) to view the latest region list.', position='Query'),
  snapshotId?: string(name='SnapshotId', description='The ID of the snapshot used to create the disk.', position='Query'),
  diskName?: string(name='DiskName', description='The name of the cloud disk or local disk.', position='Query'),
  deleteAutoSnapshot?: boolean(name='DeleteAutoSnapshot', description='Indicates whether automatic snapshots are released at the same time when the disk is released.

Default value: false', position='Query'),
  maxResults?: int32(name='MaxResults', description='The maximum number of entries returned. Valid values: 1 to 500.

Default value: 10.', position='Query'),
  autoSnapshotPolicyId?: string(name='AutoSnapshotPolicyId', description='Queries disks based on the ID of the automatic snapshot policy.', position='Query'),
  diskType?: string(name='DiskType', description='The type of the cloud disk or local disk to be queried. Valid values:

-all: query both the system disk and the data disk.
-system: only system disks are queried.
-data: only data disks are queried.

Default value: all', position='Query'),
  lockReason?: string(name='LockReason', description='The reason why the cloud disk or local disk is locked. Valid values:

-financial: locked due to overdue payments.
-security: locked for security reasons.
-recycling: the status of the preemptible instance to be released is locked.
-dedicatedhostfinancial: the ECS instance is locked because the dedicated host is overdue.', position='Query'),
  nextToken?: string(name='NextToken', description='The Token returned by the last API call.

For more information about how to view the returned data, see the preceding API description.', position='Query'),
  KMSKeyId?: string(name='KMSKeyId', description='The ID of the KMS key used by the cloud disk.', position='Query'),
  portable?: boolean(name='Portable', description='Whether the cloud disk or local disk can be detached. Valid values:

-true: supported. Can exist independently, and can be freely mounted and unmounted in the zone.

-false: not supported. It cannot exist independently and cannot be mounted or unmounted freely in the zone.

The "Portable" attribute of the following block storage types is "false", and the lifecycle is the same as that of the instance:

-Local disk
-Local SSD
-Subscription data disk', position='Query'),
  enableShared?: boolean(name='EnableShared', description='Indicates whether the storage class is shared block storage.', position='Query'),
  additionalAttributes?: [ string ](name='AdditionalAttributes', description='Other property values. Currently, you can only specify IOPS to query the maximum IOPS of the current disk.', position='Query'),
}

model DescribeDisksResponseBody = {
  nextToken?: string(name='NextToken', description='The query credential value returned by this call.'),
  requestId?: string(name='RequestId', description='The ID of the request.'),
  pageNumber?: int32(name='PageNumber', description='The page number of the cloud disk or local disk list.'),
  pageSize?: int32(name='PageSize', description='The number of entries to return on each page.'),
  totalCount?: int32(name='TotalCount', description='The total number of query results.'),
  disks?: {
    disk?: [ 
    {
      type?: string(name='Type', description='The type of the cloud disk or local disk. Possible values:

-system: system disk
-data: data disk'),
      status?: string(name='Status', description='The status of the disk. Possible values:

-In_use
-Available
-Attaching
-Detaching
-Creating
-ReIniting'),
      creationTime?: string(name='CreationTime', description='The creation time.'),
      serialNumber?: string(name='SerialNumber', description='The serial number of the cloud disk or local disk.'),
      performanceLevel?: string(name='PerformanceLevel', description='The performance level of an ESSD. Possible values:

-PL0: The maximum random read/write IOPS per disk is 10,000.
-PL1: The maximum random read/write IOPS per disk is 50,000.
-PL2: The maximum random read/write IOPS per disk is 100,000.
-PL3: The maximum random read/write IOPS per disk is 1 million.'),
      enableAutoSnapshot?: boolean(name='EnableAutoSnapshot', description='Specifies whether to enable automatic snapshot policies for disks.'),
      bdfId?: string(name='BdfId', description='This parameter is being invited for testing and is not available.'),
      storageSetId?: string(name='StorageSetId', description='The ID of the storage set.'),
      diskId?: string(name='DiskId', description='The ID of the cloud disk or local disk.'),
      storageSetPartitionNumber?: int32(name='StorageSetPartitionNumber', description='The maximum number of partitions in a bucket.'),
      multiAttach?: string(name='MultiAttach', description='Whether the multi-Mount feature is enabled for the cloud disk.'),
      deleteAutoSnapshot?: boolean(name='DeleteAutoSnapshot', description='Specifies whether to delete automatic snapshots at the same time. Possible values:

-true: deletes a snapshot from a disk.
-false: The snapshots on the disk are retained.

Snapshots created through [CreateSnapshot](~~ 25524 ~~) or in the console are retained without being affected by this parameter.'),
      encrypted?: boolean(name='Encrypted', description='Indicates whether the disk is encrypted.'),
      IOPSRead?: int32(name='IOPSRead', description='The number of read operations per second. Unit: Times/s.'),
      mountInstanceNum?: int32(name='MountInstanceNum', description='The number of instances to which shared storage is mounted.'),
      description?: string(name='Description', description='The description of the cloud disk or local disk.'),
      device?: string(name='Device', description='The device name of the instance attached to the cloud disk or local disk, for example,/dev/xvdb. Note:

-This parameter is valid only when the value of the "Status" parameter is "in_us". It is empty when it is in other states.

-For disks with multiple mount features enabled, this value is always empty. You can view all the mount information involved in a cloud disk through the list of returned "Attachment" objects.

> This parameter will be discontinued soon. We recommend that you do not use this parameter to improve code compatibility.'),
      diskName?: string(name='DiskName', description='The name of the cloud disk or local disk.'),
      portable?: boolean(name='Portable', description='Whether the cloud disk or local disk can be detached.'),
      storageClusterId?: string(name='StorageClusterId', description='The ID of the exclusive block storage cluster to which the cloud disk belongs. If your cloud disk is in a public block storage cluster, the return value is null.'),
      imageId?: string(name='ImageId', description='The ID of the image used to create the ECS instance. Only the cloud disk created from the image has a value. Otherwise, it is empty. The value remains unchanged during the lifecycle of the disk.'),
      deleteWithInstance?: boolean(name='DeleteWithInstance', description='Indicates whether the instance is released with the instance. Possible values:

-true: when the instance is released, the disk is released along with the instance.
-false: The disk is retained when the instance is released.'),
      KMSKeyId?: string(name='KMSKeyId', description='The ID of the KMS key used by the cloud disk.'),
      detachedTime?: string(name='DetachedTime', description='The last time when the disk was unmounted.'),
      sourceSnapshotId?: string(name='SourceSnapshotId', description='The ID of the snapshot used to create the cloud disk.

If no snapshot is specified when you create a cloud disk, this parameter is null. The value of this parameter remains unchanged during the lifecycle of the disk.

'),
      autoSnapshotPolicyId?: string(name='AutoSnapshotPolicyId', description='The ID of the automatic snapshot policy used by the cloud disk.'),
      enableAutomatedSnapshotPolicy?: boolean(name='EnableAutomatedSnapshotPolicy', description='Indicates whether the automatic snapshot policy is set for the disk.'),
      IOPSWrite?: int32(name='IOPSWrite', description='The number of write operations per second. Unit: Times/s.'),
      instanceId?: string(name='InstanceId', description='The ID of the instance to which the cloud disk or local disk is attached. Note:

-The value of this parameter is available only when the value of the "Status" parameter is "in_us". It is empty when it is in other states.

-For disks with multiple mount features enabled, this value is always empty. You can view all the mount information involved in a cloud disk through the list of returned "Attachment" objects.'),
      regionId?: string(name='RegionId', description='The ID of the region to which the cloud disk or local disk belongs.'),
      IOPS?: int32(name='IOPS', description='The number of read/write (I/O) operations per second. Unit: Times/s.'),
      expiredTime?: string(name='ExpiredTime', description='The expiration time of the subscription disk.'),
      size?: int32(name='Size', description='The size of the cloud disk or local disk. Unit: GiB.'),
      resourceGroupId?: string(name='ResourceGroupId', description='The ID of the enterprise resource group to which the cloud disk or local disk belongs.'),
      zoneId?: string(name='ZoneId', description='The ID of the zone to which the cloud disk or local disk belongs.'),
      diskChargeType?: string(name='DiskChargeType', description='The billing method of the cloud disk or local disk. Possible values:

-PrePaid: Subscription
-PostPaid: pay-as-you-go'),
      category?: string(name='Category', description='The type of the cloud disk or local disk. Possible values:

-cloud: basic cloud disk
-cloud_efficiency: Ultra disk
-cloud_ssd:SSD
-cloud_essd:ESSD
-local_ssd_pro:I/O-intensive local disks
-local_hdd_pro: Throughput-intensive local disks
-ephemeral:(discontinued) local disk
-ephemeral_ssd:(phased out) local SSD'),
      attachedTime?: string(name='AttachedTime', description='The last time when the disk was mounted. The time follows the ISO 8601 standard and uses UTC +0. The format is yyyy-MM-ddThh:mmZ.'),
      productCode?: string(name='ProductCode', description='The product ID of the Alibaba Cloud marketplace.'),
      operationLocks?: {
        operationLock?: [ 
        {
          lockReason?: string(name='LockReason', description='The reason why the cloud disk or local disk is locked.'),
        }
      ](name='OperationLock')
      }(name='OperationLocks', description='The type of the reason why the disk is locked.'),
      mountInstances?: {
        mountInstance?: [ 
        {
          attachedTime?: string(name='AttachedTime', description='The Mount time. The time follows the [ISO8601](~~ 25696 ~~) standard and uses UTC +0. The format is yyyy-MM-ddTHH:mm:ssZ.'),
          instanceId?: string(name='InstanceId', description='The ID of the instance to which the cloud disk or local disk is attached.'),
          device?: string(name='Device', description='The Mount point of the cloud disk or local disk.'),
        }
      ](name='MountInstance')
      }(name='MountInstances', description='A collection of information attached to an instance.'),
      tags?: {
        tag?: [ 
        {
          tagKey?: string(name='TagKey', description='The key of the tag.'),
          tagValue?: string(name='TagValue', description='The value of the tag.'),
        }
      ](name='Tag')
      }(name='Tags', description='The tag set of the cloud disk or local disk.'),
      attachments?: {
        attachment?: [ 
        {
          attachedTime?: string(name='AttachedTime', description='The time when the file is mounted. The value is in UTC +0.'),
          instanceId?: string(name='InstanceId', description='The ID of the attached instance.'),
          device?: string(name='Device', description='The name of the device.'),
        }
      ](name='Attachment')
      }(name='Attachments', description='The Mount information of the cloud disk. The list consisting of "Attachment" objects. This list is not returned when you query shared block storage.'),
    }
  ](name='Disk')
  }(name='Disks', description='A collection of cloud disks or local disks.'),
}

model DescribeDisksResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeDisksResponseBody(name='body'),
}

/**
 * ## API description

-The request parameters, such as "RegionId", "ZoneId", "DiskIds", AND "InstanceId", are Filters. Parameters are logically AND.

-The request parameter "DiskIds" is an Array in JSON format. If the parameter is empty, the filter does not work. However, if "DiskIds" is an empty Array, the filter is considered to be valid, and return null.

-You can view the returned data in either of the following ways:
-Method 1: Use "NextToken" to set the Token. The value is the value of the "NextToken" parameter returned DescribeDisks the last call. Then, use "maxresule" to set the maximum number of entries to query on a single page.
-Method 2: Set the number of entries returned on a single page by "PageSize", and then set the page number by "pagenumerber.

You can select either of the preceding methods. If a large number of entries are returned, we recommend that you use method 1. If "NextToken" is set, the request parameters "PageSize" and "pagenumerber" are invalid, and the "TotalCount" in the returned data is invalid.

-A cloud disk with multiple mount features can be attached to multiple instances. You can view all the mount information of the cloud disk based on the "Attachment" list in the returned result.

When calling an API through Alibaba Cloud CLI, the request parameter values of different data types must comply with the format requirements. For more information, see [CLI parameter format description](~~ 110340 ~~).

 */
async function describeDisks(request: DescribeDisksRequest): DescribeDisksResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeDisks', 'POST', 'undefined', 'json', false, 'none', request);
}

model RunCommandRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  description?: string(name='Description', description='The description of the command. The full character set is supported and cannot exceed 512 characters in length.', position='Query'),
  regionId?: string(name='RegionId', description='The ID of the region. You can call [DescribeRegions](~~ 25609 ~~) to view the latest region list.', position='Query'),
  enableParameter?: boolean(name='EnableParameter', description='Indicates whether the command contains custom parameters.

Default value: false', position='Query'),
  instanceId?: [ string ](name='InstanceId', description='The list of ECS instance IDs. Valid values of N: 1 to 50.

If multiple instances are specified and one of the instances does not meet the execution conditions, you must select another instance.', position='Query'),
  frequency?: string(name='Frequency', description='The execution cycle of a periodic command. This parameter is required when the value of "Timed" is "true. The interval between two periodic commands cannot be less than 10 seconds.

The value of this parameter follows the Cron expression. For more information, see [set scheduled execution commands](~~ 64769 ~~).', position='Query'),
  name?: string(name='Name', description='The name of the command. The full character set is supported and cannot exceed 128 characters in length.', position='Query'),
  timed?: boolean(name='Timed', description='Specifies whether to run the command periodically. Valid values:

-true: The execution is scheduled based on the time frequency set by the "ence" parameter. The last execution result does not affect the next execution.
-false: run only once.

Default value: false', position='Query'),
  type?: string(name='Type', description='The language of the O & M command. Valid values:

-RunBatScript: Bat commands for Windows instances.
-RunPowerShellScript: the Windows command that applies to PowerShell instances.
-RunShellScript: Applicable to Linux Shell commands.', position='Query'),
  workingDir?: string(name='WorkingDir', description='The running Directory of the command in the ECS instance.

Default value:

-Linux instances are in the home directory of the administrator (root user) by default, that is, "/root".
-By default, Windows system instance is located in the directory where the cloud assistant client process is located, for example, "C:WindowsSystem32 ".', position='Query'),
  contentEncoding?: string(name='ContentEncoding', description='The encoding method of the command content ("CommandContent"). Valid values: case insensitive:

-PlainText: no encoding, PlainText transmission.
-Base64: base64-encoded.

Default value: PlainText. If you set this parameter randomly or incorrectly, it will be treated as PlainText.', position='Query'),
  timeout?: long(name='Timeout', description='The timeout period for executing the command. Unit: seconds.

When a command cannot be run due to process reasons, missing modules, or missing cloud assistant clients, a timeout occurs. After a timeout, the command process is forcibly terminated.

Default value: 60', position='Query'),
  keepCommand?: boolean(name='KeepCommand', description='Specifies whether to retain the command after it is executed. Valid values:

-true: RETAIN. You can run the InvokeCommand again. The quota of cloud assistant commands is occupied.
-false: this parameter is not reserved. Automatically deleted after execution, does not occupy the quota of cloud assistant commands.

Default value: false', position='Query'),
  windowsPasswordName?: string(name='WindowsPasswordName', description='The password of the user who runs the command in the Windows instance.

If you want to run a command in a Windows instance as a non-default user (System), you must specify "Username" and this parameter at the same time. To reduce the risk of password leakage, you must host the password in plaintext in the parameter repository of O & M orchestration service. Only the password name is specified here. For more information, see [encryption parameters](~~ 186828 ~~) and [set common users to run cloud assistant commands](~~ 203771 ~~).

> This parameter is not required when you use the root user of a Linux instance or the System user of a Windows instance to run commands.', position='Query'),
  parameters?: map[string]any(name='Parameters', description='The key-value pair of the custom parameter passed in when the command is executed when the custom parameter is included in the command. For example, if the command content is "echo {{name}}", you can use the "Parameter" parameter to pass in the key-value pair "{ "name":"Jack"}". The custom parameter automatically replaces the variable value "name" to obtain a new command. The actual command is "echo Jack ".

The number of custom parameters ranges from 0 to 10.

The-key cannot be an empty string. It can be up to 64 characters in length.
-The value can be an empty string.
-After the custom parameters and the original command content are encoded in Base64, the total length cannot exceed 16kB.
-The set of custom parameter names must be a subset of the parameter set defined when the command is created. For parameters that are not specified, you can use an empty string instead.
Default value: NULL. This parameter is disabled.', position='Query'),
  username?: string(name='Username', description='The name of the user who runs the command on the ECS instance.

-Linux ECS instances run commands as root users by default.
-Windows the ECS instance of the System. By default, the System user runs the command.

You can also specify other users that already exist in the instance to run commands. It is more secure for ordinary users to run cloud assistant commands. For more information, see [set common users to run cloud assistant commands](~~ 203771 ~~).', position='Query'),
  commandContent?: string(name='CommandContent', description='The content of the command. The command content can be plaintext or base64-encoded content. Note:

-The size of the command content after Base64 encoding cannot exceed 16KB.
-If your command content is Base64-encoded, you must set "ContentEncoding = Base64 ".
-Specify the parameter "EnableParameter = true" to enable custom parameters in the command content:
-Define custom parameters in the format of "{}} ". Spaces and line breaks before and after the parameter names in "{}}" are ignored.
-The number of custom parameters cannot exceed 20.
-Custom parameter names can be combined a-zA-Z0-9-_. Other characters are not supported. Parameter names are case insensitive.
-A single custom parameter key cannot exceed 64 bytes.', position='Query'),
  repeatMode?: string(name='RepeatMode', description='Set the command execution method. Valid values:

-Once: run the command immediately.
-Period: run the command regularly. When this parameter is set to **, you must specify both the "** = true" parameter and the "ence" parameter.
-NextRebootOnly: When the instance starts next time, the command is automatically executed.
-EveryReboot: The command is automatically executed each time the instance is started.

Default value:
-If you do not specify the value of the "1" = true" parameter and the "ence" parameter, the default value is "Once ".
-If you specify the "1" = true" parameter value and the "ence" parameter, the parameter is processed as "1" regardless of whether the parameter value has been set.

Note:
-When this parameter is set to "1", "n"bootonly", or "EveryReboot", you can call [StopInvocation](~~ 64838 ~~) to stop the pending or periodic commands.
-If this parameter is set to "1" or "EveryReboot", you can call [DescribeInvocationResults](~~ 64845 ~~) and specify "IncludeHistory = true" to view the execution history of the command cycle.', position='Query'),
}

model RunCommandResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.'),
  commandId?: string(name='CommandId', description='The ID of the command.'),
  invokeId?: string(name='InvokeId', description='The ID of the command execution.'),
}

model RunCommandResponse = {
  headers: map[string]string(name='headers'),
  body: RunCommandResponseBody(name='body'),
}

/**
 * ## API description

Unlike executing commands through [CreateCommand](~~ 64844 ~~) and [InvokeCommand](~~ 64841 ~~), RunCommand can create and execute commands with only one call.

When you call this operation, note that:

-The network type of the target instance must be VPC.

-The status of the target instance must be running ("Running").

-The target instance must be pre-installed with the cloud assistant client ([InstallCloudAssistant](~~ 85916 ~~)).

-When you run a command of the PowerShell type, make sure that the ECS Windows module is configured for the target PowerShell instance.

-The standard time for periodic execution is UTC +0, and this time is based on the system time of the instance. The time or time zone of the ECS instance must be the same as expected. For more information about time zones, see [set the Linux instance time zone and NTP service](~~ 92803 ~~) or [set the Windows instance NTP service](~~ 51890 ~~).

-You can specify the "TimeOut" parameter to set the maximum timeout period when a command is executed on an ECS instance. After the command execution times out, the cloud assistant client forcibly terminates the process.
-After a single execution times out, the command execution status ([InvokeRecordStatus](~~ 64845 ~~)) changes to Failed.
-The timeout period of periodic execution is valid for each execution record. The last execution timeout does not affect the next execution. After an execution times out, the execution status ([InvokeRecordStatus](~~ 64845 ~~)) changes to Failed.

-The command may fail to be executed due to an abnormal status, network exception, or cloud assistant client exception of the target instance. If the command fails to be executed, no execution information is generated.

When-"EnableParameter = true", custom parameters are enabled. When "CommandContent" is set, you can use "{{parameter}}"to represent custom parameters, and pass in custom parameter key-value pairs when running commands.

<props="china">
-A maximum of 100 to 10,000 cloud assistant commands can be retained in a region based on your usage. A maximum of 2,000 to 200,000 cloud assistant commands can be executed per day. You can use [DescribeAccountAttribute](~~ 73772 ~~) to query the quota status, or [submit a ticket](https://selfservice.console.aliyun.com/ticket/createIndex.htm) to adjust the quota of the reserved amount and the number of calls.

</props>


<props="intl">
-A maximum of 100 to 10,000 cloud assistant commands can be retained in a region based on your usage. A maximum of 2,000 to 200,000 cloud assistant commands can be executed per day. You can use [DescribeAccountAttribute](~~ 73772 ~~) to query the quota status, or [submit a ticket](https://workorder-intl.console.aliyun.com/#/ticket/createIndex) to adjust the quota of the reserved amount and the number of calls.

</props>
 */
async function runCommand(request: RunCommandRequest): RunCommandResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'RunCommand', 'POST', 'undefined', 'json', false, 'none', request);
}

model DeleteCommandRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  commandId?: string(name='CommandId', description='The ID of the command. You can call the [DescribeCommands](~~ 64843 ~~) operation to query all available CommandId.', position='Query'),
  regionId?: string(name='RegionId', description='The ID of the region. You can call [DescribeRegions](~~ 25609 ~~) to view the latest region list.', position='Query'),
  ownerId?: long(name='OwnerId', description='The ID of the RAM user.', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', description='The ID of the resource master account, that is, the UID.', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='The account name of the resource master account.', position='Query'),
}

model DeleteCommandResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.'),
}

model DeleteCommandResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteCommandResponseBody(name='body'),
}

async function deleteCommand(request: DeleteCommandRequest): DeleteCommandResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteCommand', 'POST', 'undefined', 'json', false, 'none', request);
}

model DeleteVSwitchRequest {
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  vSwitchId?: string(name='VSwitchId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
}

model DeleteVSwitchResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteVSwitchResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteVSwitchResponseBody(name='body'),
}

async function deleteVSwitch(request: DeleteVSwitchRequest): DeleteVSwitchResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteVSwitch', 'POST', 'undefined', 'json', false, 'none', request);
}

model ModifyInstanceMetadataOptionsRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  httpPutResponseHopLimit?: int32(name='HttpPutResponseHopLimit', position='Query'),
  instanceId?: string(name='InstanceId', description='The ID of the instance.', position='Query'),
  httpTokens?: string(name='HttpTokens', description='Specifies whether to use the enhanced mode (IMDSv2) when accessing instance metadata. Valid values:
-optional: not mandatory.
-required: force use. If this parameter is set, the instance metadata cannot be accessed in normal mode.

Default value: optional.
> For more information about how to access instance metadata, see [instance metadata access mode](~~ 150575 ~~).', position='Query'),
  regionId?: string(name='RegionId', description='The ID of the region where the instance is located. You can call [DescribeRegions](~~ 25609 ~~) to view the latest region list.', position='Query'),
  httpEndpoint?: string(name='HttpEndpoint', description='Specifies whether to enable the access channel for instance metadata. Valid values:
-enabled: enabled
-disabled: disabled

Default value: enabled
> For more information about instance metadata, see [instance metadata Overview](~~ 49122 ~~).', position='Query'),
}

model ModifyInstanceMetadataOptionsResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.'),
}

model ModifyInstanceMetadataOptionsResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyInstanceMetadataOptionsResponseBody(name='body'),
}

async function modifyInstanceMetadataOptions(request: ModifyInstanceMetadataOptionsRequest): ModifyInstanceMetadataOptionsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyInstanceMetadataOptions', 'POST', 'undefined', 'json', false, 'none', request);
}

model DescribeClustersRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
}

model DescribeClustersResponseBody = {
  requestId?: string(name='RequestId'),
  clusters?: {
    cluster?: [ 
    {
      clusterId?: string(name='ClusterId'),
    }
  ](name='Cluster')
  }(name='Clusters'),
}

model DescribeClustersResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeClustersResponseBody(name='body'),
}

async function describeClusters(request: DescribeClustersRequest): DescribeClustersResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeClusters', 'POST', 'undefined', 'json', false, 'none', request);
}

model DeleteBandwidthPackageRequest {
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  bandwidthPackageId?: string(name='BandwidthPackageId', position='Query'),
}

model DeleteBandwidthPackageResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteBandwidthPackageResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteBandwidthPackageResponseBody(name='body'),
}

async function deleteBandwidthPackage(request: DeleteBandwidthPackageRequest): DeleteBandwidthPackageResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteBandwidthPackage', 'POST', 'undefined', 'json', false, 'none', request);
}

model DescribeTagsRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  category?: string(name='Category', position='Query'),
  tag?: [ 
    {
      key?: string(name='key', description='资源的标签键。

>为提高兼容性，建议您尽量使用Tag.N.Key参数。'),
      value?: string(name='Value', description='资源的标签值。N的取值范围：1~20。一旦传入该值，可以为空字符串。最多支持128个字符，不能以aliyun和acs:开头，不能包含 http:// 或者 https:// 。'),
    }
  ](name='Tag', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='The account name of the resource master account.', position='Query'),
  pageNumber?: int32(name='PageNumber', description='The page number of the tag list.

Start value: 1

Default value: 1.', position='Query'),
  resourceId?: string(name='ResourceId', description='The ID of the resource associated with the tag. For example, if the resource type (ResourceType) is an instance, the resource ID can be considered as the instance ID.', position='Query'),
  ownerId?: long(name='OwnerId', description='The ID of the RAM user.', position='Query'),
  resourceType?: string(name='ResourceType', description='The type of the resource. Valid values:

-disk
-instance
-image
-securitygroup
-snapshot

The preceding values are all in lowercase.', position='Query'),
  pageSize?: int32(name='PageSize', description='The number of entries to return on each page.

Maximum Value: 100

Default value: 50', position='Query'),
  regionId?: string(name='RegionId', description='The ID of the region. You can call [DescribeRegions](~~ 25609 ~~) to view the latest region list.', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', description='The ID of the resource master account, that is, the UID.', position='Query'),
}

model DescribeTagsResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.'),
  pageSize?: int32(name='PageSize', description='The number of entries to return on each page.'),
  pageNumber?: int32(name='PageNumber', description='The page number of the tag list.'),
  totalCount?: int32(name='TotalCount', description='The total number of tags.'),
  tags?: {
    tag?: [ 
    {
      tagValue?: string(name='TagValue', description='The value of the tag.'),
      tagKey?: string(name='TagKey', description='The key of the tag.'),
      resourceTypeCount?: {
        instance?: int32(name='Instance', description='The number of instances marked by the tag.'),
        image?: int32(name='Image', description='The number of images marked by the tag.'),
        eni?: int32(name='Eni', description='The number of Enis marked by the tag.'),
        launchTemplate?: int32(name='LaunchTemplate', description='The number of launch templates marked by the tag.'),
        keyPair?: int32(name='KeyPair', description='The number of key pairs marked by the tag.'),
        ddh?: int32(name='Ddh', description='The number of dedicated hosts marked by the tag.'),
        disk?: int32(name='Disk', description='The number of disks marked by the tag.'),
        volume?: int32(name='Volume', description='The number of extended volumes marked by the tag.'),
        securitygroup?: int32(name='Securitygroup', description='The number of security groups marked by the tag.'),
        snapshot?: int32(name='Snapshot', description='The number of snapshots marked by the tag.'),
      }(name='ResourceTypeCount', description='The Count of resource types.'),
    }
  ](name='Tag')
  }(name='Tags', description='The tags that meet all the filter conditions.'),
}

model DescribeTagsResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeTagsResponseBody(name='body'),
}

/**
 * ## API description

If you specify the Tag Key (Tag.N.Key) but do not specify the Tag Value (Tag.N.Value), we query all Tag Key-Value pairs corresponding to the Tag Key. If you specify a tag key-value pair, you can query the tags that exactly match the key-value pair.
 */
async function describeTags(request: DescribeTagsRequest): DescribeTagsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeTags', 'POST', 'undefined', 'json', false, 'none', request);
}

model StartDiskReplicaPairRequest {
  ownerId?: long(name='OwnerId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  replicaPairId?: string(name='ReplicaPairId', position='Query'),
}

model StartDiskReplicaPairResponseBody = {
  requestId?: string(name='RequestId'),
}

model StartDiskReplicaPairResponse = {
  headers: map[string]string(name='headers'),
  body: StartDiskReplicaPairResponseBody(name='body'),
}

async function startDiskReplicaPair(request: StartDiskReplicaPairRequest): StartDiskReplicaPairResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'StartDiskReplicaPair', 'POST', 'undefined', 'json', false, 'none', request);
}

model AuthorizeSecurityGroupEgressRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  priority?: string(name='Priority', description='The priority of the security group rule. Valid values: 1 to 100.

Default value: 1.', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', description='The ID of the resource master account, that is, the UID.', position='Query'),
  policy?: string(name='Policy', description='Set the access permission. Valid values:

-accept: accept access
-drop: Access Denied. No deny message is returned.

Default value: accept', position='Query'),
  regionId?: string(name='RegionId', description='The region ID of the source security group. You can call [DescribeRegions](~~ 25609 ~~) to view the latest region list.', position='Query'),
  securityGroupId?: string(name='SecurityGroupId', description='The ID of the source security group.', position='Query'),
  description?: string(name='Description', description='The description of the security group rule. The description must be 1 to 512 characters in length.', position='Query'),
  ipProtocol?: string(name='IpProtocol', description='The transport layer protocol. The value is case sensitive. Valid values:

-icmp
-gre
-tcp
-udp
-all: all protocols are supported.', position='Query'),
  sourcePortRange?: string(name='SourcePortRange', description='The range of ports related to the transport layer protocol opened by the source security group. Valid values:

-TCP/UDP: 1 to 65535. Use a slash (/) to separate the start port from the end port. Example: 1/200
-ICMP:-1/-1
-GRE protocol:-1/-1
-all:-1/-1', position='Query'),
  destGroupOwnerAccount?: string(name='DestGroupOwnerAccount', description='The Alibaba Cloud account to which the destination security group belongs.

-If "DestGroupOwnerAccount" and "DestGroupOwnerId" are not set, the access permissions of other security groups are set.
-If the "DestCidrIp" parameter is set, the "DestGroupOwnerAccount" parameter is invalid.', position='Query'),
  nicType?: string(name='NicType', description='The NIC type of the classic network security group rule. Valid values:

-internet: internet Nic
-intranet: intranet Nic
-You do not need to set the Nic type for VPC-type security group rules. The default value is intranet, which can only be intranet.
-When the security group is configured to access each other, that is, only the DestGroupId is specified, it can only be intranet.

Default value: internet', position='Query'),
  ownerId?: long(name='OwnerId', description='The ID of the RAM user.', position='Query'),
  clientToken?: string(name='ClientToken', description='Ensure the idempotence of the request. Generate a parameter value from your client. Make sure that the value is unique among different requests. **ClientToken** supports only ASCII characters and cannot exceed 64 characters. For more information, see [how to ensure idempotence](~~ 25693 ~~).', position='Query'),
  destCidrIp?: string(name='DestCidrIp', description='The Destination IPv4 CIDR block to which you want to set access permissions. CIDR and IPv4 IP addresses are supported.

Default value: None', position='Query'),
  ipv6DestCidrIp?: string(name='Ipv6DestCidrIp', description='The Destination IPv6 CIDR block to which you want to set access permissions. CIDR and IPv6 IP addresses are supported.

> only VPC-type IP addresses are supported.


Default value: None', position='Query'),
  destGroupOwnerId?: long(name='DestGroupOwnerId', description='The ID of the Alibaba Cloud account to which the destination security group belongs.

-If neither "DestGroupOwnerId" nor "DestGroupOwnerAccount" is set, the access permission of other security groups is set.
-If you have set the "DestCidrIp" parameter, the "DestGroupOwnerId" parameter is invalid.', position='Query'),
  sourceCidrIp?: string(name='SourceCidrIp', description='The range of source IP addresses. CIDR and IPv4 IP addresses are supported.

Default value: None', position='Query'),
  portRange?: string(name='PortRange', description='The port range related to the transport layer protocol opened by the destination security group. Valid values:

-TCP/UDP: valid values: 1 to 65535. Use a slash (/) to separate the start port from the end port. Example: 1/200
-ICMP:-1/-1
-GRE protocol:-1/-1
-all:-1/-1', position='Query'),
  destGroupId?: string(name='DestGroupId', description='The ID of the destination security group to which you want to configure access permissions. Set at least one of the "DestGroupId" or "DestCidrIp" parameters.

-If "DestGroupId" is specified but "DestCidrIp" is not specified, the value of "NicType" can only be intranet.

-If both "DestGroupId" and "DestCidrIp" are specified, the default value is "DestCidrIp.', position='Query'),
  ipv6SourceCidrIp?: string(name='Ipv6SourceCidrIp', description='The source IPv6 CIDR block. CIDR and IPv6 IP addresses are supported.


Default value: None

> only VPC-type IP addresses are supported.', position='Query'),
  destPrefixListId?: string(name='DestPrefixListId', description='The list ID of the destination prefix to which you want to set access permissions. You can call [DescribePrefixLists](~~ 205046 ~~) to query the list IDs of available prefixes.

Note:

-If the network type of a security group is classic network, the prefix list cannot be set. For more information about security groups and Prefix List restrictions, see [Security Group restrictions](~~ 25412#SecurityGroupQuota1 ~~).

-If you specify one of the "DestCidrIp", "Ipv6DestCidrIp", or "DestGroupId" parameters, this parameter is ignored.', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='The account name of the resource master account.', position='Query'),
}

model AuthorizeSecurityGroupEgressResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.'),
}

model AuthorizeSecurityGroupEgressResponse = {
  headers: map[string]string(name='headers'),
  body: AuthorizeSecurityGroupEgressResponseBody(name='body'),
}

/**
 * ## API description

In the API document of the security group, the initiator of the traffic is the Source and the receiver of the data transmission is the Dest.

When you call this operation, you need to understand the following:

-The total number of outbound and inbound security group rules cannot exceed 200.

-Security group rules divided into accept access (accept) and deny access to (drop) two-class.

-The Priority (Priority) of security group rules can be from 1 to 100. A smaller number indicates a higher priority.

-For security group rules with the same priority, the drop rule takes precedence.

-The destination device can be a specified IP address range (DestCidrIp, Ipv6DestCidrIp, DestPrefixListId), or an ECS instance in another security group (DestGroupId).

-If a matching Security Group rule already exists, the AuthorizeSecurityGroupEgress is called successfully, but the number of rules is not increased.

-A security group rule can be determined by any of the following parameters. A security group rule cannot be determined by specifying only one parameter.

-Set the ACL for the specified CIDR block. For example, IpProtocol, PortRange, (optional) SourcePortRange, NicType, Policy, and DestCidrIp.

"""
https://ecs.aliyuncs.com/? Action=AuthorizeSecurityGroupEgress
&SecurityGroupId=sg-bp67acfmxazb4ph ***
&IpProtocol=icmp
&DestCidrIp=10.0.0.0/8
&PortRange=-1/-1
&NicType=intranet
&Policy=Allow
& <common request parameters>
"""

-Set the access permissions of other security groups. For example, IpProtocol, PortRange, (optional) SourcePortRange, NicType, Policy, DestGroupOwnerAccount, and DestGroupId.

"""
https://ecs.aliyuncs.com/? Action=AuthorizeSecurityGroupEgress
&SecurityGroupId=sg-bp67acfmxazb4ph ***
&DestGroupId=sg-bp67acfmxazb4pi ***
&DestGroupOwnerAccount=Test@aliyun.com
&IpProtocol=tcp
&PortRange=22/22
&NicType=intranet
&Policy=Drop
& <common request parameters>
"""

-Associate a prefix list with a security group rule. In this case, the prefix list only supports security groups whose network type is VPC, and NicType can only be set to intranet. For example, IpProtocol, PortRange, (optional) SourcePortRange, NicType, Policy, and DestPrefixListId.

"""
https://ecs.aliyuncs.com/? Action=AuthorizeSecurityGroupEgress
&SecurityGroupId=sg-bp67acfmxazb4ph ***
&DestPrefixListId=pl-x1j1k5ykzqlixdcy ****
&DestGroupOwnerAccount=Test@aliyun.com
&IpProtocol=tcp
&PortRange=22/22
&NicType=intranet
&Policy=Drop
& <common request parameters>
"""
 */
async function authorizeSecurityGroupEgress(request: AuthorizeSecurityGroupEgressRequest): AuthorizeSecurityGroupEgressResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'AuthorizeSecurityGroupEgress', 'POST', 'undefined', 'json', false, 'none', request);
}

model StartTerminalSessionRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  instanceId?: [ string ](name='InstanceId', position='Query'),
}

model StartTerminalSessionResponseBody = {
  requestId?: string(name='RequestId'),
  sessionId?: string(name='SessionId'),
  securityToken?: string(name='SecurityToken'),
  webSocketUrl?: string(name='WebSocketUrl'),
}

model StartTerminalSessionResponse = {
  headers: map[string]string(name='headers'),
  body: StartTerminalSessionResponseBody(name='body'),
}

async function startTerminalSession(request: StartTerminalSessionRequest): StartTerminalSessionResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'StartTerminalSession', 'POST', 'undefined', 'json', false, 'none', request);
}

model DescribeManagedInstancesRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  instanceId?: [ string ](name='InstanceId', description='The ID of the managed instance. Valid values of N: 1 to 50.', position='Query'),
  activationId?: string(name='ActivationId', description='Activation Code ID.', position='Query'),
  regionId?: string(name='RegionId', description='The ID of the region. Only China (Hangzhou), China (Beijing), and China (Shanghai) are supported.', position='Query'),
  pageSize?: long(name='PageSize', description='The number of entries to return on each page.

Maximum Value: 50

Default value: 10', position='Query'),
  pageNumber?: long(name='PageNumber', description='The page number of the managed instance list.

Start value: 1

Default value: 1.', position='Query'),
  instanceIp?: string(name='InstanceIp', description='The internal or public IP address of the managed instance.', position='Query'),
  osType?: string(name='OsType', description='The operating system type of the managed instance. Valid values:

-Windows
-linux

', position='Query'),
  instanceName?: string(name='InstanceName', description='The name of the managed instance.', position='Query'),
}

model DescribeManagedInstancesResponseBody = {
  pageSize?: long(name='PageSize', description='The number of entries to return on each page.'),
  requestId?: string(name='RequestId', description='The ID of the request.'),
  pageNumber?: long(name='PageNumber', description='The page number of the managed instance list.'),
  totalCount?: long(name='TotalCount', description='The total number of managed instances queried.'),
  instances?: [ 
    {
      lastInvokedTime?: string(name='LastInvokedTime', description='The time when the cloud assistant task was last executed.'),
      connected?: boolean(name='Connected', description='Indicates whether the managed instance is connected.

-true: the managed instance is connected. You can use cloud assistant to manage the managed instance.

-false: The managed instance is not connected, the server may be stopped, or the cloud assistant client is not installed correctly.'),
      internetIp?: string(name='InternetIp', description='The public IP address of the managed instance.'),
      hostname?: string(name='Hostname', description='The hostname of the managed instance.'),
      instanceId?: string(name='InstanceId', description='The ID of the managed instance.'),
      activationId?: string(name='ActivationId', description='Activation Code ID.'),
      intranetIp?: string(name='IntranetIp', description='The internal IP address of the managed instance.'),
      agentVersion?: string(name='AgentVersion', description='The version number of the cloud assistant client.'),
      registrationTime?: string(name='RegistrationTime', description='The registration time of the managed instance.'),
      instanceName?: string(name='InstanceName', description='The name of the managed instance.'),
      osType?: string(name='OsType', description='The operating system of the managed instance.'),
      osVersion?: string(name='OsVersion', description='The version of the operating system.'),
      invocationCount?: long(name='InvocationCount', description='The number of times that the managed instance performs cloud assistant tasks.'),
      machineId?: string(name='MachineId', description='The machine code of the managed instance.'),
    }
  ](name='Instances', description='Returns the information of a managed instance in an array of Instances.
































































































'),
}

model DescribeManagedInstancesResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeManagedInstancesResponseBody(name='body'),
}

async function describeManagedInstances(request: DescribeManagedInstancesRequest): DescribeManagedInstancesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeManagedInstances', 'POST', 'undefined', 'json', false, 'none', request);
}

model UnassociateEipAddressRequest {
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  allocationId?: string(name='AllocationId', position='Query'),
  instanceId?: string(name='InstanceId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  instanceType?: string(name='InstanceType', position='Query'),
}

model UnassociateEipAddressResponseBody = {
  requestId?: string(name='RequestId'),
}

model UnassociateEipAddressResponse = {
  headers: map[string]string(name='headers'),
  body: UnassociateEipAddressResponseBody(name='body'),
}

async function unassociateEipAddress(request: UnassociateEipAddressRequest): UnassociateEipAddressResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UnassociateEipAddress', 'POST', 'undefined', 'json', false, 'none', request);
}

model CreateSnapshotRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  tag?: [ 
    {
      key?: string(name='key', description='快照的标签键。

>  为提高兼容性，建议您尽量使用Tag.N.Key参数。'),
      value?: string(name='Value', description='快照的标签值。N的取值范围：1~20。一旦传入该值，可以为空字符串。最多支持128个字符，不能以acs:开头，不能包含http://或者https://。'),
    }
  ](name='Tag', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', description='The ID of the resource master account, that is, the UID.', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='The account name of the resource master account.', position='Query'),
  snapshotName?: string(name='SnapshotName', description='The name of the snapshot. The description must be 2 to 128 characters in length. It must start with a letter and cannot start with http:// or https. It can contain numbers, colons (:), underscores (_), and hyphens (-).

To prevent conflicts with the name of an automatic snapshot, it cannot start with auto.', position='Query'),
  ownerId?: long(name='OwnerId', description='The ID of the RAM user.', position='Query'),
  category?: string(name='Category', description='The type of the snapshot. Valid values:
-Standard: normal snapshot
-Flash: local snapshot

> This parameter will be deprecated soon. We recommend that you use the "InstantAccess" parameter to improve compatibility ". This parameter and the "InstantAccess" parameter cannot be passed at the same time. For more information, see API description.', position='Query'),
  clientToken?: string(name='ClientToken', description='Ensure the idempotence of the request. Generate a parameter value from your client. Make sure that the value is unique among different requests. **ClientToken** supports only ASCII characters and cannot exceed 64 characters. For more information, see [how to ensure idempotence](~~ 25693 ~~).', position='Query'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group to which the snapshot belongs.', position='Query'),
  description?: string(name='Description', description='The description of the snapshot. The description must be 2 to 256 characters in length and cannot start with http:// or https.

Default value: Null.', position='Query'),
  retentionDays?: int32(name='RetentionDays', description='The retention period of the snapshot. Unit: days. Snapshots are automatically released after the retention period expires. Valid values: 1 to 65536.

Default value: null, indicating that snapshots are not automatically released.', position='Query'),
  instantAccessRetentionDays?: int32(name='InstantAccessRetentionDays', description='Set the retention period of the snapshot extreme availability feature. After the retention period expires, the snapshot is automatically released. This parameter takes effect when "InstantAccess = true. Unit: days. Valid values: 1 to 65535. The default value is the same as the value of the "RetentionDays" parameter.', position='Query'),
  instantAccess?: boolean(name='InstantAccess', description='Specifies whether to enable quick snapshot availability. Valid values:
-true: enabled. Only ESSDS support this feature.
-false: disabled. Create a normal snapshot.

Default value: false

> This parameter and the "categore" parameter cannot be passed at the same time. For more information, see API description.', position='Query'),
  diskId?: string(name='DiskId', description='The ID of the disk.', position='Query'),
}

model CreateSnapshotResponseBody = {
  snapshotId?: string(name='SnapshotId', description='The ID of the snapshot.'),
  requestId?: string(name='RequestId', description='The ID of the request.'),
}

model CreateSnapshotResponse = {
  headers: map[string]string(name='headers'),
  body: CreateSnapshotResponseBody(name='body'),
}

/**
 * ## API description

The original snapshot is replaced with the snapshot extreme available feature. The parameters are described as follows:
-If you have used a local snapshot before December 14, 2020. You can use the "categore" and "InstantAccess" parameters. Note that:
-The "categore" and "InstantAccess" parameters cannot be passed at the same time.
-If the values of the "categore" and "InstantAccess" parameters are not specified, a normal snapshot is created by default.
-If you have not used a local snapshot before December 14, 2020. You can only use the "InstantAccess" parameter, but not the "categore" parameter ".
<props = "china"> for more information, see [Alibaba Cloud Snapshot service upgrade and new billing items notice on December 14](https://help.aliyun.com/noticelist/articleid/1060755542.html). </props>


You cannot create snapshots for a specified disk in the following scenarios:

-The number of manual snapshots of the disk is 256.

-The previous snapshot has not been created.

-The instance mounted to the cloud disk has never been started.

-The instance attached to the disk is not in the **stopped**("Stopped") or **running**("Running") status.

-When querying ECS instance information, if the returned data contains "{"OperationLocks": {"LockReason" : "security"}}", all operations are prohibited.

When creating a snapshot, note the following:

-You can create a snapshot after creating an ECS instance or replacing the system disk for about one hour. The time to create a new data disk depends on the size of the disk data.

-If you have not created a snapshot, this snapshot cannot be used to create a custom image ([CreateImage](~~ 25535 ~~)).

-If the disk is attached to an ECS instance, do not change the instance status during snapshot creation.

-You can create snapshots for disks in the **expired**("Expired") state. If the disk expires and is released when the snapshot is created, the snapshot that is being created ("Creating") is also deleted when the disk is released.

 */
async function createSnapshot(request: CreateSnapshotRequest): CreateSnapshotResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateSnapshot', 'POST', 'undefined', 'json', false, 'none', request);
}

model CreateDiagnosticReportRequest {
  regionId?: string(name='RegionId', position='Query'),
  resourceType?: string(name='ResourceType', position='Query'),
  diagnosticCategory?: string(name='DiagnosticCategory', position='Query'),
  startTime?: string(name='StartTime', position='Query'),
  endTime?: string(name='EndTime', position='Query'),
  pluginVersion?: string(name='PluginVersion', position='Query'),
  commandType?: string(name='CommandType', position='Query'),
  resourceId?: [ string ](name='ResourceId', position='Query'),
  commandName?: [ string ](name='CommandName', position='Query'),
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  clientToken?: string(name='ClientToken', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  sourceSystem?: string(name='SourceSystem', position='Query'),
}

model CreateDiagnosticReportResponseBody = {
  status?: string(name='Status'),
  reportId?: string(name='ReportId'),
  requestId?: string(name='RequestId'),
  createTime?: string(name='CreateTime'),
  commandInvokeResults?: {
    invokeResult?: [ 
    {
      dataFileDir?: string(name='DataFileDir'),
      invokeResult?: string(name='InvokeResult'),
      commandName?: string(name='CommandName'),
    }
  ](name='InvokeResult')
  }(name='CommandInvokeResults'),
}

model CreateDiagnosticReportResponse = {
  headers: map[string]string(name='headers'),
  body: CreateDiagnosticReportResponseBody(name='body'),
}

async function createDiagnosticReport(request: CreateDiagnosticReportRequest): CreateDiagnosticReportResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateDiagnosticReport', 'POST', 'undefined', 'json', false, 'none', request);
}

model ModifyInstanceAttachmentAttributesRequest {
  privatePoolOptions?: {
    matchCriteria?: string(name='MatchCriteria', description='Modifies the private pool matching mode of an instance. Valid values:

-Open: Open mode. In this mode, the system automatically matches the open private pool for the instance.
-Target: specifies the mode. In this mode, you must also specify the "PrivatePoolOptions.Id" parameter to set the ID of the specified private pool.
-None: not used. In this mode, the instance starts normally without using a private pool.', position=''),
    id?: string(name='Id', description='Private pool ID, the elastic security services ID or capacity reservation service ID.

-This parameter is required when "PrivatePoolOptions. Matchbeautia" is set to "Target.
-If "PrivatePoolOptions. Matchefulia" is set to "Open" or "None", this parameter is not set.', position=''),
  }(name='PrivatePoolOptions'),
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  regionId?: string(name='RegionId', description='The ID of the region to which the private pool belongs. You can call [DescribeRegions](~~ 25609 ~~) to view the latest region list.', position='Query'),
  instanceId?: string(name='InstanceId', description='The ID of the instance that you want to modify the matching properties of the private pool.', position='Query'),
}

model ModifyInstanceAttachmentAttributesResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.'),
}

model ModifyInstanceAttachmentAttributesResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyInstanceAttachmentAttributesResponseBody(name='body'),
}

/**
 * ## API description

A private pool is generated after an elastic protection service or a capacity reservation service is created. It is associated with instance information that matches the private pool. When you create an instance, you can set whether to use a private pool to start the instance. The instance will match the elastic protection service or the capacity reservation service.

-After you call this operation to modify the properties of an instance"s private pool, the instance does not need to be restarted.
-The system rematches the private pool of the instance when you call the following API. If the instance matches the specified private pool, the call may fail due to insufficient capacity of the private pool or the failure of the private pool. If the call fails, call the ModifyInstanceAttachmentAttributes operation to change the matching mode of the private pool to open ".
-StartInstance restart the instance to enable the shutdown mode.
-ReActivateInstances
-ModifyInstanceChargeType
-ModifyPrepayInstanceSpec
-ReplaceSystemDisk
 */
async function modifyInstanceAttachmentAttributes(request: ModifyInstanceAttachmentAttributesRequest): ModifyInstanceAttachmentAttributesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyInstanceAttachmentAttributes', 'POST', 'undefined', 'json', false, 'none', request);
}

model ModifyVirtualBorderRouterAttributeRequest {
  regionId?: string(name='RegionId', position='Query'),
  vbrId?: string(name='VbrId', position='Query'),
  vlanId?: int32(name='VlanId', position='Query'),
  circuitCode?: string(name='CircuitCode', position='Query'),
  localGatewayIp?: string(name='LocalGatewayIp', position='Query'),
  peerGatewayIp?: string(name='PeerGatewayIp', position='Query'),
  peeringSubnetMask?: string(name='PeeringSubnetMask', position='Query'),
  description?: string(name='Description', position='Query'),
  name?: string(name='Name', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  clientToken?: string(name='ClientToken', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  userCidr?: string(name='UserCidr', position='Query'),
}

model ModifyVirtualBorderRouterAttributeResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyVirtualBorderRouterAttributeResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyVirtualBorderRouterAttributeResponseBody(name='body'),
}

async function modifyVirtualBorderRouterAttribute(request: ModifyVirtualBorderRouterAttributeRequest): ModifyVirtualBorderRouterAttributeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyVirtualBorderRouterAttribute', 'POST', 'undefined', 'json', false, 'none', request);
}

model LeaveSecurityGroupRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', description='The ID of the RAM user.', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='The account name of the resource master account.', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', description='The ID of the resource master account, that is, the UID.', position='Query'),
  securityGroupId?: string(name='SecurityGroupId', description='The ID of the security group.', position='Query'),
  networkInterfaceId?: string(name='NetworkInterfaceId', description='The ID of the Eni.

> When this parameter is specified, "InstanceId" must be empty.', position='Query'),
  instanceId?: string(name='InstanceId', description='The ID of the instance.

> When this parameter is specified, "NetworkInterfaceId" must be empty.', position='Query'),
  regionId?: string(name='RegionId', description='The ID of the region. You can call [DescribeRegions](~~ 25609 ~~) to view the latest region list.

-You can remove an instance from a security group without specifying the region ID.
-To remove an Eni from a security group, you must specify the region ID of the Eni.', position='Query'),
}

model LeaveSecurityGroupResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.'),
}

model LeaveSecurityGroupResponse = {
  headers: map[string]string(name='headers'),
  body: LeaveSecurityGroupResponseBody(name='body'),
}

/**
 * ## API description
> This API is not recommended. We recommend that you call the [ModifyInstanceAttribute](~~ 25503 ~~) API to add or remove an ECS instance from a security group. Call the [ModifyNetworkInterfaceAttribute](~~ 58513 ~~) API to remove an ENI (ENI) add or remove a security group.


When you call this operation, note that:

-Before removing a security group, the instance must be in the **Stopped**(Stopped) or **Running**(Running) status.

-An instance must be added to at least one security group. If the instance is added to only one security group, LeaveSecurityGroup request fails.

-You cannot remove an instance and an Eni from the same security group at the same time, that is, you cannot pass values for the "InstanceId" and "NetworkInterfaceId" parameters at the same time.
 */
async function leaveSecurityGroup(request: LeaveSecurityGroupRequest): LeaveSecurityGroupResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'LeaveSecurityGroup', 'POST', 'undefined', 'json', false, 'none', request);
}

model UnassignPrivateIpAddressesRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', description='The ID of the RAM user.', position='Query'),
  networkInterfaceId?: string(name='NetworkInterfaceId', description='The ID of the Eni.', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', description='The ID of the resource master account, that is, the UID.', position='Query'),
  regionId?: string(name='RegionId', description='The region to which the resource belongs. You can call [DescribeRegions](~~ 25609 ~~) to view the latest region list.', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='The account name of the resource master account.', position='Query'),
  privateIpAddress?: [ string ](name='PrivateIpAddress', description='One or more secondary private IP addresses to be deleted.', position='Query'),
}

model UnassignPrivateIpAddressesResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.'),
}

model UnassignPrivateIpAddressesResponse = {
  headers: map[string]string(name='headers'),
  body: UnassignPrivateIpAddressesResponseBody(name='body'),
}

/**
 * ## API description

-Only Enis in The **Available**(Available) or **InUse** state are supported.

-When operating the primary Eni, the attached instance must be in the **Running**(Running) or **Stopped**(Stopped) status.
 */
async function unassignPrivateIpAddresses(request: UnassignPrivateIpAddressesRequest): UnassignPrivateIpAddressesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UnassignPrivateIpAddresses', 'POST', 'undefined', 'json', false, 'none', request);
}

model DescribeInstanceVncPasswdRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  instanceId?: string(name='InstanceId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
}

model DescribeInstanceVncPasswdResponseBody = {
  vncPasswd?: string(name='VncPasswd'),
  requestId?: string(name='RequestId'),
}

model DescribeInstanceVncPasswdResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeInstanceVncPasswdResponseBody(name='body'),
}

async function describeInstanceVncPasswd(request: DescribeInstanceVncPasswdRequest): DescribeInstanceVncPasswdResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeInstanceVncPasswd', 'POST', 'undefined', 'json', false, 'none', request);
}

model ImportKeyPairRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  tag?: [ 
    {
      key?: string(name='Key', description='密钥对的标签键。N的取值范围：1~20。一旦传入该值，则不允许为空字符串。最多支持128个字符，不能以aliyun和acs:开头，不能包含http://或者https://。'),
      value?: string(name='Value', description='密钥对的标签值。N的取值范围：1~20。一旦传入该值，允许为空字符串。最多支持128个字符，不能以acs:开头，不能包含http://或者https://。'),
    }
  ](name='Tag', position='Query'),
  regionId?: string(name='RegionId', description='The ID of the region. You can call [DescribeRegions](~~ 25609 ~~) to view the latest region list.', position='Query'),
  ownerId?: long(name='OwnerId', description='The ID of the RAM user.', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='The account name of the resource master account.', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', description='The ID of the resource master account, that is, the UID.', position='Query'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group to which the SSH key pair belongs.', position='Query'),
  keyPairName?: string(name='KeyPairName', description='The name of the key pair. The name must be unique. The description must be 2 to 128 characters in length. It must start with a letter and cannot start with http:// or https. It can contain numbers, colons (:), underscores (_), and hyphens (-).', position='Query'),
  publicKeyBody?: string(name='PublicKeyBody', description='The public key of the key pair.', position='Query'),
}

model ImportKeyPairResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.'),
  keyPairName?: string(name='KeyPairName', description='The name of the key pair.'),
  keyPairFingerPrint?: string(name='KeyPairFingerPrint', description='The fingerprint of the key pair. According to the public key fingerprint format defined in RFC4716, MD5 Information Digest Algorithm is adopted.'),
}

model ImportKeyPairResponse = {
  headers: map[string]string(name='headers'),
  body: ImportKeyPairResponseBody(name='body'),
}

/**
 * ## API description

When you call this operation, note that:

-The maximum number of key pairs in each region is 500.

-The imported key pair must support any of the following encryption methods:

-rsa
-dsa
-ssh-rsa
-ssh-dss
-ecdsa
-ssh-rsa-cert-v00@openssh.com
-ssh-dss-cert-v00@openssh.com
-ssh-rsa-cert-v01@openssh.com
-ssh-dss-cert-v01@openssh.com
-ecdsa-sha2-nistp256-cert-v01@openssh.com
-ecdsa-sha2-nistp384-cert-v01@openssh.com
-ecdsa-sha2-nistp521-cert-v01@openssh.com
 */
async function importKeyPair(request: ImportKeyPairRequest): ImportKeyPairResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ImportKeyPair', 'POST', 'undefined', 'json', false, 'none', request);
}

model DeleteRecycleBinRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  resourceIds?: string(name='resourceIds', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
}

model DeleteRecycleBinResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteRecycleBinResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteRecycleBinResponseBody(name='body'),
}

async function deleteRecycleBin(request: DeleteRecycleBinRequest): DeleteRecycleBinResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteRecycleBin', 'POST', 'undefined', 'json', false, 'none', request);
}

model SoftDeleteInstancesRequest {
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  instanceId?: [ string ](name='InstanceId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  clientToken?: string(name='ClientToken', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  ownerId?: long(name='OwnerId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  hours?: int32(name='Hours', position='Query'),
}

model SoftDeleteInstancesResponseBody = {
  requestId?: string(name='RequestId'),
}

model SoftDeleteInstancesResponse = {
  headers: map[string]string(name='headers'),
  body: SoftDeleteInstancesResponseBody(name='body'),
}

async function softDeleteInstances(request: SoftDeleteInstancesRequest): SoftDeleteInstancesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'SoftDeleteInstances', 'POST', 'undefined', 'json', false, 'none', request);
}

model ModifyImageAttributeRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  licenseType?: string(name='LicenseType', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', description='The ID of the resource master account, that is, the UID.', position='Query'),
  ownerId?: long(name='OwnerId', description='The ID of the RAM user.', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='The account name of the resource master account.', position='Query'),
  imageId?: string(name='ImageId', description='The ID of the custom image.', position='Query'),
  description?: string(name='Description', description='The description of the custom image. The description must be 2 to 256 characters in length. It cannot start with "http:// "or "https.

Default: empty, said keep original description information unchanged.', position='Query'),
  imageFamily?: string(name='ImageFamily', description='The name of the Image family. The description must be 2 to 128 characters in length. It must start with a letter and cannot start with "aliyun" or "acs:". It cannot contain "http://" or "https://". It can contain numbers, periods (.), colons (:), underscores (_), and hyphens (-).

Default value: Null.', position='Query'),
  imageName?: string(name='ImageName', description='The name of the custom image. The description must be 2 to 128 characters in length. It must start with a letter and cannot start with "aliyun" or "acs:". It cannot contain "http://" or "https://". It can contain numbers, periods (.), colons (:), underscores (_), and hyphens (-).

Default value: null, indicating that the original name remains unchanged.', position='Query'),
  status?: string(name='Status', description='The status of the image. Valid values:
-Deprecated: sets the image to Deprecated. If you have already shared a custom image, you must cancel the sharing before changing it to the deprecated state. Images in the deprecated state cannot be shared or copied. However, you can use an image to create an instance or replace the system disk.
-Available: set the image to Available. You can restore a deprecated image.

> If you want to roll back the previous version of the custom image in the Image family, you can set the latest available custom image to deprecated, however, if the image is the only custom image in the available state in the Image family, the custom image in the unavailable state is used to create an instance after the image is discarded, therefore, proceed with caution.', position='Query'),
  bootMode?: string(name='BootMode', description='Modify the startup mode of an image. Valid values:

-BIOS:BIOS startup mode.
-UEFI:UEFI startup mode.

> you need to know the startup mode supported by the specified image. After you use this parameter to modify the startup mode, the instance must match the startup mode supported by the image to start normally.', position='Query'),
  regionId?: string(name='RegionId', description='The region ID of the custom image. You can call [DescribeRegions](~~ 25609 ~~) to view the latest region list.', position='Query'),
}

model ModifyImageAttributeResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.'),
}

model ModifyImageAttributeResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyImageAttributeResponseBody(name='body'),
}

async function modifyImageAttribute(request: ModifyImageAttributeRequest): ModifyImageAttributeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyImageAttribute', 'POST', 'undefined', 'json', false, 'none', request);
}

model DescribeImageComponentsRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  resourceGroupId?: string(name='ResourceGroupId', position='Query'),
  tag?: [ 
    {
      key?: string(name='Key', description='标签键。N的取值范围：1~20'),
      value?: string(name='Value', description='标签值。N的取值范围：1~20'),
    }
  ](name='Tag', position='Query'),
  nextToken?: string(name='NextToken', description='Query the credential (Token). The value is the value of the "NextToken" parameter returned by the last call to the API. You do not need to set this parameter when you call the API for the first time.', position='Query'),
  maxResults?: int32(name='MaxResults', description='The number of entries to return on each page. Valid values: 1 to 500.

Default value: 50.', position='Query'),
  imageComponentId?: [ string ](name='ImageComponentId', description='The ID of the image component to be queried. Valid values of N: 1 to 20.', position='Query'),
  owner?: string(name='Owner', description='The type of the image component. Valid values:

-SELF: The custom image component you created.
-ALIYUN: The system component provided by Alibaba Cloud.', position='Query'),
  name?: string(name='Name', description='The name of the image component. Only exact search is supported.', position='Query'),
}

model DescribeImageComponentsResponseBody = {
  nextToken?: string(name='NextToken', description='The Token returned by this call. For more information, see API description.'),
  requestId?: string(name='RequestId', description='The ID of the request.'),
  totalCount?: int32(name='TotalCount', description='The number of returned image components.'),
  maxResults?: int32(name='MaxResults', description='The number of entries to return on each page.'),
  imageComponent?: {
    imageComponentSet?: [ 
    {
      creationTime?: string(name='CreationTime', description='The time when the component was created.'),
      description?: string(name='Description', description='The description.'),
      systemType?: string(name='SystemType', description='The operating system supported by the component.'),
      imageComponentId?: string(name='ImageComponentId', description='The ID of the image component.'),
      componentType?: string(name='ComponentType', description='The type of the component.'),
      resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group.'),
      name?: string(name='Name', description='The name of the component.'),
      content?: string(name='Content', description='The content of the component.'),
      owner?: string(name='Owner', description='The type of the image component. Possible values:

-SELF: The custom image component you created.
-ALIYUN: The system component provided by Alibaba Cloud.'),
      tags?: {
        tag?: [ 
        {
          tagValue?: string(name='TagValue', description='The value of the tag.'),
          tagKey?: string(name='TagKey', description='The key of the tag.'),
        }
      ](name='Tag')
      }(name='Tags', description='The list of key-value pairs.'),
    }
  ](name='ImageComponentSet')
  }(name='ImageComponent', description='The list of image components.'),
}

model DescribeImageComponentsResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeImageComponentsResponseBody(name='body'),
}

/**
 * ## API description

You can set the "NextToken" query credential (Token) to the value of the "NextToken" parameter returned DescribeImageComponents the last call, and then set the maximum number of entries for a single-page query through "maxresule.
 */
async function describeImageComponents(request: DescribeImageComponentsRequest): DescribeImageComponentsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeImageComponents', 'POST', 'undefined', 'json', false, 'none', request);
}

model AddBandwidthPackageIpsRequest {
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  bandwidthPackageId?: string(name='BandwidthPackageId', position='Query'),
  ipCount?: string(name='IpCount', position='Query'),
  clientToken?: string(name='ClientToken', position='Query'),
}

model AddBandwidthPackageIpsResponseBody = {
  requestId?: string(name='RequestId'),
}

model AddBandwidthPackageIpsResponse = {
  headers: map[string]string(name='headers'),
  body: AddBandwidthPackageIpsResponseBody(name='body'),
}

async function addBandwidthPackageIps(request: AddBandwidthPackageIpsRequest): AddBandwidthPackageIpsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'AddBandwidthPackageIps', 'POST', 'undefined', 'json', false, 'none', request);
}

model DescribeInstanceStatusRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  clusterId?: string(name='ClusterId', description='The ID of the cluster to which the instance belongs.', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', description='The ID of the resource master account, that is, the UID.', position='Query'),
  pageSize?: int32(name='PageSize', description='The number of entries to return on each page. Valid values: 1 to 50.

Default value: 10', position='Query'),
  zoneId?: string(name='ZoneId', description='The zone to which the instance belongs.', position='Query'),
  regionId?: string(name='RegionId', description='The ID of the region to which the instance belongs. You can call [DescribeRegions](~~ 25609 ~~) to view the latest region list.', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='The account name of the resource master account.', position='Query'),
  instanceId?: [ string ](name='InstanceId', description='The ID of one or more ECS instances. Valid values of N: 1 to 100. Multiple values are in the form of duplicate lists.', position='Query'),
  ownerId?: long(name='OwnerId', description='The ID of the RAM user.', position='Query'),
  pageNumber?: int32(name='PageNumber', description='The page number of the instance status list.

Start value: 1

Default value: 1.', position='Query'),
}

model DescribeInstanceStatusResponseBody = {
  pageSize?: int32(name='PageSize', description='The number of entries to return on each page.'),
  requestId?: string(name='RequestId', description='The ID of the request.'),
  pageNumber?: int32(name='PageNumber', description='The page number of the instance list.'),
  totalCount?: int32(name='TotalCount', description='The total number of instances.'),
  instanceStatuses?: {
    instanceStatus?: [ 
    {
      status?: string(name='Status', description='The status of the instance.'),
      instanceId?: string(name='InstanceId', description='The ID of the instance.'),
    }
  ](name='InstanceStatus')
  }(name='InstanceStatuses', description='The type of the instance status set (InstanceStatus).'),
}

model DescribeInstanceStatusResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeInstanceStatusResponseBody(name='body'),
}

/**
 * ## API description

-For more information about the lifecycle status of an ECS instance, see [instance status table](~~ 25687 ~~).

-You can call this operation to obtain the list of instances.
 */
async function describeInstanceStatus(request: DescribeInstanceStatusRequest): DescribeInstanceStatusResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeInstanceStatus', 'POST', 'undefined', 'json', false, 'none', request);
}

model DescribeNatGatewaysRequest {
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  natGatewayId?: string(name='NatGatewayId', position='Query'),
  vpcId?: string(name='VpcId', position='Query'),
  pageNumber?: int32(name='PageNumber', position='Query'),
  pageSize?: int32(name='PageSize', position='Query'),
}

model DescribeNatGatewaysResponseBody = {
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  pageNumber?: int32(name='PageNumber'),
  totalCount?: int32(name='TotalCount'),
  natGateways?: {
    natGateway?: [ 
    {
      status?: string(name='Status'),
      creationTime?: string(name='CreationTime'),
      vpcId?: string(name='VpcId'),
      spec?: string(name='Spec'),
      description?: string(name='Description'),
      natGatewayId?: string(name='NatGatewayId'),
      businessStatus?: string(name='BusinessStatus'),
      name?: string(name='Name'),
      instanceChargeType?: string(name='InstanceChargeType'),
      regionId?: string(name='RegionId'),
      forwardTableIds?: {
        forwardTableId?: [ string ](name='ForwardTableId')
      }(name='ForwardTableIds'),
      bandwidthPackageIds?: {
        bandwidthPackageId?: [ string ](name='BandwidthPackageId')
      }(name='BandwidthPackageIds'),
    }
  ](name='NatGateway')
  }(name='NatGateways'),
}

model DescribeNatGatewaysResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeNatGatewaysResponseBody(name='body'),
}

async function describeNatGateways(request: DescribeNatGatewaysRequest): DescribeNatGatewaysResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeNatGateways', 'POST', 'undefined', 'json', false, 'none', request);
}

model DeleteHpcClusterRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', description='The ID of the RAM user.', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', description='The ID of the resource master account, that is, the UID.', position='Query'),
  clientToken?: string(name='ClientToken', description='Ensure the idempotence of the request. Generate a parameter value from your client. Make sure that the value is unique among different requests. **ClientToken** supports only ASCII characters and cannot exceed 64 characters. For more information, see [how to ensure idempotence](~~ 25693 ~~).', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='The account name of the resource master account.', position='Query'),
  regionId?: string(name='RegionId', description='The ID of the region to which the HPC cluster belongs. You can call [DescribeRegions](~~ 25609 ~~) to view the latest region list.', position='Query'),
  hpcClusterId?: string(name='HpcClusterId', description='The ID of the HPC cluster.', position='Query'),
}

model DeleteHpcClusterResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.'),
}

model DeleteHpcClusterResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteHpcClusterResponseBody(name='body'),
}

async function deleteHpcCluster(request: DeleteHpcClusterRequest): DeleteHpcClusterResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteHpcCluster', 'POST', 'undefined', 'json', false, 'none', request);
}

model ResetDiskRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', description='The ID of the RAM user.', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='The account name of the resource master account.', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', description='The ID of the resource master account, that is, the UID.', position='Query'),
  diskId?: string(name='DiskId', description='The ID of the specified disk device.', position='Query'),
  snapshotId?: string(name='SnapshotId', description='The ID of the snapshot to be restored to a specified disk.', position='Query'),
}

model ResetDiskResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.'),
}

model ResetDiskResponse = {
  headers: map[string]string(name='headers'),
  body: ResetDiskResponseBody(name='body'),
}

/**
 * ## API description

When you call this operation, note that:

-The disk must be in the In_Use state.

-The status of the instance to be attached to the disk must be Stopped (Stopped).

-The specified parameter SnapshotId must be a historical snapshot created by DiskId.

-When you use [DescribeInstances](~~ 25506 ~~) to query ECS instance information, if the returned data contains "{"OperationLocks": {"LockReason" : "security"}}", all operations are prohibited.
 */
async function resetDisk(request: ResetDiskRequest): ResetDiskResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ResetDisk', 'POST', 'undefined', 'json', false, 'none', request);
}

model DescribeAutoProvisioningGroupsRequest {
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  regionId?: string(name='RegionId', description='The ID of the region where the auto provisioning Group is located.', position='Query'),
  pageSize?: int32(name='PageSize', description='The number of entries to return on each page.

Maximum Value: 100

Default value: 10', position='Query'),
  pageNumber?: int32(name='PageNumber', description='The number of the page to return.

Start value: 1

Default value: 1.', position='Query'),
  autoProvisioningGroupId?: [ string ](name='AutoProvisioningGroupId', description='The ID of the auto provisioning group. Valid values of N: 1 to 20.', position='Query'),
  autoProvisioningGroupName?: string(name='AutoProvisioningGroupName', description='The name of the auto provisioning group.', position='Query'),
  autoProvisioningGroupStatus?: [ string ](name='AutoProvisioningGroupStatus', description='The status of the auto provisioning group. Valid values:

-submitted: The auto provisioning group is created, but the scheduling task has not been started.
-active: the auto provisioning group has started scheduling tasks.
-deleted: the auto provisioning group has been deleted.
-delete-running: the auto provisioning group is being deleted.
-modifying: the auto provisioning group is being modified.', position='Query'),
}

model DescribeAutoProvisioningGroupsResponseBody = {
  pageSize?: int32(name='PageSize', description='The number of rows per page.'),
  requestId?: string(name='RequestId', description='The ID of the request.'),
  pageNumber?: int32(name='PageNumber', description='The page number.'),
  totalCount?: int32(name='TotalCount', description='The number of auto provisioning groups queried.'),
  autoProvisioningGroups?: {
    autoProvisioningGroup?: [ 
    {
      creationTime?: string(name='CreationTime', description='The creation time.'),
      autoProvisioningGroupName?: string(name='AutoProvisioningGroupName', description='The name of the auto provisioning group.'),
      status?: string(name='Status', description='The status of the auto provisioning group. Possible values:

-submitted: The auto provisioning group is created, but the scheduling task has not been started.
-active: the auto provisioning group has started scheduling tasks.
-deleted: the auto provisioning group has been deleted.
-delete-running: the auto provisioning group is being deleted.
-modifying: the auto provisioning group is being modified.'),
      terminateInstances?: boolean(name='TerminateInstances', description='Specifies whether to release instances in an auto provisioning group. Possible values:

-true: Releases instances in the group.
-false: the instances in the group are retained.'),
      maxSpotPrice?: float(name='MaxSpotPrice', description='The highest price for a preemptible instance.

> When MaxSpotPrice and LaunchTemplateConfig.N.MaxPrice are set at the same time, the lowest value prevail.

LaunchTemplateConfig.N.MaxPrice is set when you create an auto provisioning group and cannot be modified.'),
      state?: string(name='State', description='The overall scheduling status of the auto provisioning group. Possible values:

-fulfilled: the scheduling task has been completed.
-pending-fulfillment: the instance is being created.
-pending-termination: the instance is being removed.
-error: An error occurred while scheduling and the instance cluster failed to be delivered.'),
      launchTemplateId?: string(name='LaunchTemplateId', description='The ID of the associated instance launch template.'),
      validFrom?: string(name='ValidFrom', description='The start time of the auto provisioning group. This parameter is used to determine the validity period in combination with "ValidUntil.'),
      launchTemplateVersion?: string(name='LaunchTemplateVersion', description='The version of the associated instance launch template.'),
      terminateInstancesWithExpiration?: boolean(name='TerminateInstancesWithExpiration', description='Specifies whether to release instances in the auto provisioning group upon expiration. Possible values:

-true: Releases instances in the group.
-false: only instances in the group are removed from the auto provisioning group.'),
      regionId?: string(name='RegionId', description='The ID of the region.'),
      validUntil?: string(name='ValidUntil', description='The expiration time of the auto provisioning group. This parameter is used together with "ValidFrom" to determine the validity period.'),
      autoProvisioningGroupType?: string(name='AutoProvisioningGroupType', description='The delivery type. Possible values:

-request: one-time request. The provisioning group delivers the instance cluster only at startup and does not retry after scheduling fails.

-maintain: continuous supply. The provisioning group attempts to deliver the instance cluster at startup and monitors the real-time capacity. If the target capacity is not reached, it attempts to continue creating ECS instances.'),
      autoProvisioningGroupId?: string(name='AutoProvisioningGroupId', description='The ID of the auto provisioning group.'),
      excessCapacityTerminationPolicy?: string(name='ExcessCapacityTerminationPolicy', description='Whether to release the scale-in instance when the real-time capacity of the auto provisioning group exceeds the target capacity and the scale-in is triggered. Possible values:

-termination: releases the scaled-In instance.
-no-termination: only the scaled-in instances are removed from the auto provisioning group.'),
      launchTemplateConfigs?: {
        launchTemplateConfig?: [ 
        {
          maxPrice?: float(name='MaxPrice', description='The maximum price of the instance type corresponding to the extended launch template.'),
          priority?: float(name='Priority', description='The priority of the instance type corresponding to the extended launch template. The highest value is 0.'),
          vSwitchId?: string(name='VSwitchId', description='The ID of the vSwitch corresponding to the extended launch template.'),
          weightedCapacity?: float(name='WeightedCapacity', description='The weight of the instance type corresponding to the extended launch template.'),
          instanceType?: string(name='InstanceType', description='Expand the instance type corresponding to the launch template.'),
        }
      ](name='LaunchTemplateConfig')
      }(name='LaunchTemplateConfigs', description='The details of the extended launch template.'),
      spotOptions?: {
        instancePoolsToUseCount?: int32(name='InstancePoolsToUseCount', description='The auto provisioning group selects the instance type with the lowest price to create the number of instances.

> This parameter is set when you create an auto provisioning group and cannot be modified.'),
        allocationStrategy?: string(name='AllocationStrategy', description='The policy used to create preemptible instances. Possible values:

-lowest-price: the cost optimization policy. Select the instance type with the lowest price.

-diversified: the distribution strategy of the balanced zone. Create instances in the zones specified by the extended launch template and distribute them evenly to each zone.'),
        instanceInterruptionBehavior?: string(name='InstanceInterruptionBehavior', description='The next action after the excess preemptible instance is stopped. Possible values:

-stop: the status is stopped.
-terminate: release.'),
      }(name='SpotOptions', description='The policies related to preemptible instances.'),
      payAsYouGoOptions?: {
        allocationStrategy?: string(name='AllocationStrategy', description='Create quantity pay instance strategy. Possible values:

-lowest-price: the cost optimization policy. Select the instance type with the lowest price.

-prioritized: the priority policy. Create instances based on the Priority set by LaunchTemplateConfig.N.Priority.

> LaunchTemplateConfig.N.Priority is set when you create an auto provisioning group and cannot be modified.'),
      }(name='PayAsYouGoOptions', description='Policies related to pay-as-you-go instances.'),
      targetCapacitySpecification?: {
        spotTargetCapacity?: float(name='SpotTargetCapacity', description='The target capacity of the preemptible instance.'),
        payAsYouGoTargetCapacity?: float(name='PayAsYouGoTargetCapacity', description='The target capacity of the pay-as-you-go instance.'),
        defaultTargetCapacityType?: string(name='DefaultTargetCapacityType', description='If the sum of PayAsYouGoTargetCapacity and SpotTargetCapacity is less than TotalTargetCapacity, the billing method of the specified differential capacity. Possible values:

-PayAsYouGo: pay-as-you-go instance
-Spot: preemptible instance'),
        totalTargetCapacity?: float(name='TotalTargetCapacity', description='The total capacity of the auto provisioning group. It consists of the following three parts:

-PayAsYouGoTargetCapacity
-SpotTargetCapacity
-Differential capacity beyond PayAsYouGoTargetCapacity and SpotTargetCapacity'),
      }(name='TargetCapacitySpecification', description='The target capacity of the auto provisioning group.'),
    }
  ](name='AutoProvisioningGroup')
  }(name='AutoProvisioningGroups', description='The details of the auto provisioning group.'),
}

model DescribeAutoProvisioningGroupsResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeAutoProvisioningGroupsResponseBody(name='body'),
}

async function describeAutoProvisioningGroups(request: DescribeAutoProvisioningGroupsRequest): DescribeAutoProvisioningGroupsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeAutoProvisioningGroups', 'POST', 'undefined', 'json', false, 'none', request);
}

model ModifyDiskChargeTypeRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='The account name of the resource master account.', position='Query'),
  diskIds?: string(name='DiskIds', description='The list of disk ids. A JSON Array in the format can contain up to 16 IDs. Separate them with commas (,).', position='Query'),
  regionId?: string(name='RegionId', description='The ID of the region to which the instance belongs. You can call [DescribeRegions](~~ 25609 ~~) to view the latest region list.', position='Query'),
  ownerId?: long(name='OwnerId', description='The ID of the resource master account, that is, the UID.', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', description='The ID of the RAM user.', position='Query'),
  clientToken?: string(name='ClientToken', description='Ensure the idempotence of the request. Generate a parameter value from your client. Make sure that the value is unique among different requests. **ClientToken** supports only ASCII characters and cannot exceed 64 characters. For more information, see [how to ensure idempotence](~~ 25693 ~~).', position='Query'),
  diskChargeType?: string(name='DiskChargeType', description='The billing method of the cloud disk. Valid values:

-PrePaid (default): converts a pay-as-you-go data disk to a subscription data disk.
-PostPaid: convert a subscription data disk to a pay-as-you-go data disk.
', position='Query'),
  instanceId?: string(name='InstanceId', description='The ID of the instance to which the disk is mounted.', position='Query'),
  autoPay?: boolean(name='AutoPay', description='Indicates whether to pay automatically. Valid values:

-true (default): automatic payment. You must ensure that your account balance is sufficient. If your account balance is insufficient, an abnormal order will be generated and you can only cancel the order.
-false: only generated orders are billed. If your account balance is insufficient, a normal unpaid order is generated. You can log on to the ECS console to pay for this order.
', position='Query'),
}

model ModifyDiskChargeTypeResponseBody = {
  orderId?: string(name='OrderId', description='The ID of the generated order.'),
  requestId?: string(name='RequestId', description='The ID of the request.'),
}

model ModifyDiskChargeTypeResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyDiskChargeTypeResponseBody(name='body'),
}

/**
 * ## API description

<props = "intl"> fees are automatically deducted by default after the billing method is changed. You must ensure that your account balance is sufficient. Otherwise, an abnormal order will be generated. In this case, you can only cancel the order. If your account balance is insufficient, you can set the AutoPay parameter to false. A normal unpaid order is generated. You can log on to the [ECS console](https://ecs.console.aliyun.com/) to pay. </props>

<props = "china"> after the billing method is changed, the fee is automatically deducted by default. You must ensure that your account balance is sufficient. Otherwise, an abnormal order will be generated. In this case, you can only cancel the order. If your account balance is insufficient, you can set the AutoPay parameter to false. A normal unpaid order is generated. You can log on to the [ECS console](https://ecs.console.aliyun.com/) to pay. </props>

When you call this operation, note the following:

-When you convert a subscription cloud disk to a pay-as-you-go cloud disk, it applies to the subscription cloud disks attached to the subscription instance.

-When you convert a pay-as-you-go cloud disk to a subscription cloud disk, it applies to pay-as-you-go data disks attached to a subscription instance or pay-as-you-go data disks attached to a pay-as-you-go instance.

-The attached instance cannot be stopped due to overdue payments.

-The billing method of each cloud disk cannot exceed three times, that is, the price difference refund cannot exceed three times.

-Refund of price difference before and after the change of billing method will be returned to your original billing method, and used vouchers will not be returned.

-The billing method of each cloud disk has been modified once, and cannot be modified again within five minutes.

-<props = "china"> for disks with multiple mount features, only the pay-as-you-go billing method is supported, but not the subscription billing method. </props>

 */
async function modifyDiskChargeType(request: ModifyDiskChargeTypeRequest): ModifyDiskChargeTypeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyDiskChargeType', 'POST', 'undefined', 'json', false, 'none', request);
}

model ModifyAutoProvisioningGroupRequest {
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  launchTemplateConfig?: [ 
    {
      vSwitchId?: string(name='VSwitchId', description='扩展启动模板中，ECS实例加入的虚拟交换机的ID。扩展模板中启动的ECS实例的可用区由虚拟交换机决定。'),
      maxPrice?: double(name='MaxPrice', description='扩展启动模板中，抢占式实例的价格上限。'),
      priority?: int32(name='Priority', description='扩展启动模板的优先级，取值为0时优先级最高。取值范围：大于0'),
      instanceType?: string(name='InstanceType', description='扩展启动模板对应的实例规格，N的取值范围：1~20。取值范围：请参见[实例规格族](~~25378~~)。'),
      weightedCapacity?: double(name='WeightedCapacity', description='扩展启动模板中，实例规格的权重。取值越高，单台实例满足计算力需求的能力越大，所需的实例数量越小。取值范围：大于0

您可以根据指定实例规格的计算力和集群单节点最低计算力得出权重值。假设单节点最低计算力为8 vCPU、60 GiB，则：

- 8 vCPU、60 GiB的实例规格权重可以设置为1
- 16 vCPU、120 GiB的实例规格权重可以设置为2'),
    }
  ](name='LaunchTemplateConfig', position='Query'),
  payAsYouGoTargetCapacity?: string(name='PayAsYouGoTargetCapacity', description='The target capacity of pay-as-you-go instances in the auto provisioning group. Value range: parameter values smaller than TotalTargetCapacity.', position='Query'),
  terminateInstancesWithExpiration?: boolean(name='TerminateInstancesWithExpiration', description='Specifies whether to release instances in the auto provisioning group upon expiration. Valid values:

-true: Releases instances in the group.
-false: only instances in the group are removed from the auto provisioning group.', position='Query'),
  regionId?: string(name='RegionId', description='The ID of the region where the auto provisioning Group is located. You can call [DescribeRegions](~~ 25609 ~~) to view the latest region list.', position='Query'),
  defaultTargetCapacityType?: string(name='DefaultTargetCapacityType', description='If the sum of PayAsYouGoTargetCapacity and SpotTargetCapacity is less than TotalTargetCapacity, the billing method of the difference capacity is specified. Valid values:

-PayAsYouGo: pay-as-you-go instance
-Spot: preemptible instance', position='Query'),
  excessCapacityTerminationPolicy?: string(name='ExcessCapacityTerminationPolicy', description='Whether to release the scale-in instance when the real-time capacity of the auto provisioning group exceeds the target capacity and the scale-in is triggered. Valid values:

-termination: releases the scaled-In instance.
-no-termination: only the scaled-in instances are removed from the auto provisioning group.', position='Query'),
  autoProvisioningGroupId?: string(name='AutoProvisioningGroupId', description='The ID of the auto provisioning group.', position='Query'),
  spotTargetCapacity?: string(name='SpotTargetCapacity', description='The target capacity of preemptible instances in the auto provisioning group. Value range: parameter values smaller than TotalTargetCapacity.', position='Query'),
  totalTargetCapacity?: string(name='TotalTargetCapacity', description='The total capacity of the auto provisioning group. Value range: positive integer

The total capacity must be greater than or equal to the sum of the PayAsYouGoTargetCapacity (target capacity of the specified pay-as-you-go instance) and SpotTargetCapacity (target capacity of the specified preemptible instance).', position='Query'),
  maxSpotPrice?: float(name='MaxSpotPrice', description='The highest price for preemptible instances in the auto provisioning group.

> When MaxSpotPrice and LaunchTemplateConfig.N.MaxPrice are set at the same time, the lowest value prevail. LaunchTemplateConfig.N.MaxPrice is set when you create an auto provisioning group and cannot be modified.', position='Query'),
  autoProvisioningGroupName?: string(name='AutoProvisioningGroupName', description='The name of the auto provisioning group. The description must be 2 to 128 characters in length. It must start with a letter and cannot start with http:// or https. It can contain numbers, colons (:), underscores (_), and hyphens (-).', position='Query'),
}

model ModifyAutoProvisioningGroupResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.'),
}

model ModifyAutoProvisioningGroupResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyAutoProvisioningGroupResponseBody(name='body'),
}

/**
 * ## API description

Before modifying an auto provisioning group, note the following:

-If you modify the capacity or capacity-related settings of the provisioning group, the provisioning group performs a scheduling task after the modification is completed.

-If the provisioning group is in the deleting state, the provisioning group cannot be modified.
 */
async function modifyAutoProvisioningGroup(request: ModifyAutoProvisioningGroupRequest): ModifyAutoProvisioningGroupResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyAutoProvisioningGroup', 'POST', 'undefined', 'json', false, 'none', request);
}

model SendFileRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  instanceId?: [ string ](name='InstanceId', description='The list of ECS instances to run the command. You can specify a maximum of 50 ECS instance IDs. Valid values of N: 1 to 50.', position='Query'),
  targetDir?: string(name='TargetDir', description='Deliver the file to the Directory of the target ECS instance. If it does not exist, it is automatically created.', position='Query'),
  content?: string(name='Content', description='The content of the file. The size of a base64-encoded file cannot exceed 32KB.

-If the "ContentType" parameter is "PlainText", this field is plain text.
-If the "ContentType" parameter is "Base64", this field is Base64-encoded.', position='Query'),
  regionId?: string(name='RegionId', description='The region ID of the target ECS instance. You can call [DescribeRegions](~~ 25609 ~~) to view the latest region list.', position='Query'),
  description?: string(name='Description', description='The description. The full character set is supported and cannot exceed 512 characters in length.', position='Query'),
  name?: string(name='Name', description='The name of the file. The full character set is supported and cannot exceed 255 characters in length.', position='Query'),
  timeout?: long(name='Timeout', description='The timeout period of the object to be delivered. Unit: Seconds

-A timeout occurs when files cannot be delivered due to process reasons, missing modules, or missing cloud assistant clients.
-When the specified timeout period is less than 10 seconds, the system automatically sets the timeout period to 10 seconds to ensure successful delivery.

Default value: 60', position='Query'),
  overwrite?: boolean(name='Overwrite', description='Specifies whether to overwrite an object with the same name if it already exists in the destination directory.
-true: overwrites
-false: does not overwrite

Default value: false', position='Query'),
  fileGroup?: string(name='FileGroup', description='The user group of the file. This parameter takes effect only for Linux instances. The default value is root.', position='Query'),
  fileOwner?: string(name='FileOwner', description='The user of the file. This parameter takes effect only for Linux instances. The default value is root.', position='Query'),
  fileMode?: string(name='FileMode', description='The permissions of the file. This parameter takes effect only for Linux instances and is configured in the same way as the chmod command.

The default value is 0644, indicating that users have read/write permissions, and user groups and other users have read-only permissions.', position='Query'),
  contentType?: string(name='ContentType', description='The content type of the file.
-PlainText: Plain text
-Base64:Base64 encoding

Default value: PlainText', position='Query'),
}

model SendFileResponseBody = {
  invokeId?: string(name='InvokeId', description='The ID of the command execution.'),
  requestId?: string(name='RequestId', description='The ID of the request.'),
}

model SendFileResponse = {
  headers: map[string]string(name='headers'),
  body: SendFileResponseBody(name='body'),
}

/**
 * ## API description:
-The status of the target ECS instance must be running ("Running").
-The cloud assistant client must be installed on the target ECS instance. For more information, see [InstallCloudAssistant](~~ 85916 ~~).
-The cloud assistant client version must be later than the following version to support file delivery. If the error code "ClientNeedUpgrade" is returned, update the client to the latest version. For more information, see [upgrade or disable cloud assistant client upgrade](~~ 134383 ~~).
-Linux:1.0.2.569
-Windows:1.0.0.149
-The size of the file cannot exceed 32 KB after Base64 encoding.
-The error message returned because the status of the target ECS instance is abnormal, the network is abnormal, or the cloud assistant client is abnormal. Call [DescribeSendFileResults](~~~) for troubleshooting.
 */
async function sendFile(request: SendFileRequest): SendFileResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'SendFile', 'POST', 'undefined', 'json', false, 'none', request);
}

model DescribeVolumesRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  zoneId?: string(name='ZoneId', position='Query'),
  volumeIds?: string(name='VolumeIds', position='Query'),
  instanceId?: string(name='InstanceId', position='Query'),
  category?: string(name='Category', position='Query'),
  status?: string(name='Status', position='Query'),
  snapshotId?: string(name='SnapshotId', position='Query'),
  autoSnapshotPolicyId?: string(name='AutoSnapshotPolicyId', position='Query'),
  enableAutomatedSnapshotPolicy?: boolean(name='EnableAutomatedSnapshotPolicy', position='Query'),
  lockReason?: string(name='LockReason', position='Query'),
  pageNumber?: int32(name='PageNumber', position='Query'),
  pageSize?: int32(name='PageSize', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  KMSKeyId?: string(name='KMSKeyId', position='Query'),
  encrypted?: boolean(name='Encrypted', position='Query'),
  tag?: [ 
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='Tag', position='Query'),
}

model DescribeVolumesResponseBody = {
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  pageNumber?: int32(name='PageNumber'),
  totalCount?: int32(name='TotalCount'),
  volumes?: {
    volume?: [ 
    {
      serialNumber?: string(name='SerialNumber'),
      creationTime?: string(name='CreationTime'),
      status?: string(name='Status'),
      sourceSnapshotId?: string(name='SourceSnapshotId'),
      autoSnapshotPolicyId?: string(name='AutoSnapshotPolicyId'),
      storageSetId?: string(name='StorageSetId'),
      enableAutomatedSnapshotPolicy?: boolean(name='EnableAutomatedSnapshotPolicy'),
      volumeChargeType?: string(name='VolumeChargeType'),
      storageSetPartitionNumber?: int32(name='StorageSetPartitionNumber'),
      snapshotLinkId?: string(name='SnapshotLinkId'),
      encrypted?: boolean(name='Encrypted'),
      regionId?: string(name='RegionId'),
      mountInstanceNum?: int32(name='MountInstanceNum'),
      description?: string(name='Description'),
      volumeId?: string(name='VolumeId'),
      size?: int32(name='Size'),
      zoneId?: string(name='ZoneId'),
      category?: string(name='Category'),
      volumeName?: string(name='VolumeName'),
      KMSKeyId?: string(name='KMSKeyId'),
      operationLocks?: {
        operationLock?: [ 
        {
          lockReason?: string(name='LockReason'),
        }
      ](name='OperationLock')
      }(name='OperationLocks'),
      mountInstances?: {
        mountInstance?: [ 
        {
          attachedTime?: string(name='AttachedTime'),
          instanceId?: string(name='InstanceId'),
          device?: string(name='Device'),
        }
      ](name='MountInstance')
      }(name='MountInstances'),
      tags?: {
        tag?: [ 
        {
          tagValue?: string(name='TagValue'),
          tagKey?: string(name='TagKey'),
        }
      ](name='Tag')
      }(name='Tags'),
    }
  ](name='Volume')
  }(name='Volumes'),
}

model DescribeVolumesResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeVolumesResponseBody(name='body'),
}

async function describeVolumes(request: DescribeVolumesRequest): DescribeVolumesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeVolumes', 'POST', 'undefined', 'json', false, 'none', request);
}

model CreateActivationRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ipAddressRange?: string(name='IpAddressRange', description='The IP address of the host that allows the activation code. Valid values: IPv4 address, IPv6 address, or CIDR block.', position='Query'),
  instanceCount?: int32(name='InstanceCount', description='The maximum number of times an activation code is used to register a managed instance. Valid values: 1 to 1000.

Default value: 10', position='Query'),
  regionId?: string(name='RegionId', description='The ID of the region. Only China (Hangzhou), China (Beijing), and China (Shanghai) are supported.', position='Query'),
  description?: string(name='Description', description='The description of the activation code. It can be 1 to 100 characters in length and cannot start with "http:// "or "https.', position='Query'),
  timeToLiveInHours?: long(name='TimeToLiveInHours', description='The validity period of the activation code. After the activation code expires, it cannot be used to register a new instance. Unit: Hour. Valid values: 1 to 24.

Default value: 4.', position='Query'),
  instanceName?: string(name='InstanceName', description='The default instance name prefix. It can be 1 to 50 characters in length and must start with a letter. It cannot start with a special character or digit. It can only contain periods (.) in special characters., underscores (_), hyphens (-), and colons (:) cannot start with "http:// "or "https.

For instances registered with the activation code created by using this API, this name is used as the prefix to generate ordered instance names. You can also specify a new instance name when registering a managed instance to overwrite this default value.

When you register a managed instance, if the instance name is not specified, the name "< InstanceName>-00" is generated. The number of digits numbered "00" depends on the number of digits of "InstanceCount.', position='Query'),
}

model CreateActivationResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.'),
  activationCode?: string(name='ActivationCode', description='The code of the activation code. This code is returned only once when an API is called and cannot be queried later. Therefore, you must properly save the returned value.'),
  activationId?: string(name='ActivationId', description='Activation Code ID.'),
}

model CreateActivationResponse = {
  headers: map[string]string(name='headers'),
  body: CreateActivationResponseBody(name='body'),
}

/**
 * ## API description

After you register a non-Alibaba cloud server as an Alibaba Cloud managed instance by using an activation code, you can use various online services provided by Alibaba Cloud (such as cloud assistant, O & M orchestration service, and Yunxiao) in the managed instance.

The operating system of a non-Alibaba cloud server must comply with the following versions, and the server can access the public network before it can be registered as an Alibaba Cloud managed instance.

-Alibaba Cloud Linux 2
-CentOS 6, 7, 8, and later
-Debian 8/9/10 and later
-Ubuntu 12/14/16/18 and later
-CoreOS
-OpenSUSE
-RedHat 5/6/7 and later
-SUSE Linux Enterprise Server 11/12/15 and later
-Window Server 2012/2016/2019 and later


 */
async function createActivation(request: CreateActivationRequest): CreateActivationResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateActivation', 'POST', 'undefined', 'json', false, 'none', request);
}

model DescribeBandwidthPackagesRequest {
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  bandwidthPackageId?: string(name='BandwidthPackageId', position='Query'),
  natGatewayId?: string(name='NatGatewayId', position='Query'),
  pageNumber?: int32(name='PageNumber', position='Query'),
  pageSize?: int32(name='PageSize', position='Query'),
}

model DescribeBandwidthPackagesResponseBody = {
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  pageNumber?: int32(name='PageNumber'),
  totalCount?: int32(name='TotalCount'),
  bandwidthPackages?: {
    bandwidthPackage?: [ 
    {
      status?: string(name='Status'),
      creationTime?: string(name='CreationTime'),
      ipCount?: string(name='IpCount'),
      regionId?: string(name='RegionId'),
      instanceChargeType?: string(name='InstanceChargeType'),
      bandwidthPackageId?: string(name='BandwidthPackageId'),
      description?: string(name='Description'),
      bandwidth?: string(name='Bandwidth'),
      natGatewayId?: string(name='NatGatewayId'),
      zoneId?: string(name='ZoneId'),
      internetChargeType?: string(name='InternetChargeType'),
      businessStatus?: string(name='BusinessStatus'),
      name?: string(name='Name'),
      ISP?: string(name='ISP'),
      publicIpAddresses?: {
        publicIpAddresse?: [ 
        {
          ipAddress?: string(name='IpAddress'),
          allocationId?: string(name='AllocationId'),
        }
      ](name='PublicIpAddresse')
      }(name='PublicIpAddresses'),
    }
  ](name='BandwidthPackage')
  }(name='BandwidthPackages'),
}

model DescribeBandwidthPackagesResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeBandwidthPackagesResponseBody(name='body'),
}

async function describeBandwidthPackages(request: DescribeBandwidthPackagesRequest): DescribeBandwidthPackagesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeBandwidthPackages', 'POST', 'undefined', 'json', false, 'none', request);
}

model ApplyAutoSnapshotPolicyRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  regionId?: string(name='regionId', description='The ID of the region where the automatic snapshot policy and disk are located. You can call [DescribeRegions](~~ 25609 ~~) to view the latest region list.', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='The account name of the resource master account.', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', description='The ID of the resource master account, that is, the UID.', position='Query'),
  autoSnapshotPolicyId?: string(name='autoSnapshotPolicyId', description='The ID of the target automatic snapshot policy.', position='Query'),
  ownerId?: long(name='OwnerId', description='The ID of the RAM user.', position='Query'),
  diskIds?: string(name='diskIds', description='The ID of one or more cloud disks. The value is in JSON Array format. Separate disk IDs with commas (,).', position='Query'),
}

model ApplyAutoSnapshotPolicyResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.'),
}

model ApplyAutoSnapshotPolicyResponse = {
  headers: map[string]string(name='headers'),
  body: ApplyAutoSnapshotPolicyResponseBody(name='body'),
}

/**
 * ## API description

-Only one automatic snapshot policy can be applied to a cloud disk.

-One automatic snapshot policy can be applied to multiple disks.
 */
async function applyAutoSnapshotPolicy(request: ApplyAutoSnapshotPolicyRequest): ApplyAutoSnapshotPolicyResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ApplyAutoSnapshotPolicy', 'POST', 'undefined', 'json', false, 'none', request);
}

model CreateSecurityGroupRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  tag?: [ 
    {
      key?: string(name='key', description='安全组的标签键。

> 为提高兼容性，建议您尽量使用Tag.N.Key参数。'),
      value?: string(name='Value', description='安全组的标签值。N的取值范围：1~20。一旦传入该值，允许为空字符串。最多支持128个字符，不能以acs:开头，不能包含http://或者https://。'),
    }
  ](name='Tag', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='The account name of the resource master account.', position='Query'),
  description?: string(name='Description', description='The description of the security group. The description must be 2 to 256 characters in length and cannot start with http:// or https.

Default value: Null.', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', description='The ID of the resource master account, that is, the UID.', position='Query'),
  clientToken?: string(name='ClientToken', description='Ensure the idempotence of the request. Generate a parameter value from your client. Make sure that the value is unique among different requests. **ClientToken** supports only ASCII characters and cannot exceed 64 characters. For more information, see [how to ensure idempotence](~~ 25693 ~~).', position='Query'),
  securityGroupName?: string(name='SecurityGroupName', description='The name of the security group. The description must be 2 to 128 characters in length. It must start with a letter and cannot start with http:// or https. It can contain numbers, colons (:), underscores (_), and hyphens (-). Default value: Null.', position='Query'),
  ownerId?: long(name='OwnerId', description='The ID of the RAM user.', position='Query'),
  regionId?: string(name='RegionId', description='The ID of the region to which the security group belongs. You can call [DescribeRegions](~~ 25609 ~~) to view the latest region list.', position='Query'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group to which the security group belongs.', position='Query'),
  vpcId?: string(name='VpcId', description='The VPC ID to which the security group belongs.', position='Query'),
  securityGroupType?: string(name='SecurityGroupType', description='The type of the security group. Valid values: Basic Security Group and Enterprise Security Group. Valid values:

-normal: normal security group.
-enterprise: The enterprise Security Group. For more information, see [Enterprise Security Group Overview](~~ 120621 ~~).', position='Query'),
}

model CreateSecurityGroupResponseBody = {
  securityGroupId?: string(name='SecurityGroupId', description='The ID of the security group.'),
  requestId?: string(name='RequestId', description='The ID of the request.'),
}

model CreateSecurityGroupResponse = {
  headers: map[string]string(name='headers'),
  body: CreateSecurityGroupResponseBody(name='body'),
}

/**
 * ## API description

When you call this operation, note that:

-You can create up to 100 security groups in an Alibaba Cloud region.

-You must specify the VpcId parameter when creating a VPC-type security group.
 */
async function createSecurityGroup(request: CreateSecurityGroupRequest): CreateSecurityGroupResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateSecurityGroup', 'POST', 'undefined', 'json', false, 'none', request);
}

model DescribeEventDetailRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  eventId?: string(name='EventId', position='Query'),
}

model DescribeEventDetailResponseBody = {
  status?: string(name='Status'),
  planTime?: string(name='PlanTime'),
  expireTime?: string(name='ExpireTime'),
  effectTime?: string(name='EffectTime'),
  eventId?: string(name='EventId'),
  endTime?: string(name='EndTime'),
  limitTime?: string(name='LimitTime'),
  startTime?: string(name='StartTime'),
  requestId?: string(name='RequestId'),
  eventType?: string(name='EventType'),
  eventCategory?: string(name='EventCategory'),
  supportModify?: string(name='SupportModify'),
  mark?: string(name='Mark'),
  resourceId?: string(name='ResourceId'),
}

model DescribeEventDetailResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeEventDetailResponseBody(name='body'),
}

async function describeEventDetail(request: DescribeEventDetailRequest): DescribeEventDetailResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeEventDetail', 'POST', 'undefined', 'json', false, 'none', request);
}

model DescribeSnapshotLinksRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='The account name of the resource master account.', position='Query'),
  diskIds?: string(name='DiskIds', description='The ID of the disk. You can specify a maximum of 100 disk IDs at a time. The format of DiskIds parameter values is a JSON Array. Separate IDs with commas (,).', position='Query'),
  instanceId?: string(name='InstanceId', description='The ID of the instance.', position='Query'),
  ownerId?: long(name='OwnerId', description='The ID of the RAM user.', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', description='The ID of the resource master account, that is, the UID.', position='Query'),
  pageSize?: int32(name='PageSize', description='The number of entries to return on each page. Valid values: 1 to 100.

Default value: 10', position='Query'),
  regionId?: string(name='RegionId', description='The ID of the region to which the cloud disk belongs. You can call [DescribeRegions](~~ 25609 ~~) to view the latest region list.', position='Query'),
  snapshotLinkIds?: string(name='SnapshotLinkIds', description='The ID of the snapshot chain. You can specify up to 100 snapshot IDs at a time. The format of SnapshotLinkIds parameter values is a JSON Array. Separate IDs with commas (,).', position='Query'),
  pageNumber?: int32(name='PageNumber', description='The page number of the disk status list. Start value: 1

Default value: 1.', position='Query'),
}

model DescribeSnapshotLinksResponseBody = {
  pageSize?: int32(name='PageSize', description='The number of entries to return on each page.'),
  requestId?: string(name='RequestId', description='The ID of the request.'),
  pageNumber?: int32(name='PageNumber', description='The page number of the snapshot chain list.'),
  totalCount?: int32(name='TotalCount', description='The total number of snapshot chains.'),
  snapshotLinks?: {
    snapshotLink?: [ 
    {
      instantAccess?: boolean(name='InstantAccess', description='Indicates whether the snapshot extreme availability feature is enabled. Possible values:

-true: enabled. Only ESSDS support this feature.
-false: disabled. That is, a snapshot is a normal snapshot that is not enabled.'),
      totalSize?: long(name='TotalSize', description='The size of all snapshots in the snapshot chain. Unit: bytes.'),
      sourceDiskName?: string(name='SourceDiskName', description='The name of the source disk.'),
      sourceDiskSize?: int32(name='SourceDiskSize', description='The capacity of the source disk. Unit: GiB.'),
      sourceDiskType?: string(name='SourceDiskType', description='The type of the source disk. Possible values:

-system: system disk
-data: data disk'),
      instanceId?: string(name='InstanceId', description='The ID of the instance.'),
      snapshotLinkId?: string(name='SnapshotLinkId', description='The ID of the snapshot chain.'),
      totalCount?: int32(name='TotalCount', description='The total number of snapshots.'),
      regionId?: string(name='RegionId', description='The ID of the region to which the snapshot chain source disk belongs.'),
      sourceDiskId?: string(name='SourceDiskId', description='The ID of the source disk. This field is retained if the source disk of the snapshot has been deleted.'),
      instanceName?: string(name='InstanceName', description='The name of the instance.'),
      category?: string(name='Category', description='The type of the snapshot.

> This parameter will be deprecated soon. We recommend that you use the "InstantAccess" parameter to improve compatibility ".'),
    }
  ](name='SnapshotLink')
  }(name='SnapshotLinks', description='A collection of snapshot chain information.'),
}

model DescribeSnapshotLinksResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeSnapshotLinksResponseBody(name='body'),
}

/**
 * ## API description

When you call this operation, note that:

-The request parameters, such as "RegionId", "DiskIds", and "InstanceId", are used as filters. The parameters are logical and relational.

-If no parameter is specified, the filter does not work. If "DiskIds" and "SnapshotLinkIds" are both empty arrays, the filter is also considered valid, but the returned result is empty.
 */
async function describeSnapshotLinks(request: DescribeSnapshotLinksRequest): DescribeSnapshotLinksResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeSnapshotLinks', 'POST', 'undefined', 'json', false, 'none', request);
}

model DescribeInvocationResultsRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  commandId?: string(name='CommandId', description='The ID of the command.
', position='Query'),
  regionId?: string(name='RegionId', description='The ID of the region. You can call [DescribeRegions](~~ 25609 ~~) to view the latest region list.', position='Query'),
  instanceId?: string(name='InstanceId', description='The ID of the instance.', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='The account name of the resource master account.', position='Query'),
  invokeId?: string(name='InvokeId', description='The ID of the command execution. You can call the [DescribeInvocations](~~ 64840 ~~) operation to query InvokeId.', position='Query'),
  pageNumber?: long(name='PageNumber', description='The current page number. Start value: 1.

Default value: 1.', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', description='The ID of the resource master account, that is, the UID.', position='Query'),
  includeHistory?: boolean(name='IncludeHistory', description='Specifies whether to return the execution history of the command cycle. Valid values:

-true: returns the execution result of the command cycle. If this parameter is set to true, the value of the "InvokeId" parameter cannot be empty and must be the execution ID of the executed command periodically.
-false: indicates that no return is returned.

Default value: false', position='Query'),
  ownerId?: long(name='OwnerId', description='The ID of the RAM user.', position='Query'),
  pageSize?: long(name='PageSize', description='The number of entries to return on each page.

Maximum Value: 50

Default value: 10', position='Query'),
  invokeRecordStatus?: string(name='InvokeRecordStatus', description='The command execution status. Valid values:
-Running: Running
-Finished: Completed
-Failed: Failed.
-Stopped: Stopped', position='Query'),
  contentEncoding?: string(name='ContentEncoding', description='Specifies the encoding method of the "Output" field in the returned data. Valid values:
-PlainText: returns the original command content and output information.
-Base64: returns the base64-encoded command content and output information.

Default value: Base64', position='Query'),
}

model DescribeInvocationResultsResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.'),
  invocation?: {
    pageSize?: long(name='PageSize', description='The number of entries to return on each page.'),
    pageNumber?: long(name='PageNumber', description='The current page number.'),
    totalCount?: long(name='TotalCount', description='The total number of commands.'),
    invocationResults?: {
      invocationResult?: [ 
      {
        invocationStatus?: string(name='InvocationStatus', description='The command progress status of a single instance. Valid values:
-Pending: The system is verifying or sending commands.
-Invalid: The Specified Command type or parameter is incorrect.
-Aborted: failed to send the command to the instance. The instance must be running and the command can be sent within 1 minute.
-Running: The command is being executed on the instance.
-Success:
-Single command: the command is executed and the exit code is 0.
-Run periodically: The Last Run succeeds and the exit code is 0. The specified cycle has ended.
-Failed:
-Single command: the command is executed and the exit code is not 0.
-Periodic invocation: The Last Invocation succeeds and the exit code is not 0. The specified cycle will be aborted.
-Error: An Error occurred while running the command and cannot continue.
-Timeout: the command execution times out.
-Cancelled: the command execution has been canceled and the command has not been started.
-Stopping: the command that is being stopped.
-Terminated: The command is Terminated when it is executed.
-Scheduled:
-Single-Run command: not applicable and does not appear.
-Periodically executed command: pending execution.'),
        repeats?: int32(name='Repeats', description='The number of times that the command is run on the instance.
-If the execution method is immediate, the value is 0 or 1.
-If the execution mode is periodic, the value is the number of executions.'),
        commandId?: string(name='CommandId', description='The ID of the command.'),
        instanceId?: string(name='InstanceId', description='The ID of the instance.'),
        output?: string(name='Output', description='The output information after the command is executed.'),
        dropped?: int32(name='Dropped', description='The length of the text that is truncated and discarded when the length of the "Output" field exceeds 24KB.'),
        stopTime?: string(name='StopTime', description='If "StopInvocation" is called, it indicates the call time.'),
        exitCode?: long(name='ExitCode', description='The exit code of the command.

-The Linux instance is the exit code of the Shell command.
-Windows the exit code of the Bat or PowerShell command.'),
        startTime?: string(name='StartTime', description='The time when the command starts to run in the instance.'),
        errorInfo?: string(name='ErrorInfo', description='The error message returned because the command failed to be issued or failed to be executed. Valid values:
-Null: The Command runs normally.
-the specified instance does not exists: the specified instance does not exist or has been released.
-the instance has released when create task: the instance is released during command execution.
-the instance is not running when create task: the instance is not running when the command is executed.
-the command is not applicable: the command does not apply to the specified instance.
-the specified account does not exists: the specified account does not exist.
-the specified directory does not exists: the specified directory does not exist.
-the cron job expression is invalid: the specified periodic expression is invalid.
-the aliyun service is not running on the instance: the cloud assistant client is not running.
-the aliyun service in the instance does not response: the cloud assistant client does not respond.
-the aliyun service in the instance is upgrading now: the cloud assistant client is being upgraded.
-the aliyun service in the instance need upgrade: the cloud assistant client needs to be upgraded.
-the command delivery has been timeout.
-the command execution has been timeout: command execution timed out.
-the command execution got an exception.
-the command execution has been interrupted.
-the command execution exit code is not zero: the command execution ends and the exit code is not zero.'),
        errorCode?: string(name='ErrorCode', description='The code for the reason why the command fails to be issued or executed. Valid values:
-Null: The Command runs normally.
-InstanceNotExists: the specified instance does not exist or has been released.
-InstanceReleased: the instance is released during command execution.
-InstanceNotRunning: the instance is not running when the command is executed.
-CommandNotApplicable: the command does not apply to the specified instance.
-AccountNotExists: the specified account does not exist.
-DirectoryNotExists: the specified directory does not exist.
-BadCronExpression: the specified periodic expression is invalid.
-ClientNotRunning: The cloud assistant client is not running.
-ClientNotResponse: The cloud assistant client does not respond.
-ClientIsUpgrading: The cloud assistant client is being upgraded.
-ClientNeedUpgrade: The cloud assistant client needs to be upgraded.
-DeliveryTimeout: the sending command timed out.
-ExecutionTimeout: the command execution times out.
-ExecutionException: command execution exception occurs.
-ExecutionInterrupted: the command execution is interrupted.
-ExitCodeNonzero: The command is executed and the exit code is not 0.'),
        finishedTime?: string(name='FinishedTime', description='The completion time of the command. If the command execution times out, the completion time of the command execution is subject to the parameter CreateCommand specified in [TimedOut](~~ 64844 ~~).'),
        invokeId?: string(name='InvokeId', description='The ID of the command execution.'),
        invokeRecordStatus?: string(name='InvokeRecordStatus', description='The command execution status.'),
        username?: string(name='Username', description='The name of the user who runs the command on the ECS instance.'),
      }
    ](name='InvocationResult')
    }(name='InvocationResults', description='The result set of command execution.'),
  }(name='Invocation', description='The collection of command execution results.'),
}

model DescribeInvocationResultsResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeInvocationResultsResponseBody(name='body'),
}

/**
 * ## API description

-After you execute a command, it does not mean that the command is executed successfully and has the expected command effect. You can call this operation to view the actual execution results. The actual output results shall prevail.

-You can query the execution information of the last two weeks. The maximum number of execution information is 100,000.
 */
async function describeInvocationResults(request: DescribeInvocationResultsRequest): DescribeInvocationResultsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeInvocationResults', 'POST', 'undefined', 'json', false, 'none', request);
}

model DescribeInstanceAttachmentAttributesRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  pageSize?: int32(name='PageSize', description='The number of entries to return on each page.

Maximum Value: 100

Default value: 10', position='Query'),
  regionId?: string(name='RegionId', description='The ID of the region to which the elastic Protection Service belongs. You can call [DescribeRegions](~~ 25609 ~~) to view the latest region list.', position='Query'),
  instanceIds?: string(name='InstanceIds', description='The ID of the instance. The value can be a JSON Array consisting of multiple instance IDs. A maximum of 100 IDs can be entered. Separate IDs with commas (,).', position='Query'),
  pageNumber?: int32(name='PageNumber', description='The page number of the instance status list.

Start value: 1

Default value: 1.', position='Query'),
}

model DescribeInstanceAttachmentAttributesResponseBody = {
  pageSize?: int32(name='PageSize', description='The number of entries to return on each page.'),
  requestId?: string(name='RequestId', description='The ID of the request.'),
  pageNumber?: int32(name='PageNumber', description='The page number of the instance status list.'),
  totalCount?: int32(name='TotalCount', description='The number of records that meet the query criteria.'),
  instances?: {
    instance?: [ 
    {
      instanceId?: string(name='InstanceId', description='The ID of the instance.'),
      privatePoolOptionsMatchCriteria?: string(name='PrivatePoolOptionsMatchCriteria', description='The private pool matching mode of the instance. Possible values:

-Open: Open mode. The instance automatically matches the open private pool.
-Target: specifies the mode. The instance matches the specified private pool.
-None: the mode is not used. The instance does not use a private pool.'),
      privatePoolOptionsId?: string(name='PrivatePoolOptionsId', description='The ID of the private pool. When "privatepooloptionsmatchbeautia" returns "Open", the private pool ID is the ID of the private pool allocated when the system automatically matches.'),
    }
  ](name='Instance')
  }(name='Instances', description='A collection of private pool information that matches the instance.'),
}

model DescribeInstanceAttachmentAttributesResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeInstanceAttachmentAttributesResponseBody(name='body'),
}

/**
 * ## API description

A private pool is generated after an elastic protection service or a capacity reservation service is created. It is associated with instance information that matches the private pool. You can set a private pool when creating an instance. The instance will match the elastic protection service or the capacity reservation service.

When the private pool expires, the matching data between the instance and the private pool also becomes invalid. If you call this operation, the returned private pool information is empty.
 */
async function describeInstanceAttachmentAttributes(request: DescribeInstanceAttachmentAttributesRequest): DescribeInstanceAttachmentAttributesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeInstanceAttachmentAttributes', 'POST', 'undefined', 'json', false, 'none', request);
}

model DescribeDedicatedHostAutoRenewRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  dedicatedHostIds?: string(name='DedicatedHostIds', description='The ID of the dedicated host. You can enter up to 100 dedicated host IDs. Separate the IDs with commas (,).', position='Query'),
  regionId?: string(name='RegionId', description='The ID of the region to which the dedicated host belongs.', position='Query'),
}

model DescribeDedicatedHostAutoRenewResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.'),
  dedicatedHostRenewAttributes?: {
    dedicatedHostRenewAttribute?: [ 
    {
      periodUnit?: string(name='PeriodUnit', description='The renewal unit. Possible values:

-Week
-Month'),
      duration?: int32(name='Duration', description='The automatic renewal period.'),
      dedicatedHostId?: string(name='DedicatedHostId', description='The ID of the dedicated host.'),
      renewalStatus?: string(name='RenewalStatus', description='Specifies whether to automatically renew the subscription dedicated host. Valid values:

-AutoRenewal: auto renewal.
-Normal: to be renewed.
-NotRenewal: no renewal or expiration notification is sent. Alibaba Cloud sends a non-renewal reminder on the third day before expiration. If you do not renew a dedicated host, you can set it to Normal, and then renew [RenewDedicatedHosts](~~ 93287 ~~) or set it to automatic (AutoRenewal).'),
      autoRenewEnabled?: boolean(name='AutoRenewEnabled', description='Specifies whether to enable automatic renewal. Possible values:
-true: auto renewal
-false: auto renewal is disabled.'),
      autoRenewWithEcs?: string(name='AutoRenewWithEcs', description='If the expiration time of the subscription ECS instance is later than that of the dedicated host, indicates whether the dedicated host is automatically renewed with the ECS instance. Possible values:

-AutoRenewWithEcs: auto renewal is performed on the ECS instance.
-StopRenewWithEcs: the ECS instance is not automatically renewed.
'),
    }
  ](name='DedicatedHostRenewAttribute')
  }(name='DedicatedHostRenewAttributes', description='An array of auto-renewal attributes of a dedicated host.'),
}

model DescribeDedicatedHostAutoRenewResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeDedicatedHostAutoRenewResponseBody(name='body'),
}

async function describeDedicatedHostAutoRenew(request: DescribeDedicatedHostAutoRenewRequest): DescribeDedicatedHostAutoRenewResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeDedicatedHostAutoRenew', 'POST', 'undefined', 'json', false, 'none', request);
}

model ModifyStorageCapacityUnitAttributeRequest {
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  storageCapacityUnitId?: string(name='StorageCapacityUnitId', description='SCU ID.', position='Query'),
  name?: string(name='Name', description='The name of the SCU. The name must be 2 to 128 characters in length. It must start with a letter and cannot start with http:// or https. It can contain numbers, colons (:), underscores (_), and hyphens (-).', position='Query'),
  regionId?: string(name='RegionId', description='The ID of the region to which the SCU belongs. You can call [DescribeRegions](~~ 25609 ~~) to view the latest region list.', position='Query'),
  description?: string(name='Description', description='The description of the SCU. It must be 2 to 256 characters in length and cannot start with http:// or https.', position='Query'),
}

model ModifyStorageCapacityUnitAttributeResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.'),
}

model ModifyStorageCapacityUnitAttributeResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyStorageCapacityUnitAttributeResponseBody(name='body'),
}

async function modifyStorageCapacityUnitAttribute(request: ModifyStorageCapacityUnitAttributeRequest): ModifyStorageCapacityUnitAttributeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyStorageCapacityUnitAttribute', 'POST', 'undefined', 'json', false, 'none', request);
}

model CreateLaunchTemplateRequest {
  systemDisk?: {
    iops?: int32(name='Iops', position=''),
    diskName?: string(name='DiskName', description='System disk name. The description must be 2 to 128 characters in length. It must start with a letter and cannot start with http:// or https. It can contain numbers, colons (:), underscores (_), and hyphens (-).', position=''),
    size?: int32(name='Size', description='The size of the system disk. Unit: GiB. Valid values: 20 to 500.

The value of this parameter must be greater than or equal to max{20, ImageSize}.', position=''),
    description?: string(name='Description', description='System disk description. The description must be 2 to 256 characters in length and cannot start with http:// or https.', position=''),
    deleteWithInstance?: boolean(name='DeleteWithInstance', description='Indicates whether the system disk is released with the instance. Valid values:

-true: release with the instance
-false: the instance is not released.

Default value: true', position=''),
    performanceLevel?: string(name='PerformanceLevel', description='When you create an ESSD as a system disk, set the performance level of the disk. Valid values:

-PL0 (default): The maximum random read/write IOPS per disk is 10,000.
-PL1: The maximum random read/write IOPS per disk is 50,000.
-PL2: The maximum random read/write IOPS per disk is 100,000.
-PL3: The maximum random read/write IOPS per disk is 1 million.

For more information about how to select an ESSD performance level, see [ESSD cloud disk](~~ 122389 ~~).', position=''),
    category?: string(name='Category', description='The type of the system disk. Valid values:

-cloud: basic cloud disk.
-cloud_efficiency: Ultra disk.
-cloud_ssd:SSD cloud disk.
-cloud_essd:ESSD. You can set the performance level of a cloud disk by using the "SystemDisk.PerformanceLevel" parameter.

For phased-out instance types and non-I/O optimized instances, the default value is cloud. Otherwise, the default value is cloud_efficiency.', position=''),
  }(name='SystemDisk'),
  templateTag?: [ 
    {
      key?: string(name='Key', description='启动模板的标签键。N的取值范围：1~20。一旦传入该值，则不允许为空字符串。最多支持128个字符，不能以aliyun和acs:开头，不能包含http://或者https://。'),
      value?: string(name='Value', description='启动模板的标签值。N的取值范围：1~20。一旦传入该值，可以为空字符串。最多支持128个字符，不能以aliyun和acs:开头，不能包含http://或者https://。'),
    }
  ](name='TemplateTag', position='Query'),
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  dataDisk?: [ 
    {
      performanceLevel?: string(name='PerformanceLevel', description='创建ESSD云盘作为数据盘使用时，设置云盘的性能等级。N的取值必须和`DataDisk.N.Category=cloud_essd`中的N保持一致。取值范围：

- PL0：单盘最高随机读写IOPS 1万。
- PL1（默认）：单盘最高随机读写IOPS 5万。
- PL2：单盘最高随机读写IOPS 10万。
- PL3：单盘最高随机读写IOPS 100万。

有关如何选择ESSD性能等级，请参见[ESSD云盘](~~122389~~)。'),
      description?: string(name='Description', description='数据盘描述。长度为2~256个英文或中文字符，不能以http://和https://开头。'),
      snapshotId?: string(name='SnapshotId', description='创建数据盘n使用的快照。n的取值范围为1~16。指定参数`DataDisk.N.SnapshotId`后，参数`DataDisk.N.Size`会被忽略，实际创建的云盘大小为指定的快照的大小。

不能使用早于2013年7月15日（含）创建的快照，请求会报错被拒绝。'),
      size?: int32(name='Size', description='第n个数据盘的容量大小，n的取值范围为1~16，内存单位为GiB。取值范围：

-   cloud：5~2000
-   cloud_efficiency：20~32768
-   cloud_ssd：20~32768
-   cloud_essd：20~32768

该参数的取值必须大于等于参数`SnapshotId`指定的快照的大小。'),
      device?: string(name='Device'),
      diskName?: string(name='DiskName', description='数据盘名称。长度为2~128个英文或中文字符。必须以大小字母或中文开头，不能以http://和https://开头。可以包含数字、半角冒号（:）、下划线（_）或者连字符（-）。'),
      category?: string(name='Category', description='数据盘n的云盘种类。取值范围：

-   cloud：普通云盘
-   cloud_efficiency：高效云盘
-   cloud_ssd：SSD云盘
-   cloud_essd：ESSD云盘

I/O优化实例的默认值为cloud_efficiency，非I/O优化实例的默认值为cloud。'),
      deleteWithInstance?: boolean(name='DeleteWithInstance', description='表示数据盘是否随实例释放。取值范围：

- true：随实例释放
- false：不随实例释放

默认值：true'),
      encrypted?: string(name='Encrypted', description='数据盘是否加密。'),
    }
  ](name='DataDisk', position='Query'),
  networkInterface?: [ 
    {
      vSwitchId?: string(name='VSwitchId', description='辅助弹性网卡所属的虚拟交换机ID。实例与弹性网卡必须在同一VPC的同一可用区中，可以分属于不同交换机。`NetworkInterface.N`的N取值不能大于1。'),
      networkInterfaceName?: string(name='NetworkInterfaceName', description='辅助弹性网卡名称。`NetworkInterface.N`的N取值不能大于1。'),
      description?: string(name='Description', description='辅助弹性网卡描述信息。长度为2~256个英文或中文字符，不能以`http://`和`https://`开头。`NetworkInterface.N`的N取值不能大于1。'),
      securityGroupId?: string(name='SecurityGroupId', description='辅助弹性网卡所属安全组的ID。辅助弹性网卡的安全组和实例的安全组必须在同一个VPC下。`NetworkInterface.N`的N取值不能大于1。

> 不支持同时指定`NetworkInterface.N.SecurityGroupId`和`NetworkInterface.N.SecurityGroupIds.N`。

'),
      primaryIpAddress?: string(name='PrimaryIpAddress', description='辅助弹性网卡的主私有IP地址。`NetworkInterface.N`的N取值不能大于1。'),
      securityGroupIds?: [ string ](name='SecurityGroupIds', description='辅助弹性网卡加入的一个或多个安全组。安全组和辅助弹性网卡必须在同一个专有网络VPC中。`SecurityGroupIds.N`的N取值范围与辅助弹性网卡能够加入安全组配额有关。更多信息，请参见[使用限制](~~25412~~)。`NetworkInterface.N`的N取值不能大于1。

> 不支持同时指定`NetworkInterface.N.SecurityGroupId`和`NetworkInterface.N.SecurityGroupIds.N`。


'),
    }
  ](name='NetworkInterface', position='Query'),
  tag?: [ 
    {
      key?: string(name='Key', description='实例、块存储和弹性网卡的标签键。N的取值范围：1~20。一旦传入该值，则不允许为空字符串。最多支持64个字符，不能以aliyun和acs:开头，不能包含http://或者https://。'),
      value?: string(name='Value', description='实例、块存储和弹性网卡的标签值。N的取值范围：1~20。一旦传入该值，可以为空字符串。最多支持128个字符，不能以aliyun和acs:开头，不能包含http://或者https://。'),
    }
  ](name='Tag', position='Query'),
  versionDescription?: string(name='VersionDescription', description='The version description of the instance launch template. The description must be 2 to 256 characters in length and cannot start with http:// or https.', position='Query'),
  imageId?: string(name='ImageId', description='The ID of the image. You can use [DescribeImages](~~ 25534 ~~) to query the available image resources.', position='Query'),
  securityGroupId?: string(name='SecurityGroupId', description='The ID of the security group to which the new instance belongs. Instances in the same security group can access each other. A security group can manage up to 1,000 instances.

> you cannot specify both "SecurityGroupId" and "SecurityGroupIds ".', position='Query'),
  ioOptimized?: string(name='IoOptimized', description='Indicates whether the instance is I/O optimized. Valid values:

-none: Non-I/O optimized
-optimized:I/O optimized', position='Query'),
  vpcId?: string(name='VpcId', description='VPC VPC ID.', position='Query'),
  description?: string(name='Description', description='The description of the instance. The description must be 2 to 256 characters in length and cannot start with http:// or https.', position='Query'),
  spotDuration?: int32(name='SpotDuration', description='The retention period of a preemptible instance. Unit: hours. Valid values: 0 to 6.

-The retention period is 2 to 6 and is being invited for testing. If you want to activate the service, submit a ticket.
-If the value is 0, the mode is not protected.

Default value: 1.', position='Query'),
  launchTemplateName?: string(name='LaunchTemplateName', description='The name of the instance launch template. The description must be 2 to 128 characters in length. It must start with a letter and cannot start with http:// or https. It can contain numbers, colons (:), underscores (_), and hyphens (-).', position='Query'),
  regionId?: string(name='RegionId', description='The ID of the region. You can call [DescribeRegions](~~ 25609 ~~) to view the latest region list.', position='Query'),
  zoneId?: string(name='ZoneId', description='The ID of the zone to which the instance belongs.', position='Query'),
  enableVmOsConfig?: boolean(name='EnableVmOsConfig', description='Specifies whether to enable instance operating system configuration.
> This parameter will be deprecated soon. To improve compatibility, try to use other parameters.', position='Query'),
  spotStrategy?: string(name='SpotStrategy', description='Quantity instance preemption strategy. This parameter takes effect only when the value of "InstanceChargeType" is "PostPaid. Valid values:

-NoSpot: a pay-as-you-go instance.
-SpotWithPriceLimit: sets the maximum price for preemptible instances.
-SpotAsPriceGo: The system automatically bids based on the actual market price.', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='The account name of the resource master account.', position='Query'),
  ownerId?: long(name='OwnerId', description='The ID of the RAM user.', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', description='The ID of the resource master account, that is, the UID.', position='Query'),
  autoReleaseTime?: string(name='AutoReleaseTime', description='The automatic release time. The time follows the [ISO8601](~~ 25696 ~~) standard and uses UTC time. The format is yyyy-MM-ddTHH:mm:ssZ.

-If the value of seconds is not "00", it is automatically set to the beginning of the current minute ("mm").

-The minimum release time is half an hour later than the current time.

-The maximum release time cannot exceed three years.', position='Query'),
  internetChargeType?: string(name='InternetChargeType', description='The network billing method. Valid values:

-PayByBandwidth: pay-by-bandwidth
-PayByTraffic: pay by traffic

> **pay-by-traffic** mode: The peak inbound and outbound bandwidth is the upper limit of the bandwidth and is not used as a service commitment indicator. When a resource scramble occurs, the peak bandwidth may be limited. If your business needs to be guaranteed by bandwidth, use the **pay-by-bandwidth** mode.

', position='Query'),
  hostName?: string(name='HostName', description='The hostname of the ECS instance.

-Periods (.) and hyphens (-) cannot be used as start and end characters, and cannot be used consecutively.
-Windows instance: the name must be 2 to 15 characters in length and cannot contain periods (.). It can contain uppercase and lowercase letters, digits, and hyphens (-).
-Other types of instances (such as Linux): The name must be 2 to 64 characters in length and can contain multiple periods (.), A segment can contain uppercase and lowercase letters, digits, and hyphens (-).', position='Query'),
  ramRoleName?: string(name='RamRoleName', description='The name of the instance RAM role. You can use the RAM API [ListRoles](~~ 28713 ~~) to query the created instance RAM role.', position='Query'),
  vSwitchId?: string(name='VSwitchId', description='You must specify the vSwitch ID when creating a VPC-type instance.', position='Query'),
  userData?: string(name='UserData', description='The user data of the instance must be encoded in Base64. the maximum size of the raw data is 16kB.', position='Query'),
  passwordInherit?: boolean(name='PasswordInherit', description='Specifies whether to use the default password of the image.

> When you use this parameter, the Password parameter must be empty, and you must ensure that the Password has been set for the image you are using.', position='Query'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the enterprise resource group to which the instance, block storage, and Eni belong.', position='Query'),
  securityGroupIds?: [ string ](name='SecurityGroupIds', description='One or more security groups to which the instance belongs. The value range of N depends on the number of instances that can be added to the security group. For more information, see [limits](~~ 25412 ~~).

> you cannot specify both "SecurityGroupId" and "SecurityGroupIds ".', position='Query'),
  instanceType?: string(name='InstanceType', description='The type of the instance. For more information, see [instance type family](~~ 25378 ~~), or call [DescribeInstanceTypes](~~ 25620 ~~) to obtain the latest specification.', position='Query'),
  keyPairName?: string(name='KeyPairName', description='The name of the key pair.

-Windows the instance. Ignore this parameter. Even if this parameter is specified, only the "Password" content is executed.
-The password logon method for Linux instances is initialized to disable.', position='Query'),
  internetMaxBandwidthOut?: int32(name='InternetMaxBandwidthOut', description='The maximum outbound public bandwidth. Unit: Mbit/s. Valid values: 0 to 100.', position='Query'),
  deploymentSetId?: string(name='DeploymentSetId', description='The ID of the deployment set.', position='Query'),
  templateResourceGroupId?: string(name='TemplateResourceGroupId', description='The ID of the resource group to which the launch template belongs.', position='Query'),
  networkType?: string(name='NetworkType', description='The network type of the instance. Valid values:

-classic
-vpc', position='Query'),
  privateIpAddress?: string(name='PrivateIpAddress', description='The private IP address of the instance.

When you configure a private IP address for a VPC-type ECS instance, you must select an idle CIDR block from the vSwitch ("VSwitchId").', position='Query'),
  spotPriceLimit?: float(name='SpotPriceLimit', description='Set the maximum hourly price for an instance. A maximum of three decimal places are supported. This parameter takes effect when the value of "spotstratege" is "spotwithpricelime.', position='Query'),
  internetMaxBandwidthIn?: int32(name='InternetMaxBandwidthIn', description='The maximum inbound public bandwidth. Unit: Mbit/s. Valid values:

-When the purchased internet outbound bandwidth is less than or equal to 10Mbit/s: 1 to 10, the default value is 10.
-When the purchased internet outbound bandwidth is greater than 10Mbit/s: 1 to "InternetMaxBandwidthOut". The default value is "InternetMaxBandwidthOut.', position='Query'),
  instanceName?: string(name='InstanceName', description='The name of the instance. The description must be 2 to 128 characters in length. It must start with a letter and cannot start with http:// or https. It can contain numbers, colons (:), underscores (_), and hyphens (-).', position='Query'),
  period?: int32(name='Period', description='The duration of the resource. Unit: month. This parameter is required only when the instancechargetype" parameter is set to prepaid. Once the DedicatedHostId is specified, the value range cannot exceed the subscription duration of the DDH. Valid values:

-"PeriodUnit = Week", valid values of Period: {"1", "2", "3", and "4"}
-"PeriodUnit = Month", valid values of Period: {"1", "2", "3", "4", "5", "6", "7", "8", "9", "12", "24", "36", "48", "60"}', position='Query'),
  securityEnhancementStrategy?: string(name='SecurityEnhancementStrategy', description='Specifies whether to enable security hardening for the operating system. Valid values:

-Active: enables security hardening, which takes effect only for public images.
-Deactive: does not enable security hardening and takes effect for all image types.', position='Query'),
  instanceChargeType?: string(name='InstanceChargeType', description='The billing method of the instance. Valid values:

-<props = "china">PrePaid: subscription. If you select this type of payment method, make sure that your account supports balance payment and credit payment. Otherwise, the error message "InvalidPayMethod" is returned. </props>
-<props = "intl">PrePaid: subscription. When you select this billing method, you must ensure that your account supports credit payment. Otherwise, the error message "InvalidPayMethod" is returned. </props>
-<props = "partner">PrePaid: subscription. When you select this billing method, you must ensure that your account supports credit payment. Otherwise, the error message "InvalidPayMethod" is returned. </props>
-PostPaid: pay-as-you-go.', position='Query'),
  imageOwnerAlias?: string(name='ImageOwnerAlias', description='The source of the image. Valid values:

-system: a public image provided by Alibaba Cloud.
-self: The custom image you created.
-others: images shared by other Alibaba Cloud users.
-<props = "intl">marketplace: The image provided by [Alibaba Cloud marketplace](https://marketplace.alibabacloud.com/). You can directly use the cloud marketplace images that you query without subscribing to them in advance. You must pay attention to the billing details of Alibaba Cloud marketplace images. </props>
-<props = "china">marketplace: The image provided by [marketplace](https://market.aliyun.com/). You can directly use the cloud marketplace images that you query without subscribing to them in advance. You must pay attention to the billing details of Alibaba Cloud marketplace images. </props>

Default value: NULL. Null indicates that the system, self, and others values are returned.


', position='Query'),
}

model CreateLaunchTemplateResponseBody = {
  launchTemplateId?: string(name='LaunchTemplateId', description='The ID of the instance launch template.'),
  requestId?: string(name='RequestId', description='The ID of the request.'),
}

model CreateLaunchTemplateResponse = {
  headers: map[string]string(name='headers'),
  body: CreateLaunchTemplateResponseBody(name='body'),
}

/**
 * ## API description

The instance launch template contains configurations for creating an instance, such as the region, image ID, instance type, security group ID, and internet bandwidth. If you do not specify an instance configuration in the template, you must specify this configuration for the instance when creating the instance.

After you create a template ("CreateLaunchTemplate"), the initial version of the template is 1. You can create multiple template versions based on this version ("CreateLaunchTemplateVersion"). The version number increases from 1 to 1. If you do not specify the template version when creating an instance ([RunInstances](~~ 63440 ~~)), the default version is used.

When you call this operation, note that:

-You can create a maximum of 30 instance launch templates in a region, and each template can have a maximum of 30 versions.

-Most parameters of the instance launch template are optional. When you create a template, Alibaba Cloud does not verify the existence and validity of the parameter values in the template. The validity of parameter values is only verified when an instance is created.

-If a configuration is set in the instance launch template, the configuration cannot be filtered out when creating an instance ([RunInstances](~~ 63440 ~~). For example, if "HostName = LocalHost" is set to the template and "host" is set to null in "RunInstances", the hostname of the instance is still "LocalHost ". If you want to overwrite the "HostName = LocalHost" configuration, you can set "HostName = MyHost" or other parameter values in "RunInstances.
 */
async function createLaunchTemplate(request: CreateLaunchTemplateRequest): CreateLaunchTemplateResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateLaunchTemplate', 'POST', 'undefined', 'json', false, 'none', request);
}

model DescribeDeploymentSetSupportedInstanceTypeFamilyRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  regionId?: string(name='RegionId', description='The ID of the region to which the deployment set belongs. You can call [DescribeRegions](~~ 25609 ~~) to view the latest region list.', position='Query'),
}

model DescribeDeploymentSetSupportedInstanceTypeFamilyResponseBody = {
  instanceTypeFamilies?: string(name='InstanceTypeFamilies', description='Instance families that support deployment sets.'),
  requestId?: string(name='RequestId', description='The ID of the request.'),
}

model DescribeDeploymentSetSupportedInstanceTypeFamilyResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeDeploymentSetSupportedInstanceTypeFamilyResponseBody(name='body'),
}

/**
 * ## API description
For more information about instance type families, see [instance type families](~~ 25378 ~~).
 */
async function describeDeploymentSetSupportedInstanceTypeFamily(request: DescribeDeploymentSetSupportedInstanceTypeFamilyRequest): DescribeDeploymentSetSupportedInstanceTypeFamilyResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeDeploymentSetSupportedInstanceTypeFamily', 'POST', 'undefined', 'json', false, 'none', request);
}

model ListTagResourcesRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  tag?: [ 
    {
      key?: string(name='Key', description='精确查找ECS资源时使用的标签键。标签键长度的取值范围：1~128。N的取值范围：1~20

`Tag.N`用于精确查找绑定了指定标签的ECS资源，由一个键值对组成。

- 仅指定`Tag.N.Key`时，则返回关联该标签键的所有资源。

- 仅指定`Tag.N.Value`，则报错`InvalidParameter.TagValue`。

- 同时指定多个标签键值对时，仅同时满足所有标签键值对的ECS资源会被查找到。
 
'),
      value?: string(name='Value', description='精确查找ECS资源时使用的标签值。标签值长度的取值范围：1~128。N的取值范围：1~20'),
    }
  ](name='Tag', position='Query'),
  tagFilter?: [ 
    {
      tagValues?: [ string ](name='TagValues', description='模糊查找ECS资源时使用的标签值。标签值长度的取值范围：1~128。N的取值范围：1~5。具体的参数说明请参见`TagFilter.N.TagKey`参数描述。




'),
      tagKey?: string(name='TagKey', description='模糊查找ECS资源时使用的标签键。标签键长度的取值范围：1~128。N的取值范围：1~5

 `TagFilter.N`用于模糊查找绑定了指定标签的ECS资源，由一个键和一个或多个值组成。模糊查询可能会有2秒延时，仅支持模糊过滤后资源数小于等于5000的情况。

- 通过标签键（`TagFilter.N.TagKey`）模糊查找ECS资源时，标签值（`TagFilter.N.TagValues.N`）必须为空。例如，模糊搜索标签键为`environment`的ECS资源时，`TagFilter.1.TagKey`可以设置为`env*`（前缀匹配的模糊搜索方式）、`*env*`（两边匹配的模糊搜索方式）或者`env`（精确搜索方式），而`TagFilter.1.TagValues`必须为空。

- 通过标签值（`TagFilter.N.TagValues.N`）模糊查找ECS资源时，标签键（`TagFilter.N.TagKey`）必须设置为精确值。例如，模糊搜索标签键为`env`，标签值为`product`的ECS资源时，`TagFilter.1.TagKey`必须精确设置为`env`，`TagFilter.1.TagValues.1`可以设置为`proc*`（前缀匹配的模糊搜索方式）、`*proc*`（两边匹配的模糊搜索方式）或者`proc`（精确搜索方式）。同一个`TagKey`下只能用同一种搜索方式，如果设置了多个不同的搜索方式，则以第一个方式为准。

- 标签键之间为交集关系，即仅同时满足您指定的所有标签键的ECS资源才会被查找到。

- 同一标签键下的标签值之间为并集关系，即满足您为该标签键指定的任一标签值的ECS资源均会被查找到。

> `TagFilter.N`与`Tag.N`参数不能同时使用，否则会返回错误信息。'),
    }
  ](name='TagFilter', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', description='The account name of the resource master account.', position='Query'),
  resourceId?: [ string ](name='ResourceId', description='The ID of the ECS resource. Valid values of N: 1 to 50.', position='Query'),
  regionId?: string(name='RegionId', description='The ID of the region to which the resource belongs. You can call [DescribeRegions](~~ 25609 ~~) to view the latest region list.', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='The ID of the resource master account, that is, the UID.', position='Query'),
  resourceType?: string(name='ResourceType', description='The definition of the resource type. Valid values:

-instance:ECS instance
-disk: disk
-snapshot: snapshot
-image: image
-securitygroup: Security Group
-volume: storage volume
-eni: eni
-ddh: Dedicated host
-ddhcluster: Dedicated host cluster
-keypair:SSH key pair
-launchtemplate: launch Template
-reservedinstance: Reserved Instance
-snapshotpolicy: automatic snapshot policy
-elasticityassurance: elastic assurance
-capacityreservation: capacity reservation', position='Query'),
  ownerId?: long(name='OwnerId', description='The ID of the RAM user.', position='Query'),
  nextToken?: string(name='NextToken', description='The start Token of the next query.', position='Query'),
}

model ListTagResourcesResponseBody = {
  nextToken?: string(name='NextToken', description='The start Token of the next query.'),
  requestId?: string(name='RequestId', description='The ID of the request.'),
  tagResources?: {
    tagResource?: [ 
    {
      tagValue?: string(name='TagValue', description='The value of the tag.'),
      resourceType?: string(name='ResourceType', description='The type of the resource. Possible values:

-instance:ECS instance
-disk: disk
-snapshot: snapshot
-image: image
-securitygroup: Security Group
-volume: storage volume
-eni: eni
-ddh: Dedicated host
-ddhcluster: Dedicated host cluster
-keypair:SSH key pair
-launchtemplate: launch Template
-reservedinstance: Reserved Instance
-snapshotpolicy: automatic snapshot policy
-elasticityassurance: elastic assurance
-capacityreservation: capacity reservation'),
      resourceId?: string(name='ResourceId', description='The ID of the resource.'),
      tagKey?: string(name='TagKey', description='The key of the tag.'),
    }
  ](name='TagResource')
  }(name='TagResources', description='A collection of resources and their tags, including the resource ID, resource type, and tag key.'),
}

model ListTagResourcesResponse = {
  headers: map[string]string(name='headers'),
  body: ListTagResourcesResponseBody(name='body'),
}

/**
 * ## API description

Specify at least one of the following parameters in the request to determine the query object.

-"ResourceId"
-"Tag.... ("Tag.N.Key" and "Tag.N.Value")
-"TagFilter"

If the following parameters are specified, only the ECS resources that meet the two conditions are returned.

-"Tag. **and "ResourceId"
-"TagFilter. **and "ResourceId"
 */
async function listTagResources(request: ListTagResourcesRequest): ListTagResourcesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListTagResources', 'POST', 'undefined', 'json', false, 'none', request);
}

model DescribeIntranetAttributeKbRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  instanceId?: string(name='InstanceId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
}

model DescribeIntranetAttributeKbResponseBody = {
  intranetMaxBandwidthIn?: int32(name='IntranetMaxBandwidthIn'),
  requestId?: string(name='RequestId'),
  intranetIpAddress?: string(name='IntranetIpAddress'),
  instanceId?: string(name='InstanceId'),
  intranetMaxBandwidthOut?: int32(name='IntranetMaxBandwidthOut'),
  vlanId?: string(name='VlanId'),
}

model DescribeIntranetAttributeKbResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeIntranetAttributeKbResponseBody(name='body'),
}

async function describeIntranetAttributeKb(request: DescribeIntranetAttributeKbRequest): DescribeIntranetAttributeKbResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeIntranetAttributeKb', 'POST', 'undefined', 'json', false, 'none', request);
}

model ModifyVpcAttributeRequest {
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  vpcId?: string(name='VpcId', position='Query'),
  description?: string(name='Description', position='Query'),
  vpcName?: string(name='VpcName', position='Query'),
  cidrBlock?: string(name='CidrBlock', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  userCidr?: string(name='UserCidr', position='Query'),
}

model ModifyVpcAttributeResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyVpcAttributeResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyVpcAttributeResponseBody(name='body'),
}

async function modifyVpcAttribute(request: ModifyVpcAttributeRequest): ModifyVpcAttributeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyVpcAttribute', 'POST', 'undefined', 'json', false, 'none', request);
}

model RemoveBandwidthPackageIpsRequest {
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  bandwidthPackageId?: string(name='BandwidthPackageId', position='Query'),
  clientToken?: string(name='ClientToken', position='Query'),
  removedIpAddresses?: [ string ](name='RemovedIpAddresses', position='Query'),
}

model RemoveBandwidthPackageIpsResponseBody = {
  requestId?: string(name='RequestId'),
}

model RemoveBandwidthPackageIpsResponse = {
  headers: map[string]string(name='headers'),
  body: RemoveBandwidthPackageIpsResponseBody(name='body'),
}

async function removeBandwidthPackageIps(request: RemoveBandwidthPackageIpsRequest): RemoveBandwidthPackageIpsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'RemoveBandwidthPackageIps', 'POST', 'undefined', 'json', false, 'none', request);
}

model CreateNetworkInterfacePermissionRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  accountId?: long(name='AccountId', description='The account ID or individual user ID of the Alibaba Cloud Partner (Certified ISV).', position='Query'),
  permission?: string(name='Permission', description='The Eni permission action. Valid values:

InstanceAttach: allows authorized users to attach your Eni to the other ECS instance. The ECS instance and the Eni must be in the same zone.', position='Query'),
  networkInterfaceId?: string(name='NetworkInterfaceId', description='The ID of the Eni.', position='Query'),
  regionId?: string(name='RegionId', description='The region of the Eni. You can call [DescribeRegions](~~ 25609 ~~) to view the latest region list.', position='Query'),
}

model CreateNetworkInterfacePermissionResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.'),
  networkInterfacePermission?: {
    permission?: string(name='Permission', description='The Eni permission.'),
    networkInterfaceId?: string(name='NetworkInterfaceId', description='The ID of the Eni.'),
    accountId?: long(name='AccountId', description='The ID of the Alibaba Cloud Partner (Certified ISV) account.'),
    networkInterfacePermissionId?: string(name='NetworkInterfacePermissionId', description='The ID of the Eni permission.'),
    serviceName?: string(name='ServiceName', description='The name of the Alibaba Cloud service.'),
    permissionState?: string(name='PermissionState', description='The status of the Eni permission. Possible values:

-Pending: authorization in progress
-Granted: Authorized
-Revoking: the authorization is being revoked.
-Revoked: the authorization has been Revoked.'),
  }(name='NetworkInterfacePermission', description='The list of Eni permissions.'),
}

model CreateNetworkInterfacePermissionResponse = {
  headers: map[string]string(name='headers'),
  body: CreateNetworkInterfacePermissionResponseBody(name='body'),
}

/**
 * ## API description

Open a ticket to apply for this feature.
 */
async function createNetworkInterfacePermission(request: CreateNetworkInterfacePermissionRequest): CreateNetworkInterfacePermissionResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateNetworkInterfacePermission', 'POST', 'undefined', 'json', false, 'none', request);
}

model DescribeSnapshotsUsageRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='The account name of the resource master account.', position='Query'),
  ownerId?: long(name='OwnerId', description='The ID of the RAM user.', position='Query'),
  regionId?: string(name='RegionId', description='The ID of the region to which the snapshot belongs. You can call [DescribeRegions](~~ 25609 ~~) to view the latest region list.', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', description='The ID of the resource master account, that is, the UID.', position='Query'),
}

model DescribeSnapshotsUsageResponseBody = {
  snapshotSize?: long(name='SnapshotSize', description='The size of a snapshot in the current region. Unit: bytes.'),
  requestId?: string(name='RequestId', description='The ID of the request.'),
  snapshotCount?: int32(name='SnapshotCount', description='The total number of snapshots in the current region.'),
}

model DescribeSnapshotsUsageResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeSnapshotsUsageResponseBody(name='body'),
}

/**
 * If you want to know the snapshot usage of each disk in the current region, we recommend that you use [DescribeSnapshotLinks](~~ 55837 ~~) to query the snapshot chain.
 */
async function describeSnapshotsUsage(request: DescribeSnapshotsUsageRequest): DescribeSnapshotsUsageResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeSnapshotsUsage', 'POST', 'undefined', 'json', false, 'none', request);
}

model DeleteAutoSnapshotPolicyRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  resourceOwnerId?: long(name='ResourceOwnerId', description='The ID of the resource master account, that is, the UID.', position='Query'),
  ownerId?: long(name='OwnerId', description='The ID of the RAM user.', position='Query'),
  autoSnapshotPolicyId?: string(name='autoSnapshotPolicyId', description='The ID of the automatic snapshot policy. You can call [DescribeAutoSnapshotPolicyEx](~~ 25530 ~~) to view the available automatic snapshot policies.', position='Query'),
  regionId?: string(name='regionId', description='The ID of the region to which the automatic snapshot belongs. You can call [DescribeRegions](~~ 25609 ~~) to view the latest region list.', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='The account name of the resource master account.', position='Query'),
}

model DeleteAutoSnapshotPolicyResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.'),
}

model DeleteAutoSnapshotPolicyResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteAutoSnapshotPolicyResponseBody(name='body'),
}

async function deleteAutoSnapshotPolicy(request: DeleteAutoSnapshotPolicyRequest): DeleteAutoSnapshotPolicyResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteAutoSnapshotPolicy', 'POST', 'undefined', 'json', false, 'none', request);
}

model ModifySecurityGroupEgressRuleRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  regionId?: string(name='RegionId', description='The region ID of the source security group. You can call [DescribeRegions](~~ 25609 ~~) to view the latest region list.', position='Query'),
  destCidrIp?: string(name='DestCidrIp', description='The Destination IPv4 CIDR block. CIDR and IPv4 IP addresses are supported.

Default value: None', position='Query'),
  priority?: string(name='Priority', description='The priority of the security group rule. Valid values: 1 to 100.

Default value: 1.', position='Query'),
  sourceCidrIp?: string(name='SourceCidrIp', description='The source IPv4 CIDR block. CIDR and IPv4 IP addresses are supported.

Default value: None', position='Query'),
  ownerId?: long(name='OwnerId', description='The ID of the RAM user.', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', description='The ID of the resource master account, that is, the UID.', position='Query'),
  destGroupOwnerId?: long(name='DestGroupOwnerId', description='The ID of the account to which the destination security group belongs.', position='Query'),
  clientToken?: string(name='ClientToken', description='Ensure the idempotence of the request. Generate a parameter value from your client. Make sure that the value is unique among different requests. **ClientToken** supports only ASCII characters and cannot exceed 64 characters. For more information, see [how to ensure idempotence](~~ 25693 ~~).', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='The account name of the resource master account.', position='Query'),
  portRange?: string(name='PortRange', description='The port range related to the transport layer protocol opened by the destination security group. Valid values:

-TCP/UDP: valid values: 1 to 65535. Use a slash (/) to separate the start port from the end port. Example: 1/200
-ICMP:-1/-1
-GRE protocol:-1/-1
-all:-1/-1', position='Query'),
  destGroupId?: string(name='DestGroupId', description='The ID of the destination security group. Set at least one of the "DestGroupId" or "DestCidrIp" parameters.

-If "DestGroupId" is specified but "DestCidrIp" is not specified, the value of "NicType" can only be intranet.
-If both "DestGroupId" and "DestCidrIp" are specified, the default value is "DestCidrIp.', position='Query'),
  description?: string(name='Description', description='The description of the security group rule. The description must be 1 to 512 characters in length.', position='Query'),
  ipv6DestCidrIp?: string(name='Ipv6DestCidrIp', description='The Destination IPv6 CIDR block. CIDR and IPv6 IP addresses are supported.

> only VPC-type IP addresses are supported.

Default value: None', position='Query'),
  sourcePortRange?: string(name='SourcePortRange', description='The range of ports related to the transport layer protocol opened by the source security group. Valid values:

-TCP/UDP: valid values: 1 to 65535. Use a slash (/) to separate the start port from the end port. Example: 1/200
-ICMP:-1/-1
-GRE protocol:-1/-1
-all:-1/-1', position='Query'),
  ipProtocol?: string(name='IpProtocol', description='The transport layer protocol. Case insensitive. Valid values:

-icmp
-gre
-tcp
-udp
-all: all protocols are supported.', position='Query'),
  ipv6SourceCidrIp?: string(name='Ipv6SourceCidrIp', description='The source IPv6 CIDR block. CIDR and IPv6 IP addresses are supported.

Default value: None', position='Query'),
  destGroupOwnerAccount?: string(name='DestGroupOwnerAccount', description='The logon name of the account to which the destination security group belongs.', position='Query'),
  securityGroupId?: string(name='SecurityGroupId', description='The ID of the source security group.', position='Query'),
  policy?: string(name='Policy', description='The access permission. Valid values:

-accept: Accepts access.
-drop: denies access and does not send back the deny message.

Default value: accept', position='Query'),
  destPrefixListId?: string(name='DestPrefixListId', description='The ID of the destination Prefix List. You can call [DescribePrefixLists](~~ 205046 ~~) to query the list IDs of available prefixes.

If you specify one of the "DestCidrIp", "Ipv6DestCidrIp", or "DestGroupId" parameters, this parameter is ignored.', position='Query'),
  nicType?: string(name='NicType', description='The NIC type of the classic network security group rule. Valid values:

-internet: internet Nic
-intranet: intranet Nic

Default value: internet

In the following cases, the parameter NicType can only be set to intranet:

-If the network type of the security group rule is VPC, you must set the NicType parameter, which can only be intranet.
-When the security group is configured to access each other, that is, only the "DestGroupId" parameter is specified, it can only be intranet.', position='Query'),
}

model ModifySecurityGroupEgressRuleResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.'),
}

model ModifySecurityGroupEgressRuleResponse = {
  headers: map[string]string(name='headers'),
  body: ModifySecurityGroupEgressRuleResponseBody(name='body'),
}

/**
 * ## API description

A security group outbound rule can be determined by any of the following parameters. A security group rule cannot be determined by specifying only one parameter.

-Rules for authorizing access from specified CIDR blocks. For example, IpProtocol, PortRange, (optional) SourcePortRange, NicType, Policy, (optional) SourceCidrIp, and DestCidrIp.

"""
https://ecs.aliyuncs.com/? Action=ModifySecurityGroupEgressRule
&SecurityGroupId=sg-bp67acfmxazb4p ****
&DestCidrIp=10.0.0.0/8
&IpProtocol=tcp
&PortRange=80/80
&Policy=allow
&Description=This is a new securitygroup rule.
& <common request parameters>
"""

-Rules for authorizing access from other security groups. For example, IpProtocol, PortRange, (optional) SourcePortRange, NicType, Policy, (optional) SourceCidrIp, and DestGroupId.

"""
https://ecs.aliyuncs.com/? Action=ModifySecurityGroupEgressRule
&SecurityGroupId=sg-bp67acfmxazb4p ****
&DestGroupId=sg-bp67acfmxa123b ****
&IpProtocol=tcp
&PortRange=80/80
&Policy=allow
&Description=This is a new securitygroup rule.
& <common request parameters>
"""

-Security group rules associated with the prefix list. For example, IpProtocol, PortRange, (optional) SourcePortRange, NicType, Policy, (optional) SourceCidrIp, and DestPrefixListId.

"""
https://ecs.aliyuncs.com/? Action=ModifySecurityGroupEgressRule
&SecurityGroupId=sg-bp67acfmxazb4p ****
&DestPrefixListId=pl-x1j1k5ykzqlixdcy ****
&IpProtocol=tcp
&PortRange=80/80
&Policy=allow
&Description=This is a new securitygroup rule.
& <common request parameters>
"""
 */
async function modifySecurityGroupEgressRule(request: ModifySecurityGroupEgressRuleRequest): ModifySecurityGroupEgressRuleResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifySecurityGroupEgressRule', 'POST', 'undefined', 'json', false, 'none', request);
}

model CopySnapshotRequest {
  tag?: [ 
    {
      key?: string(name='Key', description='新快照的标签键。一旦传入该值，则不允许为空字符串。最多支持128个字符，不能以aliyun和acs:开头，不能包含http://或者https://。'),
      value?: string(name='Value', description='新快照的标签值。一旦传入该值，允许为空字符串。最多支持128个字符，不能以aliyun和acs:开头，不能包含http://或者https://。'),
    }
  ](name='Tag', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  resourceGroupId?: string(name='ResourceGroupId', position='Query'),
  destinationSnapshotName?: string(name='DestinationSnapshotName', description='The name of the new snapshot. The description must be 2 to 128 characters in length. It must start with a letter and cannot start with http:// or https. It can contain numbers, colons (:), underscores (_), and hyphens (-).

Default value: Null.', position='Query'),
  retentionDays?: int32(name='RetentionDays', description='The retention period of a new snapshot. Unit: Days. Snapshots are automatically released after expiration. Valid values: 1 to 65536.

Default value: null, indicating that snapshots are not automatically released.', position='Query'),
  regionId?: string(name='RegionId', description='The region of the source snapshot. You can call [DescribeRegions](~~ 25609 ~~) to view the latest region list.', position='Query'),
  destinationRegionId?: string(name='DestinationRegionId', description='The region ID of the new snapshot.', position='Query'),
  snapshotId?: string(name='SnapshotId', description='The ID of the source snapshot.', position='Query'),
  destinationSnapshotDescription?: string(name='DestinationSnapshotDescription', description='The description of the new snapshot. The description must be 2 to 256 characters in length and cannot start with http:// or https.

Default value: Null.', position='Query'),
}

model CopySnapshotResponseBody = {
  snapshotId?: string(name='SnapshotId', description='The ID of the new snapshot.'),
  requestId?: string(name='RequestId', description='The ID of the request.'),
}

model CopySnapshotResponse = {
  headers: map[string]string(name='headers'),
  body: CopySnapshotResponseBody(name='body'),
}

/**
 * ## API description

When you call this operation, note that:

-The new snapshot cannot be rolled back to the disk corresponding to the source snapshot.
-Encrypted snapshots cannot be copied.
-Local snapshots cannot be copied.
 */
async function copySnapshot(request: CopySnapshotRequest): CopySnapshotResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CopySnapshot', 'POST', 'undefined', 'json', false, 'none', request);
}

model DescribePrefixListAttributesRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  prefixListId?: string(name='PrefixListId', description='The ID of the prefix list.', position='Query'),
  regionId?: string(name='RegionId', description='The ID of the region.', position='Query'),
}

model DescribePrefixListAttributesResponseBody = {
  creationTime?: string(name='CreationTime', description='The time when the prefix list was created.'),
  maxEntries?: int32(name='MaxEntries', description='The maximum number of entries supported by the prefix list.'),
  requestId?: string(name='RequestId', description='The ID of the request.'),
  description?: string(name='Description', description='The description of the prefix list.'),
  addressFamily?: string(name='AddressFamily', description='The address family of the prefix list. Possible values:

-IPv4
-IPv6'),
  prefixListName?: string(name='PrefixListName', description='The name of the prefix list.'),
  prefixListId?: string(name='PrefixListId', description='The ID of the prefix list.'),
  entries?: {
    entry?: [ 
    {
      description?: string(name='Description', description='The description of the prefix list entry.'),
      cidr?: string(name='Cidr', description='The CIDR block information of the prefix list entry.'),
    }
  ](name='Entry')
  }(name='Entries', description='An array of entries in the prefix list.'),
}

model DescribePrefixListAttributesResponse = {
  headers: map[string]string(name='headers'),
  body: DescribePrefixListAttributesResponseBody(name='body'),
}

async function describePrefixListAttributes(request: DescribePrefixListAttributesRequest): DescribePrefixListAttributesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribePrefixListAttributes', 'POST', 'undefined', 'json', false, 'none', request);
}

model DescribeReservedInstancesRequest {
  tag?: [ 
    {
      key?: string(name='Key', description='预留实例券的标签键。N的取值范围：1~20。一旦传入该值，则不允许为空字符串。最多支持128个字符，不能以aliyun和acs:开头，不能包含http://或者https://。

使用一个标签过滤资源，查询到该标签下的资源数量不能超过1000个；使用多个标签过滤资源，查询到同时绑定了多个标签的资源数量不能超过1000个。如果资源数量超过1000个，请使用[ListTagResources](~~110425~~)接口进行查询。'),
      value?: string(name='Value', description='预留实例券的标签值。N的取值范围：1~20。一旦传入该值，允许为空字符串。最多支持128个字符，不能以acs:开头，不能包含http://或者https://。'),
    }
  ](name='Tag', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  pageNumber?: int32(name='PageNumber', description='The page number of the reserved instance List. Start value: 1.

Default value: 1.', position='Query'),
  pageSize?: int32(name='PageSize', description='The number of entries to return on each page. Maximum value: 100.

Default value: 10', position='Query'),
  lockReason?: string(name='LockReason', description='The lock type. Valid values:

-financial: The account is overdue or the service has expired.
-security: security reasons', position='Query'),
  regionId?: string(name='RegionId', description='The ID of the region to which the instance belongs. You can call [DescribeRegions](~~ 25609 ~~) to view the latest region list.', position='Query'),
  reservedInstanceName?: string(name='ReservedInstanceName', description='The name of the reserved instance.', position='Query'),
  offeringType?: string(name='OfferingType', description='The Payment type of the reserved instance. Valid values:

-No Upfront: zero prepaid
-Partial Upfront: Partial prepaid
-All Upfront: full prepaid', position='Query'),
  scope?: string(name='Scope', description='The range of Reserved Instances. Valid values:

-Region: Region
-Zone: Zone

Default value: Region', position='Query'),
  reservedInstanceId?: [ string ](name='ReservedInstanceId', description='The ID of the reserved instance. Valid values of N: 1 to 100.', position='Query'),
  zoneId?: string(name='ZoneId', description='The ID of the Zone to which the instance belongs. This parameter is required when the Scope parameter is set to Zone. For more information, see [DescribeZones](~~ 25610 ~~) for a list of zones.', position='Query'),
  instanceType?: string(name='InstanceType', description='The instance type. For more information, see [instance type family](~~ 25378 ~~).', position='Query'),
  status?: [ string ](name='Status', description='The status of the reserved instance. Valid values of N: 1 to 100. Valid values:

-Creating: Creating
-Active: In validity period
-Expired: Expired
-Updating: the reserved instance properties are being changed.', position='Query'),
  allocationType?: string(name='AllocationType', description='The allocation type. Valid values:

-Normal: queries Reserved Instances under the current account.
-Shared: queries Reserved instances that have been Shared by primary and sub-accounts under the current account.

Default value: Normal', position='Query'),
  instanceTypeFamily?: string(name='InstanceTypeFamily', description='The instance type family. For more information, see [instance type family](~~ 25378 ~~).', position='Query'),
}

model DescribeReservedInstancesResponseBody = {
  pageSize?: int32(name='PageSize', description='The number of entries to return on each page.'),
  requestId?: string(name='RequestId', description='The ID of the request.'),
  pageNumber?: int32(name='PageNumber', description='The page number of the reserved instance list.'),
  totalCount?: int32(name='TotalCount', description='The total number of reserved instances.'),
  reservedInstances?: {
    reservedInstance?: [ 
    {
      status?: string(name='Status', description='State.'),
      creationTime?: string(name='CreationTime', description='The creation time.'),
      reservedInstanceName?: string(name='ReservedInstanceName', description='The name.'),
      reservedInstanceId?: string(name='ReservedInstanceId', description='The ID of the reserved instance.'),
      instanceType?: string(name='InstanceType', description='The type of the pay-as-you-go instance.'),
      instanceAmount?: int32(name='InstanceAmount', description='The number of pay-as-you-go instances of the same specification can be matched.'),
      regionId?: string(name='RegionId', description='The ID of the region.'),
      offeringType?: string(name='OfferingType', description='The payment type.'),
      startTime?: string(name='StartTime', description='The effective time.'),
      description?: string(name='Description', description='The description.'),
      allocationStatus?: string(name='AllocationStatus', description='If the AllocationType value is Shared, this parameter indicates the allocation status of Reserved Instances. Possible values:

-allocated: Reserved instances that have been allocated to other users.
-beAllocated: Reserved Instances allocated to other users.
'),
      expiredTime?: string(name='ExpiredTime', description='The expiration time.'),
      resourceGroupId?: string(name='ResourceGroupId', description='The resource group.'),
      zoneId?: string(name='ZoneId', description='The ID of the zone.'),
      platform?: string(name='Platform', description='The operating system type of the image used by the instance. Possible values:

-Windows:Windows Server-type operating system.

-Linux:Linux and Unix-like operating systems.'),
      scope?: string(name='Scope', description='The range.'),
      operationLocks?: {
        operationLock?: [ 
        {
          lockReason?: string(name='LockReason', description='The reason for the lock.'),
        }
      ](name='OperationLock')
      }(name='OperationLocks', description='Indicates whether the instance is locked.'),
      tags?: {
        tag?: [ 
        {
          tagValue?: string(name='TagValue', description='The tag value of the reserved instance.'),
          tagKey?: string(name='TagKey', description='The tag key of the reserved instance.'),
        }
      ](name='Tag')
      }(name='Tags', description='The tag pair of the reserved instance.'),
    }
  ](name='ReservedInstance')
  }(name='ReservedInstances', description='Returns the details of Reserved Instances in an array of ReservedInstance.'),
}

model DescribeReservedInstancesResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeReservedInstancesResponseBody(name='body'),
}

async function describeReservedInstances(request: DescribeReservedInstancesRequest): DescribeReservedInstancesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeReservedInstances', 'POST', 'undefined', 'json', false, 'none', request);
}

model CreateVirtualBorderRouterRequest {
  regionId?: string(name='RegionId', position='Query'),
  physicalConnectionId?: string(name='PhysicalConnectionId', position='Query'),
  vbrOwnerId?: long(name='VbrOwnerId', position='Query'),
  vlanId?: int32(name='VlanId', position='Query'),
  circuitCode?: string(name='CircuitCode', position='Query'),
  localGatewayIp?: string(name='LocalGatewayIp', position='Query'),
  peerGatewayIp?: string(name='PeerGatewayIp', position='Query'),
  peeringSubnetMask?: string(name='PeeringSubnetMask', position='Query'),
  description?: string(name='Description', position='Query'),
  name?: string(name='Name', position='Query'),
  clientToken?: string(name='ClientToken', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  userCidr?: string(name='UserCidr', position='Query'),
}

model CreateVirtualBorderRouterResponseBody = {
  vbrId?: string(name='VbrId'),
  requestId?: string(name='RequestId'),
}

model CreateVirtualBorderRouterResponse = {
  headers: map[string]string(name='headers'),
  body: CreateVirtualBorderRouterResponseBody(name='body'),
}

async function createVirtualBorderRouter(request: CreateVirtualBorderRouterRequest): CreateVirtualBorderRouterResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateVirtualBorderRouter', 'POST', 'undefined', 'json', false, 'none', request);
}

model DescribeStorageCapacityUnitsRequest {
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  tag?: [ 
    {
      key?: string(name='Key', description='SCU的标签键。N表示可以设置多个标签键进行查询，N的取值范围：1~20。'),
      value?: string(name='Value', description='SCU的标签值。N表示可以设置多个标签值进行查询，且与`Tag.N.Key`的N对应，N的取值范围：1~20。'),
    }
  ](name='Tag', position='Query'),
  pageSize?: int32(name='PageSize', description='The number of entries to return on each page.

Maximum Value: 100

Default value: 10', position='Query'),
  pageNumber?: int32(name='PageNumber', description='The page number of the SCU list.

Start value: 1

Default value: 1.', position='Query'),
  name?: string(name='Name', description='The name of the SCU.', position='Query'),
  capacity?: int32(name='Capacity', description='The capacity of the SCU. Unit: GiB. Value range:{20, 40, 100, 200, 500, 1024, 2048, 5120, 10240, 20480, 51200}', position='Query'),
  regionId?: string(name='RegionId', description='The ID of the region to which the SCU belongs. You can call [DescribeRegions](~~ 25609 ~~) to view the latest region list.', position='Query'),
  status?: [ string ](name='Status', description='The status of one or more SCUs. Valid values of N: 1 to 4. Valid values:

-Creating: Creating
-Active: Enabling
-Expired: Expired
-Pending: to take effect', position='Query'),
  storageCapacityUnitId?: [ string ](name='StorageCapacityUnitId', description='One or more SCU ID. Valid values of N: 1 to 100.', position='Query'),
  allocationType?: string(name='AllocationType', description='The allocation type. Valid values:

-Normal: queries the SCUs under the current Alibaba cloud account.
-Shared: queries SCUs that are Shared with RAM users by Alibaba Cloud accounts.

Default value: Normal', position='Query'),
}

model DescribeStorageCapacityUnitsResponseBody = {
  pageSize?: int32(name='PageSize', description='The number of entries to return on each page.'),
  requestId?: string(name='RequestId', description='The ID of the request.'),
  pageNumber?: int32(name='PageNumber', description='The page number of the SCU list.'),
  totalCount?: int32(name='TotalCount', description='The total number of SCUs.'),
  storageCapacityUnits?: {
    storageCapacityUnit?: [ 
    {
      creationTime?: string(name='CreationTime', description='The time when the SCU was created.'),
      status?: string(name='Status', description='The status of the SCU.'),
      startTime?: string(name='StartTime', description='The start time of the SCU.
'),
      capacity?: int32(name='Capacity', description='The capacity of the SCU.'),
      description?: string(name='Description', description='The description of the SCU.'),
      allocationStatus?: string(name='AllocationStatus', description='If the AllocationType value is Shared, this parameter indicates the allocation status of the SCU. Possible values:
-allocated: The SCUs that have been allocated to other users.
-beAllocated: The SCU allocated to other users.'),
      expiredTime?: string(name='ExpiredTime', description='The expiration time of the SCU.'),
      storageCapacityUnitId?: string(name='StorageCapacityUnitId', description='The ID of the SCU.'),
      name?: string(name='Name', description='The name of the SCU.'),
      regionId?: string(name='RegionId', description='The ID of the region to which the SCU belongs.'),
      tags?: {
        tag?: [ 
        {
          tagValue?: string(name='TagValue', description='The tag key of the SCU.'),
          tagKey?: string(name='TagKey', description='The tag value of the SCU.'),
        }
      ](name='Tag')
      }(name='Tags', description='The key-value pair of the SCU tag.'),
    }
  ](name='StorageCapacityUnit')
  }(name='StorageCapacityUnits', description='Returns the details of the SCU in an array of StorageCapacityUnits.'),
}

model DescribeStorageCapacityUnitsResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeStorageCapacityUnitsResponseBody(name='body'),
}

async function describeStorageCapacityUnits(request: DescribeStorageCapacityUnitsRequest): DescribeStorageCapacityUnitsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeStorageCapacityUnits', 'POST', 'undefined', 'json', false, 'none', request);
}

model DescribeInstanceModificationPriceRequest {
  systemDisk?: {
    category?: string(name='Category', description='The system disk type. Parameter values are required only when the instance type is upgraded from a phased-out instance type to an on-sale instance type and the non-I/O optimized instance type is upgraded to an I/O optimized instance type. For more information about instance types, see [instance type families](~~ 25378 ~~) and [phased-out instance types](~~ 55263 ~~).

Valid values:

-cloud_efficiency: Ultra disk
-cloud_ssd:SSD cloud disk

Default value: None', position=''),
  }(name='SystemDisk'),
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  dataDisk?: [ 
    {
      performanceLevel?: string(name='PerformanceLevel', description='当数据盘类型为ESSD云盘时，设置云盘的性能等级。N的取值必须和`DataDisk.N.Category=cloud_essd`中的N保持一致。取值范围：

- PL0：单盘最高随机读写IOPS 1万
- PL1：单盘最高随机读写IOPS 5万
- PL2：单盘最高随机读写IOPS 10万
- PL3：单盘最高随机读写IOPS 100万

默认值：PL1

有关如何选择ESSD性能等级，请参见[ESSD云盘](~~122389~~)。'),
      size?: int32(name='Size', description='数据盘的容量大小。N的取值范围：1~16，内存单位为GiB。取值范围：

- cloud_efficiency：20~32768
- cloud_ssd：20~32768
- cloud_essd：20~32768
- cloud：5~2000

默认值：指定数据盘类型相应的容量大小的最小值。'),
      category?: string(name='Category', description='数据盘类型。当您需要查询ECS实例挂载的新包年包月数据盘的价格时，可以传入该参数值。N的取值范围：1~16。取值范围：

- cloud_efficiency：高效云盘
- cloud_ssd：SSD云盘
- cloud_essd：ESSD云盘
- cloud：普通云盘。

默认值：无

> 查询时，实例规格参数（`InstanceType`）和数据盘参数（`DataDisk.N.*`）不得同时为空，必须至少指定一个。

'),
    }
  ](name='DataDisk', position='Query'),
  instanceId?: string(name='InstanceId', description='The ID of the instance for which you want to query the upgrade price.', position='Query'),
  regionId?: string(name='RegionId', description='The ID of the region. You can call [DescribeRegions](~~ 25609 ~~) to view the latest region list.', position='Query'),
  instanceType?: string(name='InstanceType', description='The specification of the target instance. We recommend that you call [DescribeResourcesModification](~~ 66187 ~~) to query the instance types that can be upgraded in a specified zone.

> you must specify at least one of the instance type parameters ("InstanceType") and data disk parameters ("DataDisk.N.* ").', position='Query'),
}

model DescribeInstanceModificationPriceResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.'),
  priceInfo?: {
    rules?: {
      rule?: [ 
      {
        description?: string(name='Description', description='The description of the activity rule.'),
        ruleId?: long(name='RuleId', description='The ID of the activity.'),
      }
    ](name='Rule')
    }(name='Rules', description='The activity rule.'),
    price?: {
      originalPrice?: float(name='OriginalPrice', description='Original price.'),
      discountPrice?: float(name='DiscountPrice', description='Discount.'),
      currency?: string(name='Currency', description='The unit of currency. Possible values:

-CNY
-USD'),
      tradePrice?: float(name='TradePrice', description='The final price, which is the original price minus the discount.'),
    }(name='Price', description='The price.'),
  }(name='PriceInfo', description='The data type consisting of price information types (PriceInfo), including price and discount rule information.'),
}

model DescribeInstanceModificationPriceResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeInstanceModificationPriceResponseBody(name='body'),
}

/**
 * ## API description

-You can only query the upgrade price of subscription ECS instances that have not expired.

-You cannot query the price of a pay-as-you-go ECS instance when it is changed. Because the price of a pay-as-you-go ECS instance after configuration change is the same as that of a new instance, you can directly call [DescribePrice](~~ 107829 ~~) to query the latest price of the ECS instance.

-Before upgrading an instance, we recommend that you call [DescribeResourcesModification](~~ 66187 ~~) to query the instance types that can be upgraded in a specified zone.

 */
async function describeInstanceModificationPrice(request: DescribeInstanceModificationPriceRequest): DescribeInstanceModificationPriceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeInstanceModificationPrice', 'POST', 'undefined', 'json', false, 'none', request);
}

model ModifyAutoSnapshotPolicyExRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  enableCrossRegionCopy?: boolean(name='EnableCrossRegionCopy', position='Query'),
  targetCopyRegions?: string(name='TargetCopyRegions', position='Query'),
  copiedSnapshotsRetentionDays?: int32(name='CopiedSnapshotsRetentionDays', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', description='The ID of the resource master account, that is, the UID.', position='Query'),
  regionId?: string(name='regionId', description='The region ID of the automatic snapshot policy. You can call [DescribeRegions](~~ 25609 ~~) to view the latest region list.', position='Query'),
  timePoints?: string(name='timePoints', description='The time when the automatic snapshot was created. Use UTC +8. Unit: Hour. Valid values: 0 to 23. Valid values: 00:00 to 23:00. For example, 1 indicates 01:00. When you need to create multiple automatic snapshots in a day, you can specify multiple time points:

-A maximum of 24 time points can be entered.
-Use a format similar to ""0", "1",... A JSON Array of "23" ". Separate time points with commas (,).', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='The account name of the resource master account.', position='Query'),
  ownerId?: long(name='OwnerId', description='The ID of the RAM user.', position='Query'),
  autoSnapshotPolicyId?: string(name='autoSnapshotPolicyId', description='The ID of the target automatic snapshot policy. You can call [DescribeAutoSnapshotPolicyEx](~~ 25530 ~~) to view the available automatic snapshot policies.', position='Query'),
  autoSnapshotPolicyName?: string(name='autoSnapshotPolicyName', description='The name of the automatic snapshot policy. If the parameter is empty, the parameter is not modified.', position='Query'),
  retentionDays?: int32(name='retentionDays', description='The retention period of the automatic snapshot. Unit: days. Valid values:

--1 (default): permanently saved.
-1 to 65536: specify the retention period.', position='Query'),
  repeatWeekdays?: string(name='repeatWeekdays', description='The duplicate date of the automatic snapshot. Unit: Day. Cycle: week. Valid values: 1 to 7. For example, 1 indicates Monday. When you need to create multiple automatic snapshots in a week, you can specify multiple time points:

-A maximum of seven time points can be entered.
-Use a format similar to ""1", "2",... A JSON Array of "7". Separate time points with commas (,).', position='Query'),
}

model ModifyAutoSnapshotPolicyExResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.'),
}

model ModifyAutoSnapshotPolicyExResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyAutoSnapshotPolicyExResponseBody(name='body'),
}

async function modifyAutoSnapshotPolicyEx(request: ModifyAutoSnapshotPolicyExRequest): ModifyAutoSnapshotPolicyExResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyAutoSnapshotPolicyEx', 'POST', 'undefined', 'json', false, 'none', request);
}

model DeleteStorageSetRequest {
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  regionId?: string(name='RegionId', description='The region to which the bucket belongs. You can call [DescribeRegions](~~ 25609 ~~) to view the latest region list.', position='Query'),
  storageSetId?: string(name='StorageSetId', description='The ID of the storage set.', position='Query'),
  clientToken?: string(name='ClientToken', description='Ensure the idempotence of the request. Generate a parameter value from your client. Make sure that the value is unique among different requests. **ClientToken** supports only ASCII characters and cannot exceed 64 characters. For more information, see [how to ensure idempotence](~~ 25693 ~~).', position='Query'),
}

model DeleteStorageSetResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.'),
}

model DeleteStorageSetResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteStorageSetResponseBody(name='body'),
}

async function deleteStorageSet(request: DeleteStorageSetRequest): DeleteStorageSetResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteStorageSet', 'POST', 'undefined', 'json', false, 'none', request);
}

model CreatePhysicalConnectionRequest {
  regionId?: string(name='RegionId', position='Query'),
  accessPointId?: string(name='AccessPointId', position='Query'),
  type?: string(name='Type', position='Query'),
  lineOperator?: string(name='LineOperator', position='Query'),
  bandwidth?: int32(name='bandwidth', position='Query'),
  peerLocation?: string(name='PeerLocation', position='Query'),
  portType?: string(name='PortType', position='Query'),
  redundantPhysicalConnectionId?: string(name='RedundantPhysicalConnectionId', position='Query'),
  description?: string(name='Description', position='Query'),
  name?: string(name='Name', position='Query'),
  circuitCode?: string(name='CircuitCode', position='Query'),
  clientToken?: string(name='ClientToken', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  userCidr?: string(name='UserCidr', position='Query'),
}

model CreatePhysicalConnectionResponseBody = {
  physicalConnectionId?: string(name='PhysicalConnectionId'),
  requestId?: string(name='RequestId'),
}

model CreatePhysicalConnectionResponse = {
  headers: map[string]string(name='headers'),
  body: CreatePhysicalConnectionResponseBody(name='body'),
}

async function createPhysicalConnection(request: CreatePhysicalConnectionRequest): CreatePhysicalConnectionResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreatePhysicalConnection', 'POST', 'undefined', 'json', false, 'none', request);
}

model ModifyUserEventAttributeRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  resourceId?: string(name='ResourceId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  eventId?: string(name='EventId', position='Query'),
  newPlanTime?: string(name='NewPlanTime', position='Query'),
  newExpireTime?: string(name='NewExpireTime', position='Query'),
}

model ModifyUserEventAttributeResponseBody = {
  eventId?: string(name='EventId'),
  requestId?: string(name='RequestId'),
}

model ModifyUserEventAttributeResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyUserEventAttributeResponseBody(name='body'),
}

async function modifyUserEventAttribute(request: ModifyUserEventAttributeRequest): ModifyUserEventAttributeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyUserEventAttribute', 'POST', 'undefined', 'json', false, 'none', request);
}

model AssociateHaVipRequest {
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  clientToken?: string(name='ClientToken', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  haVipId?: string(name='HaVipId', position='Query'),
  instanceId?: string(name='InstanceId', position='Query'),
}

model AssociateHaVipResponseBody = {
  requestId?: string(name='RequestId'),
}

model AssociateHaVipResponse = {
  headers: map[string]string(name='headers'),
  body: AssociateHaVipResponseBody(name='body'),
}

async function associateHaVip(request: AssociateHaVipRequest): AssociateHaVipResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'AssociateHaVip', 'POST', 'undefined', 'json', false, 'none', request);
}

model ModifySecurityGroupPolicyRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', description='The ID of the RAM user.', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', description='The ID of the resource master account, that is, the UID.', position='Query'),
  clientToken?: string(name='ClientToken', description='Ensure the idempotence of the request. Generate a parameter value from your client. Make sure that the value is unique among different requests. **ClientToken** supports only ASCII characters and cannot exceed 64 characters. For more information, see [how to ensure idempotence](~~ 25693 ~~).', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='The account name of the resource master account.', position='Query'),
  regionId?: string(name='RegionId', description='The ID of the region to which the security group belongs. You can call [DescribeRegions](~~ 25609 ~~) to view the latest region list.', position='Query'),
  securityGroupId?: string(name='SecurityGroupId', description='The ID of the security group.', position='Query'),
  innerAccessPolicy?: string(name='InnerAccessPolicy', description='The Intranet connection policy between ECS instances in the security group. Valid values:

-Accept: interconnect
-Drop: Quarantine

The value is case insensitive.', position='Query'),
}

model ModifySecurityGroupPolicyResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.'),
}

model ModifySecurityGroupPolicyResponse = {
  headers: map[string]string(name='headers'),
  body: ModifySecurityGroupPolicyResponseBody(name='body'),
}

/**
 * ## API description

When you call this operation, note that:

-When the value of the InnerAccessPolicy parameter is Accept, the networks of instances in the security group are interconnected. In this case, the Accept priority principle is followed, that is, the networks of instances in the security group remain interconnected and are not affected by user-defined security group rules.

-When the value of the parameter InnerAccessPolicy is Drop, the networks of instances in the security group are isolated. In this case, the user-defined security group rule takes precedence. That is, although the networks of instances in the security group are isolated, you can customize security group rules to change the internal network status. For example, you can use [AuthorizeSecurityGroup](~~ 25554 ~~) to connect two ECS instances in a security group.

-You can use [DescribeSecurityGroupAttribute](~~ 25555 ~~) to query the intranet connection policy of the current security group.
 */
async function modifySecurityGroupPolicy(request: ModifySecurityGroupPolicyRequest): ModifySecurityGroupPolicyResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifySecurityGroupPolicy', 'POST', 'undefined', 'json', false, 'none', request);
}

model ConvertNatPublicIpToEipRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  resourceOwnerId?: long(name='ResourceOwnerId', description='The ID of the resource master account, that is, the UID.', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='The account name of the resource master account.', position='Query'),
  ownerId?: long(name='OwnerId', description='The ID of the RAM user.', position='Query'),
  regionId?: string(name='RegionId', description='The ID of the region to which the instance belongs. You can call [DescribeRegions](~~ 25609 ~~) to view the latest region list.', position='Query'),
  instanceId?: string(name='InstanceId', description='The ID of the instance to be converted to a public IP address.', position='Query'),
}

model ConvertNatPublicIpToEipResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.'),
}

model ConvertNatPublicIpToEipResponse = {
  headers: map[string]string(name='headers'),
  body: ConvertNatPublicIpToEipResponseBody(name='body'),
}

/**
 * ## API description

After the public IP address is converted to an EIP, the EIP is billed separately. Make sure that you have fully understood [the billing method of EIP](~~ 122035 ~~).

When you call this operation, the ECS instance must meet the following requirements:

-The status is **stopped**("Stopped") or **running**("Running").

-No EIP is bound.

-There are no configuration change tasks that have not taken effect.

-The public network bandwidth cannot be 0 Mbit/s.

-Internet bandwidth is billed by traffic.

-Subscription ECS instances of the VPC type do not expire within 24 hours.




 */
async function convertNatPublicIpToEip(request: ConvertNatPublicIpToEipRequest): ConvertNatPublicIpToEipResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ConvertNatPublicIpToEip', 'POST', 'undefined', 'json', false, 'none', request);
}

model DeleteRouteEntryRequest {
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  routeTableId?: string(name='RouteTableId', position='Query'),
  destinationCidrBlock?: string(name='DestinationCidrBlock', position='Query'),
  nextHopId?: string(name='NextHopId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  nextHopList?: [ 
    {
      nextHopId?: string(name='NextHopId'),
      nextHopType?: string(name='NextHopType'),
    }
  ](name='NextHopList', position='Query'),
}

model DeleteRouteEntryResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteRouteEntryResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteRouteEntryResponseBody(name='body'),
}

async function deleteRouteEntry(request: DeleteRouteEntryRequest): DeleteRouteEntryResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteRouteEntry', 'POST', 'undefined', 'json', false, 'none', request);
}

model DeleteVirtualBorderRouterRequest {
  regionId?: string(name='RegionId', position='Query'),
  vbrId?: string(name='VbrId', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  clientToken?: string(name='ClientToken', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  userCidr?: string(name='UserCidr', position='Query'),
}

model DeleteVirtualBorderRouterResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteVirtualBorderRouterResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteVirtualBorderRouterResponseBody(name='body'),
}

async function deleteVirtualBorderRouter(request: DeleteVirtualBorderRouterRequest): DeleteVirtualBorderRouterResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteVirtualBorderRouter', 'POST', 'undefined', 'json', false, 'none', request);
}

model DescribeInstancePhysicalAttributeRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  instanceId?: string(name='InstanceId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
}

model DescribeInstancePhysicalAttributeResponseBody = {
  rackId?: string(name='RackId'),
  instanceId?: string(name='InstanceId'),
  requestId?: string(name='RequestId'),
  nodeControllerId?: string(name='NodeControllerId'),
  vlanId?: string(name='VlanId'),
}

model DescribeInstancePhysicalAttributeResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeInstancePhysicalAttributeResponseBody(name='body'),
}

async function describeInstancePhysicalAttribute(request: DescribeInstancePhysicalAttributeRequest): DescribeInstancePhysicalAttributeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeInstancePhysicalAttribute', 'POST', 'undefined', 'json', false, 'none', request);
}

model TerminatePhysicalConnectionRequest {
  regionId?: string(name='RegionId', position='Query'),
  physicalConnectionId?: string(name='PhysicalConnectionId', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  clientToken?: string(name='ClientToken', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  userCidr?: string(name='UserCidr', position='Query'),
}

model TerminatePhysicalConnectionResponseBody = {
  requestId?: string(name='RequestId'),
}

model TerminatePhysicalConnectionResponse = {
  headers: map[string]string(name='headers'),
  body: TerminatePhysicalConnectionResponseBody(name='body'),
}

async function terminatePhysicalConnection(request: TerminatePhysicalConnectionRequest): TerminatePhysicalConnectionResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'TerminatePhysicalConnection', 'POST', 'undefined', 'json', false, 'none', request);
}

model ValidateSecurityGroupRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  ipProtocol?: string(name='IpProtocol', position='Query'),
  instanceId?: string(name='InstanceId', position='Query'),
  direction?: string(name='Direction', position='Query'),
  sourceIp?: string(name='SourceIp', position='Query'),
  sourcePort?: int32(name='SourcePort', position='Query'),
  destIp?: string(name='DestIp', position='Query'),
  destPort?: int32(name='DestPort', position='Query'),
  nicType?: string(name='NicType', position='Query'),
}

model ValidateSecurityGroupResponseBody = {
  policy?: string(name='Policy'),
  requestId?: string(name='RequestId'),
  triggeredGroupRule?: {
    direction?: string(name='Direction'),
    sourceGroupId?: string(name='SourceGroupId'),
    destGroupOwnerAccount?: string(name='DestGroupOwnerAccount'),
    sourceCidrIp?: string(name='SourceCidrIp'),
    createTime?: string(name='CreateTime'),
    destGroupId?: string(name='DestGroupId'),
    ipProtocol?: string(name='IpProtocol'),
    destCidrIp?: string(name='DestCidrIp'),
    priority?: string(name='Priority'),
    destGroupName?: string(name='DestGroupName'),
    nicType?: string(name='NicType'),
    policy?: string(name='Policy'),
    description?: string(name='Description'),
    portRange?: string(name='PortRange'),
    sourceGroupOwnerAccount?: string(name='SourceGroupOwnerAccount'),
    sourceGroupName?: string(name='SourceGroupName'),
  }(name='TriggeredGroupRule'),
}

model ValidateSecurityGroupResponse = {
  headers: map[string]string(name='headers'),
  body: ValidateSecurityGroupResponseBody(name='body'),
}

async function validateSecurityGroup(request: ValidateSecurityGroupRequest): ValidateSecurityGroupResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ValidateSecurityGroup', 'POST', 'undefined', 'json', false, 'none', request);
}

model ModifySnapshotGroupRequest {
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  name?: string(name='Name', description='The name of the modified snapshot. The description must be 2 to 128 characters in length. It must start with a letter and cannot start with "http:// "or "https://". It can contain numbers and periods (.)., underscores (_), hyphens (-), or colons (:).', position='Query'),
  regionId?: string(name='RegionId', description='The ID of the region to which the instance snapshot belongs. You can call [DescribeRegions](~~ 25609 ~~) to view the latest region list.', position='Query'),
  description?: string(name='Description', description='The modified description. The description must be 2 to 256 characters in length and cannot start with "http:// "or "https.', position='Query'),
  snapshotGroupId?: string(name='SnapshotGroupId', description='The ID of the instance snapshot.', position='Query'),
}

model ModifySnapshotGroupResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.'),
}

model ModifySnapshotGroupResponse = {
  headers: map[string]string(name='headers'),
  body: ModifySnapshotGroupResponseBody(name='body'),
}

async function modifySnapshotGroup(request: ModifySnapshotGroupRequest): ModifySnapshotGroupResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifySnapshotGroup', 'POST', 'undefined', 'json', false, 'none', request);
}

model CreateImagePipelineRequest {
  tag?: [ 
    {
      key?: string(name='Key', description='标签键。N的取值范围：1~20。一旦传入该值，则不允许为空字符串。最多支持128个字符，不能以`aliyun`和`acs:`开头，不能包含`http://`或者`https://`。'),
      value?: string(name='Value', description='标签值。N的取值范围：1~20。一旦传入该值，可以为空字符串。最多支持128个字符，不能以`acs:`开头，不能包含`http://`或者`https://`。'),
    }
  ](name='Tag', position='Query'),
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  resourceGroupId?: string(name='ResourceGroupId', position='Query'),
  addAccount?: [ long ](name='AddAccount', position='Query'),
  toRegionId?: [ string ](name='ToRegionId', position='Query'),
  description?: string(name='Description', description='The description. The description must be 2 to 256 characters in length and cannot start with "http:// "or "https.', position='Query'),
  baseImageType?: string(name='BaseImageType', description='The type of the source image. Valid values:

-IMAGE: IMAGE.
-IMAGE_FAMILY: The Image family is.', position='Query'),
  deleteInstanceOnFailure?: boolean(name='DeleteInstanceOnFailure', description='Specifies whether to release the intermediate instance after the image fails to be built. Valid values:

-true: Release
-false: do not release

Default value: true

> If the intermediate instance is not started, the instance is not retained by default.

', position='Query'),
  clientToken?: string(name='ClientToken', description='Ensure the idempotence of the request. Generate a parameter value from your client. Make sure that the value is unique among different requests. **ClientToken** supports only ASCII characters and cannot exceed 64 characters. For more information, see [how to ensure idempotence](~~ 25693 ~~).', position='Query'),
  name?: string(name='Name', description='The name of the template. The description must be 2 to 128 characters in length. It must start with a letter and cannot start with "http://" or "https. It can contain letters, digits, colons (:), underscores (_), periods (.), and hyphens (-).

> If "Name" is not set, "ImagePipelineId" is returned by default.', position='Query'),
  vSwitchId?: string(name='VSwitchId', description='The vSwitch ID of the VPC.

If you do not set the parameter value, new VPCs and vswitches are created by default. Make sure that the VPC resource quota under your account is sufficient. For more information, see [limits](~~ 27750 ~~).', position='Query'),
  imageName?: string(name='ImageName', description='The prefix of the target image name. The description must be 2 to 64 characters in length. It must start with a letter and cannot start with "http://" or "https. It can contain letters, digits, colons (:), underscores (_), periods (.), and hyphens (-).

The complete image name is automatically concatenated with the prefix of the name and the ID of the build task ("ExecutionId"). The format is "{ ImageName }_{ ExecutionId}".

', position='Query'),
  systemDiskSize?: int32(name='SystemDiskSize', description='The system disk size of the intermediate instance. Unit: GiB. Valid values: 20 to 500.

Default value: 40', position='Query'),
  internetMaxBandwidthOut?: int32(name='InternetMaxBandwidthOut', description='The Internet outbound bandwidth of the intermediate instance. Unit: Mbit/s. Valid values: 0 to 100.

Default value: 0.', position='Query'),
  buildContent?: string(name='BuildContent', description='The content of the image template. The content size cannot exceed 16KB. A maximum of 127 commands are supported. For more information about supported commands, see API description.', position='Query'),
  instanceType?: string(name='InstanceType', description='The instance type. You can call [DescribeInstanceTypes](~~ 25620 ~~) to query different instance types.

If you do not set the parameter value, the instance type is automatically set based on the principle of minimum vCPU and memory, and is affected by the instance type inventory. For example, the ecs.g6.large instance type is selected by default. If the inventory is insufficient, the ecs.g6.xlarge instance type is selected.', position='Query'),
  baseImage?: string(name='BaseImage', description='The source image.
-When "BaseImageType = IMAGE", this parameter is set to the image ID.
-When "BaseImageType = IMAGE_FAMILY ", this parameter is set to the name of the Image family.', position='Query'),
}

model CreateImagePipelineResponseBody = {
  imagePipelineId?: string(name='ImagePipelineId', description='The ID of the image template.'),
  requestId?: string(name='RequestId', description='The ID of the request.'),
}

model CreateImagePipelineResponse = {
  headers: map[string]string(name='headers'),
  body: CreateImagePipelineResponseBody(name='body'),
}

/**
 * ## API description

You can customize the image content by using an image template and build images across regions and accounts. Before creating an image template, note the following:

-You can only create custom image templates.
-You can only set public images, custom images, shared images, or image families for Linux.
-To build an image by using an image template, you need to create an intermediate instance to assist in building the image. The intermediate instance is a pay-as-you-go ECS instance, which charges a certain fee. For more information, see [pay-as-you-go](~~ 40653 ~~).

For the build template content "BuildContent", note the following:
-If the "FROM" command is set for the "BuildContent" parameter, the values of the source image "BaseImageType" and the source image "BaseImage" are overwritten by the "FROM" command.
-If the "FROM" command is not set for the "BuildContent" parameter, the system automatically adds the "FROM" command consisting of the source image type "BaseImageType" and the source image "BaseImage" to the first line of the template content, the format is "<BaseImageType >:< BaseImage>".
-You can edit the content of an image template through the Dockerfile and pass the content to the "BuildContent" parameter. The content size cannot exceed 16KB. A maximum of 127 commands are supported. For more information about supported commands, see [commands supported by image building service](~~ 200206 ~~).

You cannot use an API to create an image template. This feature is only supported by console operations. For more information, see [image building Overview](~~ 197410 ~~).

 */
async function createImagePipeline(request: CreateImagePipelineRequest): CreateImagePipelineResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateImagePipeline', 'POST', 'undefined', 'json', false, 'none', request);
}

model ModifyImageSharePermissionRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  launchPermission?: string(name='LaunchPermission', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='The account name of the resource master account.', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', description='The ID of the resource master account, that is, the UID.', position='Query'),
  ownerId?: long(name='OwnerId', description='The ID of the RAM user.', position='Query'),
  removeAccount?: [ string ](name='RemoveAccount', description='The ID of the Alibaba Cloud account that deletes image sharing. Valid values of N: 1 to 10. If the value exceeds 10, the system ignores this parameter.', position='Query'),
  imageId?: string(name='ImageId', description='The ID of the shared custom image.', position='Query'),
  regionId?: string(name='RegionId', description='The ID of the region to which the custom image belongs. You can call [DescribeRegions](~~ 25609 ~~) to view the latest region list.', position='Query'),
  addAccount?: [ string ](name='AddAccount', description='The ID of the Alibaba Cloud account that is authorized to share images. Valid values of N: 1 to 10. If the value exceeds 10, the system ignores this parameter.', position='Query'),
}

model ModifyImageSharePermissionResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.'),
}

model ModifyImageSharePermissionResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyImageSharePermissionResponseBody(name='body'),
}

/**
 * ## API description

When you call this operation, note that:

-You can only share your custom images with other Alibaba Cloud users.

-Each custom image can be shared with up to 10 Alibaba cloud accounts at a time. Therefore, you can specify a maximum of 10 Alibaba cloud accounts at a time for the parameter AddAccount.n or RemoveAccount.n. The system ignores this parameter if it exceeds 10 accounts.

-<props = "china"> each custom image can be shared with up to 50 Alibaba cloud accounts. You can [submit a ticket](https://selfservice.console.aliyun.com/ticket/createIndex.htm) to apply for sharing with more users. </props>

-<props = "intl"> each custom image can be shared with up to 50 Alibaba cloud accounts. You can [submit a ticket](https://workorder-intl.console.aliyun.com/#/ticket/createIndex)</props> to apply for sharing with more users. </props>

-After an ECS instance ([RunInstances](~~ 63440 ~~) is created from a shared image, once the custom image owner disables the image sharing relationship, or delete the custom image ([DeleteImage](~~ 25537 ~~), the instance cannot initialize the system disk ([ReInitDisk](~~ 25519 ~~)).
 */
async function modifyImageSharePermission(request: ModifyImageSharePermissionRequest): ModifyImageSharePermissionResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyImageSharePermission', 'POST', 'undefined', 'json', false, 'none', request);
}

model DescribePrefixListsRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  regionId?: string(name='RegionId', description='The ID of the region.', position='Query'),
  nextToken?: string(name='NextToken', description='Query the credential (Token). The value is the value of the "NextToken" parameter returned by the last call to the API. You do not need to set this parameter when you call the API for the first time.', position='Query'),
  addressFamily?: string(name='AddressFamily', description='The address family of the prefix list. Valid values:

-IPv4
-IPv6

Default value: NULL. All prefixes are queried.', position='Query'),
  prefixListName?: string(name='PrefixListName', description='The name of the prefix list.', position='Query'),
  maxResults?: int32(name='MaxResults', description='The number of entries to return on each page.

Maximum Value: 100

Default value: 10', position='Query'),
  prefixListId?: [ string ](name='PrefixListId', description='The ID of the prefix list. Valid values of N: 0 to 100.', position='Query'),
}

model DescribePrefixListsResponseBody = {
  nextToken?: string(name='NextToken', description='The Token returned by this call. If the returned value is null, no more data is returned.'),
  requestId?: string(name='RequestId', description='The ID of the request.'),
  prefixLists?: {
    prefixList?: [ 
    {
      creationTime?: string(name='CreationTime', description='The time when the prefix list was created.'),
      associationCount?: int32(name='AssociationCount', description='The number of associated resources.'),
      maxEntries?: int32(name='MaxEntries', description='The maximum number of entries supported by the prefix list.'),
      description?: string(name='Description', description='The description of the prefix list.'),
      addressFamily?: string(name='AddressFamily', description='The address family of the prefix list. Possible values:

-IPv4
-IPv6'),
      prefixListName?: string(name='PrefixListName', description='The name of the prefix list.'),
      prefixListId?: string(name='PrefixListId', description='The ID of the prefix list.'),
    }
  ](name='PrefixList')
  }(name='PrefixLists', description='An array of prefix information.'),
}

model DescribePrefixListsResponse = {
  headers: map[string]string(name='headers'),
  body: DescribePrefixListsResponseBody(name='body'),
}

/**
 * ## API description

The request parameters "addressfamile", "PrefixListId. ", AND "PrefixListName" are similar to filters AND are logical AND (AND) relationships. If a parameter is empty, the filter does not work.
 */
async function describePrefixLists(request: DescribePrefixListsRequest): DescribePrefixListsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribePrefixLists', 'POST', 'undefined', 'json', false, 'none', request);
}

model DeleteLaunchTemplateVersionRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', description='The ID of the RAM user.', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='The account name of the resource master account.', position='Query'),
  regionId?: string(name='RegionId', description='The ID of the region to which the template belongs. You can call [DescribeRegions](~~ 25609 ~~) to view the latest region list.', position='Query'),
  deleteVersion?: [ long ](name='DeleteVersion', description='The version number of the template. Valid values of n: 1 to 29. You can call [DescribeLaunchTemplateVersions](~~ 73761 ~~) to query the launch template version list.', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', description='The ID of the resource master account, that is, the UID.', position='Query'),
  launchTemplateId?: string(name='LaunchTemplateId', description='The ID of the launch template to be deleted. For more information, call [DescribeLaunchTemplates](~~ 73759 ~~).', position='Query'),
  launchTemplateName?: string(name='LaunchTemplateName', description='The name of the launch template.', position='Query'),
}

model DeleteLaunchTemplateVersionResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.'),
}

model DeleteLaunchTemplateVersionResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteLaunchTemplateVersionResponseBody(name='body'),
}

async function deleteLaunchTemplateVersion(request: DeleteLaunchTemplateVersionRequest): DeleteLaunchTemplateVersionResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteLaunchTemplateVersion', 'POST', 'undefined', 'json', false, 'none', request);
}

model CreateUserEventRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  resourceId?: string(name='ResourceId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  eventType?: string(name='EventType', position='Query'),
  planTime?: string(name='PlanTime', position='Query'),
  expireTime?: string(name='ExpireTime', position='Query'),
}

model CreateUserEventResponseBody = {
  eventId?: string(name='EventId'),
  requestId?: string(name='RequestId'),
}

model CreateUserEventResponse = {
  headers: map[string]string(name='headers'),
  body: CreateUserEventResponseBody(name='body'),
}

async function createUserEvent(request: CreateUserEventRequest): CreateUserEventResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateUserEvent', 'POST', 'undefined', 'json', false, 'none', request);
}

model DescribePhysicalConnectionsRequest {
  regionId?: string(name='RegionId', position='Query'),
  pageNumber?: int32(name='PageNumber', position='Query'),
  pageSize?: int32(name='PageSize', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  clientToken?: string(name='ClientToken', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  userCidr?: string(name='UserCidr', position='Query'),
  filter?: [ 
    {
      key?: string(name='Key'),
      value?: [ string ](name='Value'),
    }
  ](name='Filter', position='Query'),
}

model DescribePhysicalConnectionsResponseBody = {
  requestId?: string(name='RequestId'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  totalCount?: int32(name='TotalCount'),
  physicalConnectionSet?: {
    physicalConnectionType?: [ 
    {
      adLocation?: string(name='AdLocation'),
      creationTime?: string(name='CreationTime'),
      status?: string(name='Status'),
      type?: string(name='Type'),
      portNumber?: string(name='PortNumber'),
      circuitCode?: string(name='CircuitCode'),
      spec?: string(name='Spec'),
      bandwidth?: long(name='Bandwidth'),
      description?: string(name='Description'),
      portType?: string(name='PortType'),
      enabledTime?: string(name='EnabledTime'),
      businessStatus?: string(name='BusinessStatus'),
      lineOperator?: string(name='LineOperator'),
      name?: string(name='Name'),
      redundantPhysicalConnectionId?: string(name='RedundantPhysicalConnectionId'),
      peerLocation?: string(name='PeerLocation'),
      accessPointId?: string(name='AccessPointId'),
      physicalConnectionId?: string(name='PhysicalConnectionId'),
    }
  ](name='PhysicalConnectionType')
  }(name='PhysicalConnectionSet'),
}

model DescribePhysicalConnectionsResponse = {
  headers: map[string]string(name='headers'),
  body: DescribePhysicalConnectionsResponseBody(name='body'),
}

async function describePhysicalConnections(request: DescribePhysicalConnectionsRequest): DescribePhysicalConnectionsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribePhysicalConnections', 'POST', 'undefined', 'json', false, 'none', request);
}

model ImportSnapshotRequest {
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  snapshotName?: string(name='SnapshotName', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  ossBucket?: string(name='OssBucket', position='Query'),
  ossObject?: string(name='OssObject', position='Query'),
  roleName?: string(name='RoleName', position='Query'),
}

model ImportSnapshotResponseBody = {
  requestId?: string(name='RequestId'),
  taskId?: string(name='TaskId'),
  snapshotId?: string(name='SnapshotId'),
}

model ImportSnapshotResponse = {
  headers: map[string]string(name='headers'),
  body: ImportSnapshotResponseBody(name='body'),
}

async function importSnapshot(request: ImportSnapshotRequest): ImportSnapshotResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ImportSnapshot', 'POST', 'undefined', 'json', false, 'none', request);
}

model DescribeRecycleBinRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  resourceId?: string(name='ResourceId', position='Query'),
  status?: string(name='Status', position='Query'),
  pageNumber?: int32(name='PageNumber', position='Query'),
  pageSize?: int32(name='PageSize', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
}

model DescribeRecycleBinResponseBody = {
  totalCount?: int32(name='TotalCount'),
  requestId?: string(name='RequestId'),
  recycleBinModels?: {
    recycleBinModel?: [ 
    {
      status?: string(name='Status'),
      creationTime?: string(name='CreationTime'),
      resourceType?: string(name='ResourceType'),
      resourceId?: string(name='ResourceId'),
      regionId?: string(name='RegionId'),
      relationResources?: {
        relationResource?: [ 
        {
          relationResourceType?: string(name='RelationResourceType'),
          relationResourceId?: string(name='RelationResourceId'),
        }
      ](name='relationResource')
      }(name='RelationResources'),
    }
  ](name='RecycleBinModel')
  }(name='RecycleBinModels'),
}

model DescribeRecycleBinResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeRecycleBinResponseBody(name='body'),
}

async function describeRecycleBin(request: DescribeRecycleBinRequest): DescribeRecycleBinResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeRecycleBin', 'POST', 'undefined', 'json', false, 'none', request);
}

model DetachVolumeRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  instanceId?: string(name='InstanceId', position='Query'),
  volumeId?: string(name='VolumeId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
}

model DetachVolumeResponseBody = {
  requestId?: string(name='RequestId'),
}

model DetachVolumeResponse = {
  headers: map[string]string(name='headers'),
  body: DetachVolumeResponseBody(name='body'),
}

async function detachVolume(request: DetachVolumeRequest): DetachVolumeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DetachVolume', 'POST', 'undefined', 'json', false, 'none', request);
}

model CreateNetworkInterfaceRequest {
  tag?: [ 
    {
      key?: string(name='Key', description='弹性网卡的标签键。N的取值范围：1~20。一旦传入该值，则不允许为空字符串。最多支持128个字符，不能以aliyun和acs:开头，不能包含`http://`或者`https://`。'),
      value?: string(name='Value', description='弹性网卡的标签值。N的取值范围：1~20。一旦传入该值，可以为空字符串。最多支持128个字符，不能以acs:开头，不能包含`http://`或者`https://`。'),
    }
  ](name='Tag', position='Query'),
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  visible?: boolean(name='Visible', position='Query'),
  instanceType?: string(name='InstanceType', position='Query'),
  businessType?: string(name='BusinessType', position='Query'),
  networkInterfaceTrafficMode?: string(name='NetworkInterfaceTrafficMode', position='Query'),
  queuePairNumber?: int32(name='QueuePairNumber', position='Query'),
  regionId?: string(name='RegionId', description='The ID of the region where the instance is located. You can call [DescribeRegions](~~ 25609 ~~) to view the latest region list.', position='Query'),
  clientToken?: string(name='ClientToken', description='Ensure the idempotence of the request. Generate a parameter value from your client. Make sure that the value is unique among different requests. **ClientToken** supports only ASCII characters and cannot exceed 64 characters. For more information, see [how to ensure idempotence](~~ 25693 ~~).', position='Query'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group. You can call [ListResourceGroups](~~ 158855 ~~) to query resource group information.', position='Query'),
  primaryIpAddress?: string(name='PrimaryIpAddress', description='The primary private IP address of the Eni.

The specified IP address must be an idle address in the CIDR block of the vSwitch. If you do not specify the IP address, the idle address in the vSwitch is randomly allocated by default.', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='The account name of the resource master account.', position='Query'),
  ipv6Address?: [ string ](name='Ipv6Address', description='Specify one or more IPv6 addresses for the Eni. You can set up to 10 IPv6 addresses. Valid values of N: 1 to 10.

Valid values: Ipv6Address.1=2001:db8:1234:1 a00::****

> If you want to set an IPv6 address for an Eni, you must set either of "Ipv6Addresses.... or "Ipv6AddressCount", but you cannot set both parameters at the same time.', position='Query'),
  vSwitchId?: string(name='VSwitchId', description='The ID of the vSwitch. The private IP address of the Eni is an idle IP address in the CIDR block of the vSwitch.', position='Query'),
  securityGroupIds?: [ string ](name='SecurityGroupIds', description='Join one or more security groups. The security group and the Eni must be in the same VPC. The value range of N depends on the number of security groups that Enis can join. For more information, see [limits](~~ 25412 ~~).

> when calling an API, you must set either the "SecurityGroupId" or "SecurityGroupIds.... Parameter. However, you cannot set this parameter at the same time.', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', description='The ID of the resource master account, that is, the UID.', position='Query'),
  ownerId?: long(name='OwnerId', description='The ID of the RAM user.', position='Query'),
  secondaryPrivateIpAddressCount?: int32(name='SecondaryPrivateIpAddressCount', description='Specify the number of private IP addresses to allow ECS to automatically create IP addresses for you.', position='Query'),
  securityGroupId?: string(name='SecurityGroupId', description='Join a security group. The security group and the Eni must be in the same VPC.

> when calling an API, you must set either the "SecurityGroupId" or "SecurityGroupIds.... Parameter. However, you cannot set this parameter at the same time.', position='Query'),
  ipv6AddressCount?: int32(name='Ipv6AddressCount', description='Specify the number of randomly generated IPv6 addresses for the Eni. Valid values: 1 to 10.

> If you want to set an IPv6 address for an Eni, you must set either of "Ipv6Addresses.... or "Ipv6AddressCount", but you cannot set both parameters at the same time.', position='Query'),
  description?: string(name='Description', description='The description of the Eni. The description must be 2 to 256 characters in length and cannot start with "http:// "or "https.

Default value: Null.', position='Query'),
  privateIpAddress?: [ string ](name='PrivateIpAddress', description='Select one or more secondary private IP addresses from the idle addresses in the CIDR block of the vSwitch to which the Eni belongs. Valid values of N: 0 to 10.

> when assigning a secondary private IP address, you cannot specify both the "PrivateIpAddress. "and the "SecondaryPrivateIpAddressCount" parameters".', position='Query'),
  networkInterfaceName?: string(name='NetworkInterfaceName', description='The name of the Eni. The description must be 2 to 128 characters in length. It must start with a letter and cannot start with "http:// "or "https. It can contain numbers, colons (:), underscores (_), and hyphens (-).

Default value: Null.', position='Query'),
  queueNumber?: int32(name='QueueNumber', description='The number of Eni queues. Valid values: 1 to 2048.

When you associate an Eni with an Eni, the value must be less than the maximum number of queues that the instance type supports a single Eni. You can call the [DescribeInstanceTypes](~~ 25620 ~~) operation to query the maximum number of queues for a single NIC.

Default value: Null. The default number of Enis queues of the instance type is used for binding. You can call the [DescribeInstanceTypes](~~ 25620 ~~) operation to query the "secondaryeniqueuenumerber" field.
', position='Query'),
}

model CreateNetworkInterfaceResponseBody = {
  status?: string(name='Status', description='The status of the Eni.'),
  type?: string(name='Type', description='The type of the Eni.'),
  vpcId?: string(name='VpcId', description='The VPC ID of the VPC to which the Eni belongs.'),
  networkInterfaceName?: string(name='NetworkInterfaceName', description='The name of the Eni.'),
  macAddress?: string(name='MacAddress', description='The MAC address of the Eni.'),
  networkInterfaceId?: string(name='NetworkInterfaceId', description='The ID of the Eni.'),
  serviceID?: long(name='ServiceID', description='The ID of the virtual merchant corresponding to the Eni.'),
  ownerId?: string(name='OwnerId', description='The ID of the account to which the Eni belongs.'),
  serviceManaged?: boolean(name='ServiceManaged', description='Whether the user of the Eni is a cloud product or a virtual merchant.'),
  vSwitchId?: string(name='VSwitchId', description='The vSwitch ID of the VPC.'),
  requestId?: string(name='RequestId', description='The ID of the request.'),
  description?: string(name='Description', description='The description of the Eni.'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group.'),
  zoneId?: string(name='ZoneId', description='The ID of the zone.'),
  privateIpAddress?: string(name='PrivateIpAddress', description='The private IP address of the Eni.'),
  securityGroupIds?: {
    securityGroupId?: [ string ](name='SecurityGroupId')
  }(name='SecurityGroupIds'),
  privateIpSets?: {
    privateIpSet?: [ 
    {
      privateIpAddress?: string(name='PrivateIpAddress', description='The private IP address of the instance.'),
      primary?: boolean(name='Primary', description='Indicates whether the private IP address is the primary IP address.'),
    }
  ](name='PrivateIpSet')
  }(name='PrivateIpSets', description='A collection of PrivateIpSet.'),
  tags?: {
    tag?: [ 
    {
      tagKey?: string(name='TagKey', description='The key of the tag.'),
      tagValue?: string(name='TagValue', description='The value of the tag.'),
    }
  ](name='Tag')
  }(name='Tags', description='The tag.'),
  ipv6Sets?: {
    ipv6Set?: [ 
    {
      ipv6Address?: string(name='Ipv6Address', description='The IPv6 address.'),
    }
  ](name='Ipv6Set')
  }(name='Ipv6Sets', description='The IPv6 address assigned to the Eni.'),
}

model CreateNetworkInterfaceResponse = {
  headers: map[string]string(name='headers'),
  body: CreateNetworkInterfaceResponseBody(name='body'),
}

/**
 * ## API description

<props="china">
-The newly created Eni is in the Available (Available) state.

-Enis can only be attached to VPC instances in the same zone.

-An Eni can be attached to only one instance. You must detach a new instance from the current instance before attaching it to the new instance.

-When the Eni is reattached to another instance, its properties remain unchanged and network traffic is redirected to the new instance.

-If you need to set an IPv6 address when creating an Eni, make sure that IPv6 is enabled for the specified vSwitch. For more information, see [what is IPv6 gateway](~~ 98896 ~~).

-By default, an account can create up to 100 Enis in an Alibaba Cloud region. For more information, open a ticket (https://selfservice.console.aliyun.com/ticket/createIndex.htm).

</props>

<props="intl">
-The newly created Eni is in the Available (Available) state.

-Enis can only be attached to VPC instances in the same zone.

-An Eni can be attached to only one instance. You must detach a new instance from the current instance before attaching it to the new instance.

-When the Eni is reattached to another instance, its properties remain unchanged and network traffic is redirected to the new instance.

-If you need to set an IPv6 address when creating an Eni, make sure that IPv6 is enabled for the specified vSwitch. For more information, see [what is IPv6 gateway](~~ 98896 ~~).

-By default, an account can create up to 100 Enis in an Alibaba Cloud region. For more information, open a ticket (https://workorder-intl.console.aliyun.com/#/ticket/createIndex).

</props>

<props="partner">
-The newly created Eni is in the Available (Available) state.

-Enis can only be attached to VPC instances in the same zone.

-An Eni can be attached to only one instance. You must detach a new instance from the current instance before attaching it to the new instance.

-When the Eni is reattached to another instance, its properties remain unchanged and network traffic is redirected to the new instance.

-If you need to set an IPv6 address when creating an Eni, make sure that IPv6 is enabled for the specified vSwitch. For more information, see [what is IPv6 gateway](~~ 98896 ~~).

-By default, an account can create up to 100 Enis in an Alibaba Cloud region. For more information, open a ticket.

</props>
 */
async function createNetworkInterface(request: CreateNetworkInterfaceRequest): CreateNetworkInterfaceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateNetworkInterface', 'POST', 'undefined', 'json', false, 'none', request);
}

model DescribeIpRangesRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  clusterId?: string(name='ClusterId', position='Query'),
  nicType?: string(name='NicType', position='Query'),
  pageNumber?: int32(name='PageNumber', position='Query'),
  pageSize?: int32(name='PageSize', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
}

model DescribeIpRangesResponseBody = {
  requestId?: string(name='RequestId'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  totalCount?: int32(name='TotalCount'),
  regionId?: string(name='RegionId'),
  clusterId?: string(name='ClusterId'),
  ipRanges?: {
    ipRange?: [ 
    {
      nicType?: string(name='NicType'),
      ipAddress?: string(name='IpAddress'),
    }
  ](name='IpRange')
  }(name='IpRanges'),
}

model DescribeIpRangesResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeIpRangesResponseBody(name='body'),
}

async function describeIpRanges(request: DescribeIpRangesRequest): DescribeIpRangesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeIpRanges', 'POST', 'undefined', 'json', false, 'none', request);
}

model ResetDisksRequest {
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  disk?: [ 
    {
      snapshotId?: string(name='SnapshotId', description='实例快照中，指定云盘对应的快照ID。N的取值范围：1~10'),
      diskId?: string(name='DiskId', description='指定待回滚的云盘ID。N的取值范围：1~10'),
    }
  ](name='Disk', position='Query'),
  regionId?: string(name='RegionId', description='The ID of the region. You can call [DescribeRegions](~~ 25609 ~~) to view the latest region list.', position='Query'),
}

model ResetDisksResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.'),
  operationProgressSet?: {
    operationProgress?: [ 
    {
      errorMsg?: string(name='ErrorMsg', description='The error message. If the rollback succeeds, a null value is returned.

<props = "intl"> for error codes and error messages, see [error Center](https://error-center.alibabacloud.com/status/product/Ecs). </props>

<props = "china"> for error codes and error messages, see [error Center](https://error-center.aliyun.com/status/product/Ecs). </props>
'),
      errorCode?: string(name='ErrorCode', description='The error code. If the rollback succeeds, a null value is returned.


<props = "intl"> for error codes and error messages, see [error Center](https://error-center.alibabacloud.com/status/product/Ecs). </props>

<props = "china"> for error codes and error messages, see [error Center](https://error-center.aliyun.com/status/product/Ecs). </props>
'),
      operationStatus?: string(name='OperationStatus', description='Indicates whether the operation is successful.
Success is returned if the request succeeds. ErrorCode and ErrorMsg are returned if the request fails.'),
      relatedItemSet?: {
        relatedItem?: [ 
        {
          name?: string(name='Name', description='The name of the resource.'),
          value?: string(name='Value', description='The ID of the resource.'),
        }
      ](name='RelatedItem')
      }(name='RelatedItemSet', description='The resource information.'),
    }
  ](name='OperationProgress')
  }(name='OperationProgressSet', description='A collection of Operation status information when one or more cloud disks are rolled back.'),
}

model ResetDisksResponse = {
  headers: map[string]string(name='headers'),
  body: ResetDisksResponseBody(name='body'),
}

/**
 * ## API description

Before you call this operation to roll back a disk, make sure that you need to pay attention to the rollback function. For more information, see [roll back Cloud disks from instance snapshots](~~ 209160 ~~).
 */
async function resetDisks(request: ResetDisksRequest): ResetDisksResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ResetDisks', 'POST', 'undefined', 'json', false, 'none', request);
}

model ModifyPrefixListRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  addEntry?: [ 
    {
      description?: string(name='Description', description='前缀列表条目的描述信息。长度为2~32个英文或中文字符，不能以`http://`和`https://`开头。N的取值范围：0~200。'),
      cidr?: string(name='Cidr', description='添加的前缀列表条目的CIDR地址块信息。N的取值范围：0~200。

添加时请您注意：
- 前缀列表的条目数量，不能大于前缀列表支持的最大条目容量。您可以调用[DescribePrefixListAttributes](~~205872~~)查询指定前缀列表的最大条目容量信息。
- 不允许设置重复的CIDR地址块信息。
- 不允许与`RemoveEntry.N.Cidr`参数值重复。'),
    }
  ](name='AddEntry', position='Query'),
  removeEntry?: [ 
    {
      cidr?: string(name='Cidr', description='删除的前缀列表条目的CIDR地址块信息。N的取值范围：0~200。

删除时请您注意：
- 不允许设置重复的CIDR地址块信息。
- 不允许与`AddEntry.N.Cidr`参数值重复。'),
    }
  ](name='RemoveEntry', position='Query'),
  prefixListId?: string(name='PrefixListId', description='The ID of the prefix list.', position='Query'),
  regionId?: string(name='RegionId', description='The ID of the region.
', position='Query'),
  description?: string(name='Description', description='The description of the prefix list. The description must be 2 to 256 characters in length and cannot start with "http:// "or "https.', position='Query'),
  prefixListName?: string(name='PrefixListName', description='The name of the prefix list. The description must be 2 to 128 characters in length. It must start with a letter and cannot start with "http:// ", "https://", "com.aliyun", or "com.alibabacloud. It can contain letters, digits, colons (:), underscores (_), periods (.), and hyphens (-).', position='Query'),
}

model ModifyPrefixListResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.'),
}

model ModifyPrefixListResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyPrefixListResponseBody(name='body'),
}

/**
 * ## API description

<props="china">
-The specified CIDR block must be in standard format. For example, 10.0.0.0/8 indicates the correct CIDR block, while 10.0.0.1/8 indicates the incorrect CIDR block. For more information, see [what is CIDR](https://help.aliyun.com/knowledge_detail/40637.html#section-jua-0tj-q5m).

-Do not specify duplicate CIDR blocks when adding or deleting entries. Example:
-For IPv4 CIDR block: you cannot specify entries with both CIDR blocks 10.0.0.0/8 at the same time. You cannot specify entries with both CIDR blocks 10.0.0.1/32 and 10.0.0.1 at the same time, the two address blocks are the same.
-IPv6 CIDR block: you cannot specify two CIDR blocks at the same time: 2001:fd01:0:0:0:0:0:0/32 and 2001:fd01::/32. The two address blocks are the same.

-The CIDR block of the new entry cannot overlap with the CIDR block of the deleted entry. For example, when you add an entry whose CIDR block is 10.0.0.0/8, you cannot include the CIDR block 10.0.0.0/8 in the entry to be deleted.

-To modify the description of the entry, you must specify the CIDR block ("AddEntry.N.Cidr") and the new description ("AddEntry.N.Description").

</props>


<props="intl">
-The specified CIDR block must be in standard format. For example, 10.0.0.0/8 indicates the correct CIDR block, while 10.0.0.1/8 indicates the incorrect CIDR block. For more information, see [what is CIDR](https://www.alibabacloud.com/help/doc-detail/40637.htm#section-jua-0tj-q5m).

-Do not specify duplicate CIDR blocks when adding or deleting entries. Example:
-For IPv4 CIDR block: you cannot specify entries with both CIDR blocks 10.0.0.0/8 at the same time. You cannot specify entries with both CIDR blocks 10.0.0.1/32 and 10.0.0.1 at the same time, the two address blocks are the same.
-IPv6 CIDR block: you cannot specify two CIDR blocks at the same time: 2001:fd01:0:0:0:0:0:0/32 and 2001:fd01::/32. The two address blocks are the same.

-The CIDR block of the new entry cannot overlap with the CIDR block of the deleted entry. For example, when you add an entry whose CIDR block is 10.0.0.0/8, you cannot include the CIDR block 10.0.0.0/8 in the entry to be deleted.

-To modify the description of the entry, you must specify the CIDR block ("AddEntry.N.Cidr") and the new description ("AddEntry.N.Description").

</props>

 */
async function modifyPrefixList(request: ModifyPrefixListRequest): ModifyPrefixListResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyPrefixList', 'POST', 'undefined', 'json', false, 'none', request);
}

model DescribeVRoutersRequest {
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  VRouterId?: string(name='VRouterId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  pageNumber?: int32(name='PageNumber', position='Query'),
  pageSize?: int32(name='PageSize', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
}

model DescribeVRoutersResponseBody = {
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  pageNumber?: int32(name='PageNumber'),
  totalCount?: int32(name='TotalCount'),
  VRouters?: {
    VRouter?: [ 
    {
      vpcId?: string(name='VpcId'),
      creationTime?: string(name='CreationTime'),
      VRouterId?: string(name='VRouterId'),
      description?: string(name='Description'),
      VRouterName?: string(name='VRouterName'),
      regionId?: string(name='RegionId'),
      routeTableIds?: {
        routeTableId?: [ string ](name='RouteTableId')
      }(name='RouteTableIds'),
    }
  ](name='VRouter')
  }(name='VRouters'),
}

model DescribeVRoutersResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeVRoutersResponseBody(name='body'),
}

async function describeVRouters(request: DescribeVRoutersRequest): DescribeVRoutersResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeVRouters', 'POST', 'undefined', 'json', false, 'none', request);
}

model DescribeNetworkInterfacesRequest {
  tag?: [ 
    {
      key?: string(name='Key', description='弹性网卡的标签值。N的取值范围：1~20

使用一个标签过滤资源，查询到该标签下的资源数量不能超过1000个；使用多个标签过滤资源，查询到同时绑定了多个标签的资源数量不能超过1000个。如果资源数量超过1000个，请使用[ListTagResources](~~110425~~)接口进行查询。'),
      value?: string(name='Value', description='弹性网卡的标签键。N的取值范围：1~20'),
    }
  ](name='Tag', position='Query'),
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', description='The ID of the resource master account, that is, the UID.', position='Query'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group. When you use this parameter to filter resources, the number of resources cannot exceed 1,000.', position='Query'),
  ownerId?: long(name='OwnerId', description='The ID of the RAM user.', position='Query'),
  ipv6Address?: [ string ](name='Ipv6Address', description='The IPv6 address of the Eni. N indicates that multiple IPv6 addresses can be set. Valid values of N: 1 to 100.', position='Query'),
  networkInterfaceId?: [ string ](name='NetworkInterfaceId', description='The ID of the Eni. Valid values of N: 1 to 100.', position='Query'),
  vpcId?: string(name='VpcId', description='The VPC ID of the VPC to which the Eni belongs.', position='Query'),
  pageNumber?: int32(name='PageNumber', description='The page number of the query result.

Start value: 1

Default value: 1.', position='Query'),
  type?: string(name='Type', description='The type of the Eni. Valid values:

-Primary: Primary Eni
-Secondary: Secondary Eni

Default value: null, indicating that all types are queried.', position='Query'),
  regionId?: string(name='RegionId', description='The region ID. You can call [DescribeRegions](~~ 25609 ~~) to view the latest region list.', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='The account name of the resource master account.', position='Query'),
  securityGroupId?: string(name='SecurityGroupId', description='The ID of the security group to which the secondary Eni belongs.

-If you want to query the information of the secondary Eni by using the security group ID, specify this parameter.
-To query the primary Eni information by using the security group ID, call [DescribeInstances](~~ 25506 ~~) to specify the "SecurityGroupId" parameter.', position='Query'),
  pageSize?: int32(name='PageSize', description='The number of entries to return on each page.

Maximum Value: 100

Default value: 10

For more information about how to view the returned data, see the preceding API description.', position='Query'),
  privateIpAddress?: [ string ](name='PrivateIpAddress', description='The secondary private IPv4 address of the Eni. Valid values of N: 1 to 100.', position='Query'),
  nextToken?: string(name='NextToken', description='The Token returned by the last API call.

For more information about how to view the returned data, see the preceding API description.', position='Query'),
  networkInterfaceName?: string(name='NetworkInterfaceName', description='The name of the Eni.', position='Query'),
  vSwitchId?: string(name='VSwitchId', description='The vSwitch ID of the VPC.', position='Query'),
  maxResults?: int32(name='MaxResults', description='The maximum number of entries returned. Valid values: 1 to 500.

Default value: 10', position='Query'),
  primaryIpAddress?: string(name='PrimaryIpAddress', description='The IPv4 address of the primary and private network of the Eni.', position='Query'),
  serviceManaged?: boolean(name='ServiceManaged', description='Whether the user of the Eni is a cloud product or a virtual merchant.', position='Query'),
  instanceId?: string(name='InstanceId', description='The ID of the instance associated with the Eni.', position='Query'),
  status?: string(name='Status', description='The NIC status. Valid values:

* Creating: Creating
* Available: Available
* Attaching: binding
* InUse: Bound
* Detaching: Unbinding
* Deleting: Deleting
* CreateFailed: Failed to be created, which is abnormal.

Default value: null, indicating that all statuses are queried.', position='Query'),
}

model DescribeNetworkInterfacesResponseBody = {
  nextToken?: string(name='NextToken', description='The query credential value returned by this call.'),
  requestId?: string(name='RequestId', description='The ID of the request.'),
  pageNumber?: int32(name='PageNumber', description='The page number of the returned data list.'),
  pageSize?: int32(name='PageSize', description='The number of entries to return on each page.'),
  totalCount?: int32(name='TotalCount', description='The total number of Enis returned.'),
  networkInterfaceSets?: {
    networkInterfaceSet?: [ 
    {
      status?: string(name='Status', description='The status of the Eni.'),
      type?: string(name='Type', description='The type of the Eni.'),
      vpcId?: string(name='VpcId', description='The VPC ID of the VPC to which the Eni belongs.'),
      creationTime?: string(name='CreationTime', description='The creation time.'),
      networkInterfaceName?: string(name='NetworkInterfaceName', description='The name of the Eni.'),
      networkInterfaceTrafficMode?: string(name='NetworkInterfaceTrafficMode', description='> This parameter is being invited for testing and is not currently available.'),
      macAddress?: string(name='MacAddress', description='The MAC address of the Eni.'),
      queuePairNumber?: int32(name='QueuePairNumber', description='> This parameter is being invited for testing and is not currently available.'),
      networkInterfaceId?: string(name='NetworkInterfaceId', description='The ID of the Eni.'),
      serviceID?: long(name='ServiceID', description='The ID of the virtual merchant corresponding to the Eni.'),
      instanceId?: string(name='InstanceId', description='The ID of the instance to which the Eni is bound.

> Enis managed and controlled by other Alibaba Cloud services do not return the instance ID.'),
      ownerId?: string(name='OwnerId', description='The ID of the account to which the Eni belongs.'),
      vSwitchId?: string(name='VSwitchId', description='The vSwitch ID of the VPC.'),
      serviceManaged?: boolean(name='ServiceManaged', description='Whether the user of the Eni is a cloud product or a virtual merchant.'),
      description?: string(name='Description', description='The description.'),
      resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group.'),
      zoneId?: string(name='ZoneId', description='The ID of the zone.'),
      privateIpAddress?: string(name='PrivateIpAddress', description='The private IP address of the Eni.'),
      queueNumber?: int32(name='QueueNumber', description='The number of Nic queues.

-If the secondary Eni is in the InUse state and the number of queues has not been changed, the default number of secondary Eni queues of the instance type is returned.
-If the secondary Eni has modified the number of queues, the modified number of queues is returned.
-If the secondary Eni is in the Available state and the number of queues has not been modified, the return value is null.
-The default number of queues for the primary Eni returned by the primary Eni.'),
      privateIpSets?: {
        privateIpSet?: [ 
        {
          privateIpAddress?: string(name='PrivateIpAddress', description='The private IP address of the instance.'),
          primary?: boolean(name='Primary', description='Indicates whether the private IP address is the primary IP address. Possible values:
-true: primary and private IP addresses
-false: secondary private IP address'),
        }
      ](name='PrivateIpSet')
      }(name='PrivateIpSets', description='A collection of PrivateIpSet.'),
      ipv6Sets?: {
        ipv6Set?: [ 
        {
          ipv6Address?: string(name='Ipv6Address', description='The IPv6 address specified for the Eni.'),
        }
      ](name='Ipv6Set')
      }(name='Ipv6Sets', description='The set of IPv6 addresses assigned to the Eni.'),
      tags?: {
        tag?: [ 
        {
          tagKey?: string(name='TagKey', description='The key of the tag.'),
          tagValue?: string(name='TagValue', description='The value of the tag.'),
        }
      ](name='Tag')
      }(name='Tags', description='The tag.'),
      securityGroupIds?: {
        securityGroupId?: [ string ](name='SecurityGroupId')
      }(name='SecurityGroupIds'),
      attachment?: {
        deviceIndex?: int32(name='DeviceIndex', description='> This parameter is being invited for testing and is not currently available.'),
        instanceId?: string(name='InstanceId', description='> This parameter is being invited for testing and is not currently available.'),
        trunkNetworkInterfaceId?: string(name='TrunkNetworkInterfaceId', description='> This parameter is being invited for testing and is not currently available.'),
      }(name='Attachment', description='> This parameter is being invited for testing and is not currently available.'),
    }
  ](name='NetworkInterfaceSet')
  }(name='NetworkInterfaceSets', description='A collection of Enis.'),
}

model DescribeNetworkInterfacesResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeNetworkInterfacesResponseBody(name='body'),
}

/**
 * ## API description

"DescribeNetworkInterfaces" supports the following two methods:

-Method 1: Use "NextToken" to set the Token. The value is the value of the "NextToken" parameter returned by the last call to "DescribeNetworkInterfaces". Then, use "maxresule" to set the maximum number of entries to query on a single page.

-Method 2: Set the number of entries returned on a single page by "PageSize", and then set the page number by "pagenumerber.

You can select either of the preceding methods. If an Eni returns a large number of entries, we recommend that you use method 1. If "NextToken" is set, the request parameters "PageSize" and "pagenumerber" are invalid, and the "TotalCount" in the returned data is invalid.


 */
async function describeNetworkInterfaces(request: DescribeNetworkInterfacesRequest): DescribeNetworkInterfacesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeNetworkInterfaces', 'POST', 'undefined', 'json', false, 'none', request);
}

model DescribeImageFromFamilyRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  regionId?: string(name='RegionId', description='The region ID of the image. You can call [DescribeRegions](~~ 25609 ~~) to view the latest region list.', position='Query'),
  imageFamily?: string(name='ImageFamily', description='The name of the Image family. The description must be 2 to 128 characters in length. It must start with a letter and cannot start with http://, https://, acs:, or aliyun. It can contain numbers, colons (:), underscores (_), and hyphens (-).', position='Query'),
}

model DescribeImageFromFamilyResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.'),
  image?: {
    creationTime?: string(name='CreationTime', description='The time when the image was created.'),
    status?: string(name='Status', description='The status of the image. Possible values:
-UnAvailable: UnAvailable
-Available: Available
-Creating: Creating
-CreateFailed: Failed to be created.'),
    imageFamily?: string(name='ImageFamily', description='The image family is.'),
    progress?: string(name='Progress', description='The progress of the image completion. Unit: percentage.'),
    isCopied?: boolean(name='IsCopied', description='Indicates whether the image is copied.'),
    isSupportIoOptimized?: boolean(name='IsSupportIoOptimized', description='Indicates whether it can be run on I/O optimized instances.'),
    imageOwnerAlias?: string(name='ImageOwnerAlias', description='The alias of the image owner. Possible values:
-system: public image.
-self: your custom image.
-others: public images of other users.
-marketplace: Alibaba Cloud marketplace image.'),
    isSupportCloudinit?: boolean(name='IsSupportCloudinit', description='Indicates whether cloud-init is supported.'),
    imageVersion?: string(name='ImageVersion', description='The version of the image.'),
    usage?: string(name='Usage', description='The type of the resource to be referenced. Possible values:
-instance: one or more ECS instances are created.
-none: no ECS instance has been created.'),
    isSelfShared?: string(name='IsSelfShared', description='Indicates whether the custom image has been shared with other users.'),
    description?: string(name='Description', description='The description.'),
    size?: int32(name='Size', description='The size of the image. Unit: GiB.'),
    platform?: string(name='Platform', description='The operating system platform.'),
    imageName?: string(name='ImageName', description='The name of the image.'),
    OSName?: string(name='OSName', description='The Chinese display name of the operating system.'),
    imageId?: string(name='ImageId', description='The ID of the image.'),
    OSType?: string(name='OSType', description='The operating system type. Possible values:
-Windows
-linux'),
    isSubscribed?: boolean(name='IsSubscribed', description='Indicates whether you have subscribed to the terms of service of the image product corresponding to the image product code.'),
    productCode?: string(name='ProductCode', description='The ID of the image product in the marketplace.'),
    architecture?: string(name='Architecture', description='The architecture type of the image system. Possible values:
-i386
-x86_64'),
    diskDeviceMappings?: {
      diskDeviceMapping?: [ 
      {
        type?: string(name='Type', description='The type of the image.'),
        importOSSBucket?: string(name='ImportOSSBucket', description='The OSS Bucket to which the imported Image belongs.'),
        snapshotId?: string(name='SnapshotId', description='The ID of the snapshot.'),
        importOSSObject?: string(name='ImportOSSObject', description='The OSS Object to which the imported Image belongs.'),
        size?: string(name='Size', description='The size of the disk. Unit: GiB.'),
        device?: string(name='Device', description='The device information of the cloud disk, such as/dev/xvdb.
> This parameter will be discontinued soon. We recommend that you do not use this parameter to improve code compatibility.'),
        format?: string(name='Format', description='The image format.'),
      }
    ](name='DiskDeviceMapping')
    }(name='DiskDeviceMappings', description='The mapping between disks and snapshots in an image.'),
    tags?: {
      tag?: [ 
      {
        tagValue?: string(name='TagValue', description='The tag value of the custom image.'),
        tagKey?: string(name='TagKey', description='The tag key of the custom image.'),
      }
    ](name='Tag')
    }(name='Tags', description='The tag pair of the image.'),
  }(name='Image', description='The returned image information.'),
}

model DescribeImageFromFamilyResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeImageFromFamilyResponseBody(name='body'),
}

/**
 * ## API description
-This operation only queries the newly created custom images in the current image family, excluding public images, Alibaba Cloud marketplace images, and shared images.
-If no custom image is available for the specified Image family, the returned result is null.
 */
async function describeImageFromFamily(request: DescribeImageFromFamilyRequest): DescribeImageFromFamilyResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeImageFromFamily', 'POST', 'undefined', 'json', false, 'none', request);
}

model UnassociateHaVipRequest {
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  clientToken?: string(name='ClientToken', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  haVipId?: string(name='HaVipId', position='Query'),
  instanceId?: string(name='InstanceId', position='Query'),
  force?: string(name='Force', position='Query'),
}

model UnassociateHaVipResponseBody = {
  requestId?: string(name='RequestId'),
}

model UnassociateHaVipResponse = {
  headers: map[string]string(name='headers'),
  body: UnassociateHaVipResponseBody(name='body'),
}

async function unassociateHaVip(request: UnassociateHaVipRequest): UnassociateHaVipResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UnassociateHaVip', 'POST', 'undefined', 'json', false, 'none', request);
}

model ModifyHaVipAttributeRequest {
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  clientToken?: string(name='ClientToken', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  haVipId?: string(name='HaVipId', position='Query'),
  description?: string(name='Description', position='Query'),
}

model ModifyHaVipAttributeResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyHaVipAttributeResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyHaVipAttributeResponseBody(name='body'),
}

async function modifyHaVipAttribute(request: ModifyHaVipAttributeRequest): ModifyHaVipAttributeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyHaVipAttribute', 'POST', 'undefined', 'json', false, 'none', request);
}

model AttachClassicLinkVpcRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='The account name of the resource master account.', position='Query'),
  vpcId?: string(name='VpcId', description='Enable the ClassicLink of the VPC ID. You can call [DescribeVpcs](~~ 35739 ~~) to view the available VPCs.', position='Query'),
  regionId?: string(name='RegionId', description='The ID of the region to which the instance belongs. You can call [DescribeRegions](~~ 25609 ~~) to view the latest region list.', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', description='The ID of the resource master account, that is, the UID.', position='Query'),
  ownerId?: long(name='OwnerId', description='The ID of the RAM user.', position='Query'),
  instanceId?: string(name='InstanceId', description='The ID of the classic network instance. You can call [DescribeInstances](~~ 25506 ~~) to view the available instances.', position='Query'),
}

model AttachClassicLinkVpcResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.'),
}

model AttachClassicLinkVpcResponse = {
  headers: map[string]string(name='headers'),
  body: AttachClassicLinkVpcResponseBody(name='body'),
}

/**
 * ## API description

When you call this operation, note that:

-Before connecting to an instance of the classic network type, the instance must be in the **Running**(Running) or **Stopped**(Stopped) status.

-The target VPC must have [ClassicLink enabled](~~ 65413 ~~).

-The classic network instance and the VPC must be in the same Alibaba Cloud region.
 */
async function attachClassicLinkVpc(request: AttachClassicLinkVpcRequest): AttachClassicLinkVpcResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'AttachClassicLinkVpc', 'POST', 'undefined', 'json', false, 'none', request);
}

model DescribeSnapshotGroupsRequest {
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  additionalAttributes?: [ string ](name='AdditionalAttributes', position='Query'),
  name?: string(name='Name', description='The name of the instance snapshot.', position='Query'),
  instanceId?: string(name='InstanceId', description='The ID of the instance.', position='Query'),
  regionId?: string(name='RegionId', description='Belongs geo ID. You can call [DescribeRegions](~~ 25609 ~~) to view the latest region list.', position='Query'),
  status?: [ string ](name='Status', description='The status of the instance snapshot. Valid values:

-progressing: creating

-accomplished: created.

-failed: failed to be created.

Valid values of N: 1 to 3.', position='Query'),
  maxResults?: int32(name='MaxResults', description='The number of entries to return on each page.

Maximum Value: 100

Default value: 10', position='Query'),
  nextToken?: string(name='NextToken', description='The Token of the query. The value is the NextToken parameter returned by the last API call.', position='Query'),
  snapshotGroupId?: [ string ](name='SnapshotGroupId', description='The ID of the instance snapshot. Valid values of N: 1 to 10.', position='Query'),
}

model DescribeSnapshotGroupsResponseBody = {
  nextToken?: string(name='NextToken', description='The start flag of the next query.'),
  requestId?: string(name='RequestId', description='The ID of the request.'),
  snapshotGroups?: {
    snapshotGroup?: [ 
    {
      status?: string(name='Status', description='The status of the instance snapshot. Valid values:

-progressing: creating

-accomplished: created.

-failed: failed to be created.'),
      creationTime?: string(name='CreationTime', description='The creation time.'),
      description?: string(name='Description', description='The description.'),
      progressStatus?: string(name='ProgressStatus', description='> This parameter is not available.'),
      snapshotGroupId?: string(name='SnapshotGroupId', description='The ID of the instance snapshot.'),
      instanceId?: string(name='InstanceId', description='The ID of the instance to which the snapshot belongs.'),
      name?: string(name='Name', description='The name of the instance snapshot.'),
      snapshots?: {
        snapshot?: [ 
        {
          sourceDiskId?: string(name='SourceDiskId', description='The ID of the source disk. This field is retained if the source disk of the snapshot is released.'),
          progress?: string(name='Progress', description='The progress of snapshot creation. Unit: percentage.'),
          instantAccessRetentionDays?: int32(name='InstantAccessRetentionDays', description='The retention period of the snapshot feature. The snapshot is automatically released when the retention period expires.'),
          snapshotId?: string(name='SnapshotId', description='The ID of the snapshot.'),
          instantAccess?: boolean(name='InstantAccess', description='Indicates whether the snapshot extreme availability feature is enabled. Possible values:

-true: enabled. Only ESSDS support this feature.
-false: disabled. That is, a snapshot is a normal snapshot that is not enabled.'),
          sourceDiskType?: string(name='SourceDiskType', description='The type of the source disk. Possible values:

-system: system disk
-data: data disk'),
        }
      ](name='Snapshot')
      }(name='Snapshots', description='An array of snapshot information contained in an instance snapshot.'),
    }
  ](name='SnapshotGroup')
  }(name='SnapshotGroups', description='An array of instance snapshots.'),
}

model DescribeSnapshotGroupsResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeSnapshotGroupsResponseBody(name='body'),
}

/**
 * ## API description

"InstanceId", "SnapshotGroupId. **, And "Status.** are not required request parameters, but filter logic can be constructed. The relationship between parameters is logical And (And).
 */
async function describeSnapshotGroups(request: DescribeSnapshotGroupsRequest): DescribeSnapshotGroupsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeSnapshotGroups', 'POST', 'undefined', 'json', false, 'none', request);
}

model AttachInstanceRamRoleRequest {
  sourceRegionId?: string(name='SourceRegionId', position='Host'),
  instanceIds?: string(name='InstanceIds', description='The ID of the instance. The value can be a JSON Array consisting of multiple instance IDs. A maximum of 100 IDs can be entered. Separate IDs with commas (,).', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='The account name of the resource master account.', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', description='The ID of the resource master account, that is, the UID.', position='Query'),
  regionId?: string(name='RegionId', description='The ID of the region. You can call [DescribeRegions](~~ 25609 ~~) to view the latest region list.', position='Query'),
  policy?: string(name='Policy', description='The policy. The description must be 1 to 1024 characters in length. When you grant an instance RAM role to one or more ECS instances, you can specify an additional policy to further restrict the permissions of the RAM role. For more information, see [Policy Overview](~~ 93732 ~~).
', position='Query'),
  ramRoleName?: string(name='RamRoleName', description='The name of the instance RAM role. You can use the RAM API [ListRoles](~~ 28713 ~~) to query the created instance RAM role.', position='Query'),
  ownerId?: long(name='OwnerId', description='The ID of the RAM user.', position='Query'),
}

model AttachInstanceRamRoleResponseBody = {
  ramRoleName?: string(name='RamRoleName', description='The name of the instance RAM role.'),
  requestId?: string(name='RequestId', description='The ID of the request.'),
  totalCount?: int32(name='TotalCount', description='The total number of RAM roles granted to the instance.'),
  failCount?: int32(name='FailCount', description='The number of failures to grant the instance RAM role.'),
  attachInstanceRamRoleResults?: {
    attachInstanceRamRoleResult?: [ 
    {
      code?: string(name='Code', description='Determines whether the instance RAM role is granted. A value of 200 indicates that the application is successfully granted. A value other than 200 indicates that the application fails. For more information, see error codes.'),
      message?: string(name='Message', description='Determines whether the instance RAM role is granted. If the return value is Success, the authorization is successful. If the return value is other, the authorization fails. For more information, see error codes.'),
      instanceId?: string(name='InstanceId', description='The ID of the instance.'),
      success?: boolean(name='Success', description='Indicates whether the instance RAM role is granted.'),
    }
  ](name='AttachInstanceRamRoleResult')
  }(name='AttachInstanceRamRoleResults', description='The information set of the instance RAM role type (AttachInstanceRamRoleResult).'),
}

model AttachInstanceRamRoleResponse = {
  headers: map[string]string(name='headers'),
  body: AttachInstanceRamRoleResponseBody(name='body'),
}

async function attachInstanceRamRole(request: AttachInstanceRamRoleRequest): AttachInstanceRamRoleResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'AttachInstanceRamRole', 'POST', 'undefined', 'json', false, 'none', request);
}

model ModifyVRouterAttributeRequest {
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  VRouterId?: string(name='VRouterId', position='Query'),
  VRouterName?: string(name='VRouterName', position='Query'),
  description?: string(name='Description', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
}

model ModifyVRouterAttributeResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyVRouterAttributeResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyVRouterAttributeResponseBody(name='body'),
}

async function modifyVRouterAttribute(request: ModifyVRouterAttributeRequest): ModifyVRouterAttributeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyVRouterAttribute', 'POST', 'undefined', 'json', false, 'none', request);
}

